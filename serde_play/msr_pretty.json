{
  "decode": {
    "lines": []
  },
  "encodings": [
    {
      "bits": [
        {
          "name": "!=1111",
          "size": 4,
          "type": 4
        },
        {
          "name": "0 0 0 1 0",
          "size": 5,
          "type": 5
        },
        {
          "name": "R",
          "size": 1,
          "type": 1
        },
        {
          "name": "1 0",
          "size": 2,
          "type": 5
        },
        {
          "name": "M1",
          "size": 4,
          "type": 3
        },
        {
          "name": "(1) (1) (1) (1) (0) (0) 1",
          "size": 7,
          "type": 5
        },
        {
          "name": "M",
          "size": 1,
          "type": 3
        },
        {
          "name": "0 0 0 0",
          "size": 4,
          "type": 5
        },
        {
          "name": "Rn",
          "size": 4,
          "type": 1
        }
      ],
      "decode": [
        "n = UInt(Rn); write_spsr = (R == '1');",
        "if n == 15 then UNPREDICTABLE;",
        "SYSm = M:M1;"
      ],
      "mask": "0x0120f200",
      "mnemonics": [
        {
          "constraint": "",
          "mnemonics": [
            {
              "aliases": [],
              "value": "MSR{<c>}{<q>} <banked_reg>, <Rn>"
            }
          ],
          "name": "A1 variant"
        }
      ],
      "name": "A1",
      "variant": "[Arm Bits32 Archetype (0x200000021)]"
    },
    {
      "bits": [
        {
          "name": "1 1 1 1 0 0 1 1 1 0 0",
          "size": 11,
          "type": 5
        },
        {
          "name": "R",
          "size": 1,
          "type": 1
        },
        {
          "name": "Rn",
          "size": 4,
          "type": 1
        },
        {
          "name": "1 0 (0) 0",
          "size": 4,
          "type": 5
        },
        {
          "name": "M1",
          "size": 4,
          "type": 3
        },
        {
          "name": "(0) (0) 1",
          "size": 3,
          "type": 5
        },
        {
          "name": "M",
          "size": 1,
          "type": 3
        },
        {
          "name": "(0) (0) (0) (0)",
          "size": 4,
          "type": 5
        }
      ],
      "decode": [
        "n = UInt(Rn); write_spsr = (R == '1');",
        "if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
        "SYSm = M:M1;"
      ],
      "mask": "0xf3808020",
      "mnemonics": [
        {
          "constraint": "",
          "mnemonics": [
            {
              "aliases": [],
              "value": "MSR{<c>}{<q>} <banked_reg>, <Rn>"
            }
          ],
          "name": "T1 variant"
        }
      ],
      "name": "T1",
      "variant": "[Thumb Bits32 Archetype (0x200000022)]"
    }
  ],
  "id": "116",
  "names": [
    "MSR",
    "(Banked register)"
  ],
  "operation": {
    "lines": [
      "if ConditionPassed() then",
      "    EncodingSpecificOperations();",
      "    if PSTATE.EL == EL0 then",
      "        UNPREDICTABLE;",
      "    else",
      "        mode = PSTATE.M;",
      "        if write_spsr then",
      "            SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases",
      "            case SYSm of",
      "                when '01110' SPSR_fiq = R[n];",
      "                when '10000' SPSR_irq = R[n];",
      "                when '10010' SPSR_svc = R[n];",
      "                when '10100' SPSR_abt = R[n];",
      "                when '10110' SPSR_und = R[n];",
      "                when '11100'",
      "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
      "                    SPSR_mon = R[n];",
      "                when '11110' SPSR_hyp = R[n];",
      "        else",
      "            BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases",
      "            case SYSm of",
      "                when '00xxx'                       // Access the User mode registers",
      "                    m = UInt(SYSm<2:0>) + 8;",
      "                    Rmode[m,M32_User] = R[n];",
      "                when '01xxx'                       // Access the FIQ mode registers",
      "                    m = UInt(SYSm<2:0>) + 8;",
      "                    Rmode[m,M32_FIQ] = R[n];",
      "                when '1000x'                       // Access the IRQ mode registers",
      "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
      "                    Rmode[m,M32_IRQ] = R[n];",
      "                when '1001x'                       // Access the Supervisor mode regsiters",
      "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
      "                    Rmode[m,M32_Svc] = R[n];",
      "                when '1010x'                       // Access the Abort mode registers",
      "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
      "                    Rmode[m,M32_Abort] = R[n];",
      "                when '1011x'                       // Access the Undefined mode registers",
      "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
      "                    Rmode[m,M32_Undef] = R[n];",
      "                when '1110x'                       // Access Monitor registers",
      "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
      "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
      "                    Rmode[m,M32_Monitor] = R[n];",
      "                when '11110'                       // Access ELR_hyp register",
      "                    ELR_hyp = R[n];",
      "                when '11111'                       // Access SP_hyp register",
      "                    Rmode[13,M32_Hyp] = R[n];"
    ]
  },
  "summary": {
    "lines": [
      "Move to Banked or Special register from general-purpose register moves the value of a general-purpose register to",
      "the Banked general-purpose register or SPSR of the specified mode, or to ELR_hyp on page G1-3817.",
      "MSR (Banked register) is UNPREDICTABLE if executed in User mode.",
      "The effect of using an MSR (Banked register) instruction with a register argument that is not valid for the current mode",
      "is UNPREDICTABLE. For more information see Usage restrictions on the Banked register transfer instructions on",
      "page F7-3256."
    ]
  },
  "symbols": {
    "lines": [
      "<c>                See Standard assembler syntax fields on page F2-2506.",
      "<q>                See Standard assembler syntax fields on page F2-2506.",
      "<banked_reg>       Is the name of the banked register to be transferred to or from, encoded in the \"R:M:M1\" field. It",
      "                   can have the following values:",
      "                   R8_usr                 when R = 0, M = 0, M1 = 0000",
      "                   R9_usr                 when R = 0, M = 0, M1 = 0001",
      "                     R10_usr                  when R = 0, M = 0, M1 = 0010",
      "                     R11_usr                  when R = 0, M = 0, M1 = 0011",
      "                     R12_usr                  when R = 0, M = 0, M1 = 0100",
      "                     SP_usr                   when R = 0, M = 0, M1 = 0101",
      "                     LR_usr                   when R = 0, M = 0, M1 = 0110",
      "                     UNPREDICTABLE            when R = 0, M = 0, M1 = 0111",
      "                     R8_fiq                   when R = 0, M = 0, M1 = 1000",
      "                     R9_fiq                   when R = 0, M = 0, M1 = 1001",
      "                     R10_fiq                  when R = 0, M = 0, M1 = 1010",
      "                     R11_fiq                  when R = 0, M = 0, M1 = 1011",
      "                     R12_fiq                  when R = 0, M = 0, M1 = 1100",
      "                     SP_fiq                   when R = 0, M = 0, M1 = 1101",
      "                     LR_fiq                   when R = 0, M = 0, M1 = 1110",
      "                     UNPREDICTABLE            when R = 0, M = 0, M1 = 1111",
      "                     LR_irq                   when R = 0, M = 1, M1 = 0000",
      "                     SP_irq                   when R = 0, M = 1, M1 = 0001",
      "                     LR_svc                   when R = 0, M = 1, M1 = 0010",
      "                     SP_svc                   when R = 0, M = 1, M1 = 0011",
      "                     LR_abt                   when R = 0, M = 1, M1 = 0100",
      "                     SP_abt                   when R = 0, M = 1, M1 = 0101",
      "                     LR_und                   when R = 0, M = 1, M1 = 0110",
      "                     SP_und                   when R = 0, M = 1, M1 = 0111",
      "                     UNPREDICTABLE            when R = 0, M = 1, M1 = 10xx",
      "                     LR_mon                   when R = 0, M = 1, M1 = 1100",
      "                     SP_mon                   when R = 0, M = 1, M1 = 1101",
      "                     ELR_hyp                  when R = 0, M = 1, M1 = 1110",
      "                     SP_hyp                   when R = 0, M = 1, M1 = 1111",
      "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 0xxx",
      "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 10xx",
      "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 110x",
      "                     SPSR_fiq                 when R = 1, M = 0, M1 = 1110",
      "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 1111",
      "                     SPSR_irq                 when R = 1, M = 1, M1 = 0000",
      "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0001",
      "                     SPSR_svc                 when R = 1, M = 1, M1 = 0010",
      "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0011",
      "                     SPSR_abt                 when R = 1, M = 1, M1 = 0100",
      "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0101",
      "                     SPSR_und                 when R = 1, M = 1, M1 = 0110",
      "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0111",
      "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 10xx",
      "                     SPSR_mon                 when R = 1, M = 1, M1 = 1100",
      "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 1101",
      "                     SPSR_hyp                 when R = 1, M = 1, M1 = 1110",
      "             UNPREDICTABLE           when R = 1, M = 1, M1 = 1111",
      "<Rn>         Is the general-purpose source register, encoded in the \"Rn\" field."
    ]
  }
}
