{
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "M1",
              "size": 4,
              "type": 3
            },
            {
              "name": "(1) (1) (1) (1) (0) (0) 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); write_spsr = (R == '1');",
            "if n == 15 then UNPREDICTABLE;",
            "SYSm = M:M1;"
          ],
          "mask": "0x0120f200",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <banked_reg>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 (0) 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "M1",
              "size": 4,
              "type": 3
            },
            {
              "name": "(0) (0) 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            }
          ],
          "decode": [
            "n = UInt(Rn); write_spsr = (R == '1');",
            "if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "SYSm = M:M1;"
          ],
          "mask": "0xf3808020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <banked_reg>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "116",
      "names": [
        "MSR",
        "(Banked register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL0 then",
          "        UNPREDICTABLE;",
          "    else",
          "        mode = PSTATE.M;",
          "        if write_spsr then",
          "            SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases",
          "            case SYSm of",
          "                when '01110' SPSR_fiq = R[n];",
          "                when '10000' SPSR_irq = R[n];",
          "                when '10010' SPSR_svc = R[n];",
          "                when '10100' SPSR_abt = R[n];",
          "                when '10110' SPSR_und = R[n];",
          "                when '11100'",
          "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
          "                    SPSR_mon = R[n];",
          "                when '11110' SPSR_hyp = R[n];",
          "        else",
          "            BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases",
          "            case SYSm of",
          "                when '00xxx'                       // Access the User mode registers",
          "                    m = UInt(SYSm<2:0>) + 8;",
          "                    Rmode[m,M32_User] = R[n];",
          "                when '01xxx'                       // Access the FIQ mode registers",
          "                    m = UInt(SYSm<2:0>) + 8;",
          "                    Rmode[m,M32_FIQ] = R[n];",
          "                when '1000x'                       // Access the IRQ mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_IRQ] = R[n];",
          "                when '1001x'                       // Access the Supervisor mode regsiters",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Svc] = R[n];",
          "                when '1010x'                       // Access the Abort mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Abort] = R[n];",
          "                when '1011x'                       // Access the Undefined mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Undef] = R[n];",
          "                when '1110x'                       // Access Monitor registers",
          "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Monitor] = R[n];",
          "                when '11110'                       // Access ELR_hyp register",
          "                    ELR_hyp = R[n];",
          "                when '11111'                       // Access SP_hyp register",
          "                    Rmode[13,M32_Hyp] = R[n];"
        ]
      },
      "summary": {
        "lines": [
          "Move to Banked or Special register from general-purpose register moves the value of a general-purpose register to",
          "the Banked general-purpose register or SPSR of the specified mode, or to ELR_hyp on page G1-3817.",
          "MSR (Banked register) is UNPREDICTABLE if executed in User mode.",
          "The effect of using an MSR (Banked register) instruction with a register argument that is not valid for the current mode",
          "is UNPREDICTABLE. For more information see Usage restrictions on the Banked register transfer instructions on",
          "page F7-3256."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<banked_reg>       Is the name of the banked register to be transferred to or from, encoded in the \"R:M:M1\" field. It",
          "                   can have the following values:",
          "                   R8_usr                 when R = 0, M = 0, M1 = 0000",
          "                   R9_usr                 when R = 0, M = 0, M1 = 0001",
          "                     R10_usr                  when R = 0, M = 0, M1 = 0010",
          "                     R11_usr                  when R = 0, M = 0, M1 = 0011",
          "                     R12_usr                  when R = 0, M = 0, M1 = 0100",
          "                     SP_usr                   when R = 0, M = 0, M1 = 0101",
          "                     LR_usr                   when R = 0, M = 0, M1 = 0110",
          "                     UNPREDICTABLE            when R = 0, M = 0, M1 = 0111",
          "                     R8_fiq                   when R = 0, M = 0, M1 = 1000",
          "                     R9_fiq                   when R = 0, M = 0, M1 = 1001",
          "                     R10_fiq                  when R = 0, M = 0, M1 = 1010",
          "                     R11_fiq                  when R = 0, M = 0, M1 = 1011",
          "                     R12_fiq                  when R = 0, M = 0, M1 = 1100",
          "                     SP_fiq                   when R = 0, M = 0, M1 = 1101",
          "                     LR_fiq                   when R = 0, M = 0, M1 = 1110",
          "                     UNPREDICTABLE            when R = 0, M = 0, M1 = 1111",
          "                     LR_irq                   when R = 0, M = 1, M1 = 0000",
          "                     SP_irq                   when R = 0, M = 1, M1 = 0001",
          "                     LR_svc                   when R = 0, M = 1, M1 = 0010",
          "                     SP_svc                   when R = 0, M = 1, M1 = 0011",
          "                     LR_abt                   when R = 0, M = 1, M1 = 0100",
          "                     SP_abt                   when R = 0, M = 1, M1 = 0101",
          "                     LR_und                   when R = 0, M = 1, M1 = 0110",
          "                     SP_und                   when R = 0, M = 1, M1 = 0111",
          "                     UNPREDICTABLE            when R = 0, M = 1, M1 = 10xx",
          "                     LR_mon                   when R = 0, M = 1, M1 = 1100",
          "                     SP_mon                   when R = 0, M = 1, M1 = 1101",
          "                     ELR_hyp                  when R = 0, M = 1, M1 = 1110",
          "                     SP_hyp                   when R = 0, M = 1, M1 = 1111",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 0xxx",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 10xx",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 110x",
          "                     SPSR_fiq                 when R = 1, M = 0, M1 = 1110",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 1111",
          "                     SPSR_irq                 when R = 1, M = 1, M1 = 0000",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0001",
          "                     SPSR_svc                 when R = 1, M = 1, M1 = 0010",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0011",
          "                     SPSR_abt                 when R = 1, M = 1, M1 = 0100",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0101",
          "                     SPSR_und                 when R = 1, M = 1, M1 = 0110",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0111",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 10xx",
          "                     SPSR_mon                 when R = 1, M = 1, M1 = 1100",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 1101",
          "                     SPSR_hyp                 when R = 1, M = 1, M1 = 1110",
          "             UNPREDICTABLE           when R = 1, M = 1, M1 = 1111",
          "<Rn>         Is the general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
},
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "0 0 (1) (1) (1) (1)",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 0 (0) 0 0 0 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); read_spsr = (R == '1');",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x010f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRS{<c>}{<q>} <Rd>, <spec_reg>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 (0) 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 0 (0) (0) (0) (0) (0)",
              "size": 8,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); read_spsr = (R == '1');",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3ef8000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRS{<c>}{<q>} <Rd>, <spec_reg>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "114",
      "names": [
        "MRS",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if read_spsr then",
          "        if PSTATE.M IN {M32_User,M32_System} then",
          "            UNPREDICTABLE;",
          "        else",
          "            R[d] = SPSR[];",
          "    else",
          "        // CPSR has same bit assignments as SPSR, but with the IT, J, SS, IL, and T bits masked out.",
          "        psr_val = GetPSRFromPSTATE() AND '11111000 00001111 00000011 11011111';",
          "        if PSTATE.EL == EL0 then",
          "            // If accessed from User mode return UNKNOWN values for E, A, I, F bits, bits<9:6>,",
          "            // and for the M field, bits<4:0>",
          "            psr_val<9:6> = bits(4) UNKNOWN;",
          "            psr_val<4:0> = bits(5) UNKNOWN;",
          "        R[d] = psr_val;"
        ]
      },
      "summary": {
        "lines": [
          "Move Special register to general-purpose register moves the value of the The Application Program Status Register,",
          "APSR on page E1-2382, CPSR, or SPSR_<current_mode> into a general-purpose register.",
          "ARM recommends the APSR form when only the N, Z, C, V, Q, and GE[3:0] bits are being written. For more",
          "information, see The Application Program Status Register, APSR on page E1-2382.",
          "An MRS that accesses the SPSR is UNPREDICTABLE if executed in User mode or System mode.",
          "An MRS that is executed in User mode and accesses the CPSR returns an UNKNOWN value for the CPSR.{E, A, I, F,",
          "M} fields."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<spec_reg>         Is the special register to be accessed, encoded in the \"R\" field. It can have the following values:",
          "                   CPSR|APSR when R = 0",
          "                   SPSR        when R = 1"
        ]
      }
    }

}
