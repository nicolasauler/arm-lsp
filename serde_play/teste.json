[
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       n = UInt(Rn);   setflags = (S == '1');    imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02a00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADCS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf1400000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADCS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "1",
      "names": [
        "ADC",
        "ADCS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(R[n], imm32, PSTATE.C);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add with Carry (immediate) adds an immediate value and the Carry flag value to a register value, and writes the",
          "result to the destination register.",
          "If the destination register is not the PC, the ADCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The ADC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ADCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                PC is used:",
          "                       For the ADC variant, the instruction is a branch to the address calculated by the operation.",
          "                        This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the ADCS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>.",
          "<Rn>            For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                used.",
          "                For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                page F4-2559 for the range of values.",
          "                For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "                page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00a00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADCS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);                 setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004140",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ADCS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 0 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeb400000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADCS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "2",
      "names": [
        "ADC",
        "ADCS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "           R[d] = result;",
          "           if setflags then",
          "               PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add with Carry (register) adds a register value, the Carry flag value, and an optionally-shifted register value, and",
          "writes the result to the destination register.",
          "If the destination register is not the PC, the ADCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The ADC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The ADCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>               See Standard assembler syntax fields on page F2-2506.",
          "<q>               See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>             Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>              For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                  PC is used:",
          "                         For the ADC variant, the instruction is a branch to the address calculated by the operation.",
          "                          This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                          general-purpose registers and the PC on page E1-2378.",
          "                         For the ADCS variant, the instruction performs an exception return, that restores PSTATE",
          "                          from SPSR_<current_mode>.",
          "                  For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>.",
          "<Rn>              For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                  be used.",
          "                  For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>              For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                  can be used.",
          "                  For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>           Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                  the following values:",
          "                  LSL          when type = 00",
          "                  LSR          when type = 01",
          "                  ASR          when type = 10",
          "                  ROR          when type = 11",
          "<amount>          Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                  LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "In T32 assembly:",
          "        Outside an IT block, if ADCS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though ADCS <Rd>, <Rn> had been written.",
          "        Inside an IT block, if ADC<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though ADC<c> <Rd>, <Rn> had been written.",
          "To prevent either of these happening, use the .W qualifier."
        ]
      }
    }
]
