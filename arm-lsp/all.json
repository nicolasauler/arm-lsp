[
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       n = UInt(Rn);   setflags = (S == '1');    imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02a00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADCS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf1400000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADCS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "1",
      "names": [
        "ADC",
        "ADCS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(R[n], imm32, PSTATE.C);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add with Carry (immediate) adds an immediate value and the Carry flag value to a register value, and writes the",
          "result to the destination register.",
          "If the destination register is not the PC, the ADCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The ADC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ADCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                PC is used:",
          "                       For the ADC variant, the instruction is a branch to the address calculated by the operation.",
          "                        This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the ADCS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>.",
          "<Rn>            For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                used.",
          "                For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                page F4-2559 for the range of values.",
          "                For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "                page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00a00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADCS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);                 setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004140",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ADCS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 0 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeb400000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADCS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "2",
      "names": [
        "ADC",
        "ADCS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "           R[d] = result;",
          "           if setflags then",
          "               PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add with Carry (register) adds a register value, the Carry flag value, and an optionally-shifted register value, and",
          "writes the result to the destination register.",
          "If the destination register is not the PC, the ADCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The ADC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The ADCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>               See Standard assembler syntax fields on page F2-2506.",
          "<q>               See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>             Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>              For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                  PC is used:",
          "                         For the ADC variant, the instruction is a branch to the address calculated by the operation.",
          "                          This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                          general-purpose registers and the PC on page E1-2378.",
          "                         For the ADCS variant, the instruction performs an exception return, that restores PSTATE",
          "                          from SPSR_<current_mode>.",
          "                  For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>.",
          "<Rn>              For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                  be used.",
          "                  For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>              For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                  can be used.",
          "                  For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>           Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                  the following values:",
          "                  LSL          when type = 00",
          "                  LSR          when type = 01",
          "                  ASR          when type = 10",
          "                  ROR          when type = 11",
          "<amount>          Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                  LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "In T32 assembly:",
          "        Outside an IT block, if ADCS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though ADCS <Rd>, <Rn> had been written.",
          "        Inside an IT block, if ADC<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though ADC<c> <Rd>, <Rn> had been written.",
          "To prevent either of these happening, use the .W qualifier."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00a00010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "3",
      "names": [
        "ADC",
        "ADCS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add with Carry (register-shifted register) adds a register value, the Carry flag value, and a register-shifted register",
          "value. It writes the result to the destination register, and can optionally update the condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' && S == '0' then SEE ADR;",
            "if Rn == '1101' then SEE ADD (SP plus immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');              imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02800000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADD variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADDS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       n = UInt(Rn);   setflags = !InITBlock();        imm32 = ZeroExtend(imm3, 32);"
          ],
          "mask": "0x00001c00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD<c>{<q>} <Rd>, <Rn>, #<imm3>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ADDS{<q>} <Rd>, <Rn>, #<imm3>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "0 0 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rdn);    n = UInt(Rdn);    setflags = !InITBlock();         imm32 = ZeroExtend(imm8, 32);"
          ],
          "mask": "0x00003000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD<c>{<q>} <Rdn>, #<imm8>// Inside IT block, and <Rdn>, <imm8> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADD<c>{<q>} {<Rdn>,} <Rdn>, #<imm8>// Inside IT block, and <Rdn>, <imm8> cannot be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADDS{<q>} <Rdn>, #<imm8>// Outside IT block, and <Rdn>, <imm8> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADDS{<q>} {<Rdn>,} <Rdn>, #<imm8>// Outside IT block, and <Rdn>, <imm8> cannot be represented in T1"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMN (immediate);",
            "if Rn == '1101' then SEE ADD (SP plus immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf1000000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD<c>.W {<Rd>,} <Rn>, #<const>// Inside IT block, and <Rd>, <Rn>, <const> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADD variant"
            },
            {
              "constraint": " S = 1 && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS.W {<Rd>,} <Rn>, #<const>// Outside IT block, and <Rd>, <Rn>, <const> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ADDS variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "!=11x1",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE ADR;",
            "if Rn == '1101' then SEE ADD (SP plus immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = FALSE; imm32 = ZeroExtend(i:imm3:imm8, 32);",
            "if d == 15 then UNPREDICTABLE;   // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf2000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>// <imm12> cannot be represented in T1, T2, or T3"
                },
                {
                  "aliases": [],
                  "value": "ADDW{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>// <imm12> can be represented in T1, T2, or T3"
                }
              ],
              "name": "T4 variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "4",
      "names": [
        "ADD",
        "ADDS (immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        (result, nzcv) = AddWithCarry(R[n], imm32, '0');",
          "        if d == 15 then          // Can only occur for A32 encoding",
          "            if setflags then",
          "                ALUExceptionReturn(result);",
          "            else",
          "                      ALUWritePC(result);",
          "              else",
          "                  R[d] = result;",
          "                  if setflags then",
          "                      PSTATE.<N,Z,C,V> = nzcv;",
          "     else",
          "         if ConditionPassed() then",
          "             EncodingSpecificOperations();",
          "             (result, nzcv) = AddWithCarry(R[n], imm32, '0');",
          "             R[d] = result;",
          "             if setflags then",
          "                 PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add (immediate) adds an immediate value to a register value, and writes the result to the destination register.",
          "If the destination register is not the PC, the ADDS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. If the",
          "destination register is the PC:",
          "          The ADD variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ADDS variant of the instruction performs an exception return without the use of the stack. ARM",
          "deprecates use of this instruction. However, in this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>          Is the general-purpose source and destination register, encoded in the \"Rdn\" field.",
          "<imm8>         Is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "<Rd>           For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "               this register is the same as <Rn>. If the PC is used:",
          "                      For the ADD variant, the instruction is a branch to the address calculated by the operation.",
          "                       This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                       general-purpose registers and the PC on page E1-2378.",
          "                      For the ADDS variant, the instruction performs an exception return, that restores PSTATE",
          "                       from SPSR_<current_mode>. ARM deprecates use of this instruction.",
          "               For encoding T1, T3 and T4: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "               If omitted, this register is the same as <Rn>.",
          "<Rn>           For encoding A1 and T4: is the general-purpose source register, encoded in the \"Rn\" field. If the SP",
          "               is used, see ADD, ADDS (SP plus immediate). If the PC is used, see ADR.",
          "               For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "               For encoding T3: is the general-purpose source register, encoded in the \"Rn\" field. If the SP is used,",
          "               see ADD, ADDS (SP plus immediate).",
          "<imm3>         Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"imm3\" field.",
          "<imm12>        Is a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.",
          "<const>        For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "               page F4-2559 for the range of values.",
          "               For encoding T3: an immediate value. See Modified immediate constants in T32 instructions on",
          "               page F3-2530 for the range of values.",
          "When multiple encodings of the same length are available for an instruction, encoding T3 is preferred to encoding",
          "T4 (if encoding T4 is required, use the ADDW syntax). Encoding T1 is preferred to encoding T2 if <Rd> is specified",
          "and encoding T2 is preferred to encoding T1 if <Rd> is omitted."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1101' then SEE ADD (SP plus register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00800000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADD, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADD, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADDS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADDS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00001800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD<c>{<q>} <Rd>, <Rn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ADDS{<q>} {<Rd>,} <Rn>, <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "DN",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "if (DN:Rdn) == '1101' || Rm == '1101' then SEE ADD (SP plus register);",
            "d = UInt(DN:Rdn); n = d; m = UInt(Rm); setflags = FALSE; (shift_t, shift_n) = (SRType_LSL, 0);",
            "if n == 15 && m == 15 then UNPREDICTABLE;",
            "if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x00004400",
          "mnemonics": [
            {
              "constraint": " !(DN == 1 && Rdn == 101).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD<c>{<q>} <Rdn>, <Rm>// Preferred syntax, Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rdn>,} <Rdn>, <Rm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 0 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMN (register);",
            "if Rn == '1101' then SEE ADD (SP plus register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeb000000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADD, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADD, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && Rd != 1111 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ADDS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11) && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADDS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "5",
      "names": [
        "ADD",
        "ADDS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, '0');",
          "    if d == 15 then",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add (register) adds a register value and an optionally-shifted register value, and writes the result to the destination",
          "register.",
          "If the destination register is not the PC, the ADDS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. If the",
          "destination register is the PC:",
          "         The ADD variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The ADDS variant of the instruction performs an exception return without the use of the stack. ARM",
          "deprecates use of this instruction. However, in this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>         Is the general-purpose source and destination register, encoded in the \"DN:Rdn\" field. If the PC is",
          "              used, the instruction is a branch to the address calculated by the operation. This is a simple branch,",
          "              see Pseudocode description of operations on the AArch32 general-purpose registers and the PC on",
          "              page E1-2378. The assembler language allows <Rdn> to be specified once or twice in the assembler",
          "              syntax. When used inside an IT block, and <Rdn> and <Rm> are in the range R0 to R7, <Rdn> must be",
          "              specified once so that encoding T2 is preferred to encoding T1. In all other cases there is no",
          "              difference in behavior when <Rdn> is specified once or twice.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. If the PC is used:",
          "                     For the ADD variant, the instruction is a branch to the address calculated by the operation.",
          "                      This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the ADDS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>. ARM deprecates use of this instruction.",
          "              For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. When used",
          "              inside an IT block, <Rd> must be specified. When used outside an IT block, <Rd> is optional, and:",
          "                     If omitted, this register is the same as <Rn>.",
          "                     If present, encoding T1 is preferred to encoding T2.",
          "              For encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>.",
          "<Rn>          For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "              be used. If the SP is used, see ADD, ADDS (SP plus register).",
          "              For encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "              For encoding T3: is the first general-purpose source register, encoded in the \"Rn\" field. If the SP is",
          "              used, see ADD, ADDS (SP plus register).",
          "<Rm>          For encoding A1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "              The PC can be used.",
          "              For encoding T1 and T3: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "     <shift>         Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                     the following values:",
          "                     LSL          when type = 00",
          "                     LSR          when type = 01",
          "                     ASR          when type = 10",
          "                     ROR          when type = 11",
          "     <amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                     LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "     Inside an IT block, if ADD<c> <Rd>, <Rn>, <Rd> cannot be assembled using encoding T1, it is assembled using",
          "     encoding T2 as though ADD<c> <Rd>, <Rn> had been written. To prevent this happening, use the .W qualifier."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00800010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "6",
      "names": [
        "ADD",
        "ADDS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, '0');",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add (register-shifted register) adds a register value and a register-shifted register value. It writes the result to the",
          "destination register, and can optionally update the condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       setflags = (S == '1');     imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x028d0000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "ADD variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "ADDS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       setflags = FALSE;   imm32 = ZeroExtend(imm8:'00', 32);"
          ],
          "mask": "0x0000a800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} <Rd>, SP, #<imm8>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 0 0 0 0",
              "size": 9,
              "type": 5
            },
            {
              "name": "imm7",
              "size": 7,
              "type": 2
            }
          ],
          "decode": [
            "d = 13;   setflags = FALSE;     imm32 = ZeroExtend(imm7:'00', 32);"
          ],
          "mask": "0x0000b000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {SP,} SP, #<imm7>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMN (immediate);",
            "d = UInt(Rd); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if d == 15 && !setflags then UNPREDICTABLE;"
          ],
          "mask": "0xf10d0000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}.W {<Rd>,} SP, #<const>// <Rd>, <const> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "ADD variant"
            },
            {
              "constraint": " S = 1 && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "ADDS variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 0 0 0 0 1 1 0 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = FALSE;       imm32 = ZeroExtend(i:imm3:imm8, 32);",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf20d0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, #<imm12>// <imm12> cannot be represented in T1, T2, or T3"
                },
                {
                  "aliases": [],
                  "value": "ADDW{<c>}{<q>} {<Rd>,} SP, #<imm12>// <imm12> can be represented in T1, T2, or T3"
                }
              ],
              "name": "T4 variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "7",
      "names": [
        "ADD",
        "ADDS (SP plus immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(SP, imm32, '0');",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add to SP (immediate) adds an immediate value to the SP value, and writes the result to the destination register.",
          "If the destination register is not the PC, the ADDS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. However,",
          "when the destination register is the PC:",
          "          The ADD variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ADDS variant of the instruction performs an exception return without the use of the stack. ARM",
          "deprecates use of this instruction. However, in this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<imm7>       Is the unsigned immediate, a multiple of 4, in the range 0 to 508, encoded in the \"imm7\" field as",
          "             <imm7>/4.",
          "<Rd>         For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "             this register is the SP. ARM deprecates using the PC as the destination register, but if the PC is used:",
          "                    For the ADD variant, the instruction is a branch to the address calculated by the operation.",
          "                     This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                     general-purpose registers and the PC on page E1-2378.",
          "                    For the ADDS variant, the instruction performs an exception return, that restores PSTATE",
          "                     from SPSR_<current_mode>.",
          "             For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "             For encoding T3 and T4: is the general-purpose destination register, encoded in the \"Rd\" field. If",
          "             omitted, this register is the SP.",
          "<imm8>       Is an unsigned immediate, a multiple of 4, in the range 0 to 1020, encoded in the \"imm8\" field as",
          "             <imm8>/4.",
          "<imm12>      Is a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.",
          "<const>      For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "             page F4-2559 for the range of values.",
          "             For encoding T3: an immediate value. See Modified immediate constants in T32 instructions on",
          "             page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x008d0000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX"
                }
              ],
              "name": "ADD, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADD, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX"
                }
              ],
              "name": "ADDS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADDS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "DM",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(DM:Rdm); m = UInt(DM:Rdm); setflags = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x00004468",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rdm>,} SP, <Rdm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 0 0 1",
              "size": 9,
              "type": 5
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 1",
              "size": 3,
              "type": 5
            }
          ],
          "decode": [
            "if Rm == '1101' then SEE encoding T1;",
            "d = 13; m = UInt(Rm); setflags = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004485",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {SP,} SP, <Rm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 0 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1 (0)",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMN (register);",
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeb0d0000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX"
                }
              ],
              "name": "ADD, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADD{<c>}.W {<Rd>,} SP, <Rm>// <Rd>, <Rm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADD, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && Rd != 1111 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX"
                }
              ],
              "name": "ADDS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11) && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ADDS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "8",
      "names": [
        "ADD",
        "ADDS (SP plus register)"
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "(result, nzcv) = AddWithCarry(SP, shifted, '0');",
          "if d == 15 then",
          "    if setflags then",
          "        ALUExceptionReturn(result);",
          "    else",
          "        ALUWritePC(result);",
          "else",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Add to SP (register) adds an optionally-shifted register value to the SP value, and writes the result to the destination",
          "register.",
          "If the destination register is not the PC, the ADDS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The ADD variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ADDS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>           Is the general-purpose destination and second source register, encoded in the \"Rdm\" field. If",
          "                omitted, this register is the SP. ARM deprecates using the PC as the destination register, but if the",
          "                PC is used, the instruction is a branch to the address calculated by the operation. This is a simple",
          "                branch, see Pseudocode description of operations on the AArch32 general-purpose registers and the",
          "                PC on page E1-2378.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the SP. ARM deprecates using the PC as the destination register, but if the PC is used:",
          "                       For the ADD variant, the instruction is a branch to the address calculated by the operation.",
          "                        This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the ADDS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the SP.",
          "<Rm>            For encoding A1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "                The PC can be used, but this is deprecated.",
          "                For encoding T3: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>         Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                the following values:",
          "                LSL          when type = 00",
          "                LSR          when type = 01",
          "                ASR          when type = 10",
          "                ROR          when type = 11",
          "<amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 0 0 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [],
          "mask": "0x028f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is never the preferred disassembly.",
                      "target": "ADR{<c>}{<q>} <Rd>, <label>"
                    }
                  ],
                  "value": "ADD{<c>}{<q>} <Rd>, PC, #<const>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [],
          "mask": "0x0000a000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is never the preferred disassembly.",
                      "target": "ADR{<c>}{<q>} <Rd>, <label>"
                    }
                  ],
                  "value": "ADD{<c>}{<q>} <Rd>, PC, #<imm8>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 0 0 0 0 1 1 1 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [],
          "mask": "0xf20f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is never the preferred disassembly.",
                      "target": "ADR{<c>}{<q>} <Rd>, <label>"
                    }
                  ],
                  "value": "ADDW{<c>}{<q>} <Rd>, PC, #<imm12>// <Rd>, <imm12> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is never the preferred disassembly.",
                      "target": "ADR{<c>}{<q>} <Rd>, <label>"
                    }
                  ],
                  "value": "ADD{<c>}{<q>} <Rd>, PC, #<imm12>"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "9",
      "names": [
        "ADD",
        "(immediate to PC)"
      ],
      "operation": {
        "lines": [
          "The description of ADR gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Add to PC adds an immediate value to the Align(PC, 4) value to form a PC-relative address, and writes the result",
          "to the destination register. ARM recommends that, where possible, software avoids using this alias.",
          "This instruction is an alias of the ADR instruction. This means that:",
          "         The encodings in this description are named to match the encodings of ADR.",
          "         The description of ADR gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is",
          "                   used, the instruction is a branch to the address calculated by the operation. This is an interworking",
          "                   branch, see Pseudocode description of operations on the AArch32 general-purpose registers and the",
          "                   PC on page E1-2378.",
          "                   For encoding T1 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<label>            For encoding A1 and A2: the label of an instruction or literal data item whose address is to be loaded",
          "                   into <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of",
          "                   the ADR instruction to this label. If the offset is zero or positive, encoding A1 is used, with imm32 equal",
          "                   to the offset. If the offset is negative, encoding A2 is used, with imm32 equal to the size of the offset.",
          "                   That is, the use of encoding A2 indicates that the required offset is minus the value of imm32.",
          "                   Permitted values of the size of the offset are any of the constants described in Modified immediate",
          "                   constants in A32 instructions on page F4-2559.",
          "                   For encoding T1: the label of an instruction or literal data item whose address is to be loaded into",
          "                   <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of the",
          "                   ADR instruction to this label. Permitted values of the size of the offset are multiples of 4 in the range",
          "                   0 to 1020.",
          "                   For encoding T2 and T3: the label of an instruction or literal data item whose address is to be loaded",
          "                   into <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of",
          "                   the ADR instruction to this label. If the offset is zero or positive, encoding T3 is used, with imm32 equal",
          "                   to the offset. If the offset is negative, encoding T2 is used, with imm32 equal to the size of the offset.",
          "                   That is, the use of encoding T2 indicates that the required offset is minus the value of imm32.",
          "                   Permitted values of the size of the offset are 0-4095.",
          "<imm8>             Is an unsigned immediate, a multiple of 4, in the range 0 to 1020, encoded in the \"imm8\" field as",
          "                   <imm8>/4.",
          "<imm12>            Is a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.",
          "<const>            An immediate value. See Modified immediate constants in A32 instructions on page F4-2559 for the",
          "                   range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 0 0 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       imm32 = A32ExpandImm(imm12);   add = TRUE;"
          ],
          "mask": "0x028f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADR{<c>}{<q>} <Rd>, <label>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 1 0 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       imm32 = A32ExpandImm(imm12);   add = FALSE;"
          ],
          "mask": "0x024f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADR{<c>}{<q>} <Rd>, <label>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       imm32 = ZeroExtend(imm8:'00', 32);     add = TRUE;"
          ],
          "mask": "0x0000a000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADR{<c>}{<q>} <Rd>, <label>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 1 0 1 0 1 1 1 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); imm32 = ZeroExtend(i:imm3:imm8, 32); add = FALSE;",
            "if d == 15 then UNPREDICTABLE;    // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf2af0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADR{<c>}{<q>} <Rd>, <label>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 0 0 0 0 1 1 1 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); imm32 = ZeroExtend(i:imm3:imm8, 32); add = TRUE;",
            "if d == 15 then UNPREDICTABLE;  // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf20f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ADR{<c>}.W <Rd>, <label>// <Rd>, <label> can be presented in T1"
                },
                {
                  "aliases": [],
                  "value": "ADR{<c>}{<q>} <Rd>, <label>"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "10",
      "names": [
        "ADR",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);",
          "    if d == 15 then          // Can only occur for A32 encodings",
          "        ALUWritePC(result);",
          "    else",
          "        R[d] = result;"
        ]
      },
      "summary": {
        "lines": [
          "Form PC-relative address adds an immediate value to the PC value to form a PC-relative address, and writes the",
          "result to the destination register.",
          "This instruction is used by the aliases ADD (immediate, to PC) and SUB (immediate, from PC). See the Alias",
          "conditions on page F7-2653 table for details of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1 and A2: is the general-purpose destination register, encoded in the \"Rd\" field. If",
          "              the PC is used, the instruction is a branch to the address calculated by the operation. This is an",
          "              interworking branch, see Pseudocode description of operations on the AArch32 general-purpose",
          "              registers and the PC on page E1-2378.",
          "              For encoding T1, T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<label>       For encoding A1 and A2: the label of an instruction or literal data item whose address is to be loaded",
          "              into <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of",
          "              the ADR instruction to this label. If the offset is zero or positive, encoding A1 is used, with imm32 equal",
          "              to the offset. If the offset is negative, encoding A2 is used, with imm32 equal to the size of the offset.",
          "                     That is, the use of encoding A2 indicates that the required offset is minus the value of imm32.",
          "                     Permitted values of the size of the offset are any of the constants described in Modified immediate",
          "                     constants in A32 instructions on page F4-2559.",
          "                     For encoding T1: the label of an instruction or literal data item whose address is to be loaded into",
          "                     <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of the",
          "                     ADR instruction to this label. Permitted values of the size of the offset are multiples of 4 in the range",
          "                     0 to 1020.",
          "                     For encoding T2 and T3: the label of an instruction or literal data item whose address is to be loaded",
          "                     into <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of",
          "                     the ADR instruction to this label. If the offset is zero or positive, encoding T3 is used, with imm32 equal",
          "                     to the offset. If the offset is negative, encoding T2 is used, with imm32 equal to the size of the offset.",
          "                     That is, the use of encoding T2 indicates that the required offset is minus the value of imm32.",
          "                     Permitted values of the size of the offset are 0-4095.",
          "     The instruction aliases permit the addition or subtraction of the offset and the immediate offset to be specified",
          "     separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "     information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x02000000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "AND variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ANDS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE TST (immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0000000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "AND variant"
            },
            {
              "constraint": " S = 1 && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ANDS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "11",
      "names": [
        "AND",
        "ANDS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] AND imm32;",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise AND (immediate) performs a bitwise AND of a register value and an immediate value, and writes the result",
          "to the destination register.",
          "If the destination register is not the PC, the ANDS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The AND variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ANDS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                PC is used:",
          "                       For the AND variant, the instruction is a branch to the address calculated by the operation.",
          "                        This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the ANDS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>.",
          "<Rn>            For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                used.",
          "                For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                page F4-2559 for the range of values.",
          "                For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "                page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00000000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "AND, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "AND, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ANDS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ANDS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);                 setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ANDS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE TST (register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea000000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "AND, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "AND, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && Rd != 1111 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ANDS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11) && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ANDS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "12",
      "names": [
        "AND",
        "ANDS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] AND shifted;",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "                PSTATE.N = result<31>;",
          "                PSTATE.Z = IsZeroBit(result);",
          "                PSTATE.C = carry;",
          "                // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise AND (register) performs a bitwise AND of a register value and an optionally-shifted register value, and",
          "writes the result to the destination register.",
          "If the destination register is not the PC, the ANDS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The AND variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The ANDS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>               See Standard assembler syntax fields on page F2-2506.",
          "<q>               See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>             Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>              For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                  PC is used:",
          "                         For the AND variant, the instruction is a branch to the address calculated by the operation.",
          "                          This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                          general-purpose registers and the PC on page E1-2378.",
          "                         For the ANDS variant, the instruction performs an exception return, that restores PSTATE",
          "                          from SPSR_<current_mode>.",
          "                  For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>.",
          "<Rn>              For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                  be used.",
          "                  For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>              For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                  can be used.",
          "                  For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>           Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                  the following values:",
          "                  LSL          when type = 00",
          "                  LSR          when type = 01",
          "                  ASR          when type = 10",
          "                  ROR          when type = 11",
          "<amount>          Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                  LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "In T32 assembly:",
          "        Outside an IT block, if ANDS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though ANDS <Rd>, <Rn> had been written.",
          "        Inside an IT block, if AND<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though AND<c> <Rd>, <Rn> had been written.",
          "To prevent either of these happening, use the .W qualifier."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00000010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "13",
      "names": [
        "AND",
        "ANDS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] AND shifted;",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise AND (register-shifted register) performs a bitwise AND of a register value and a register-shifted register",
          "value. It writes the result to the destination register, and can optionally update the condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "1 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00001000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASR<c>{<q>} {<Rd>,} <Rm>, #<imm>// Inside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 0 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea4f0020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASR<c>.W {<Rd>,} <Rm>, #<imm>// Inside IT block, and <Rd>, <Rm>, <imm> can be represented in T2"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "14",
      "names": [
        "ASR",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Arithmetic Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in copies",
          "of its sign bit, and writes the result to the destination register.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                   deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch",
          "                   to the address calculated by the operation. This is an interworking branch, see Pseudocode",
          "                   description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                   For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                   used.",
          "                   For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>              For encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as",
          "                   <imm> modulo 32.",
          "                   For encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as",
          "                   <imm> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00004100",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rdm>, <Rdm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>// Inside IT block"
                }
              ],
              "name": "Arithmetic shift right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa40f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASR<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "15",
      "names": [
        "ASR",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Arithmetic Shift Right (register) shifts a register value right by a variable number of bits, shifting in copies of its",
          "sign bit, and writes the result to the destination register. The variable number of bits is read from the bottom byte of",
          "a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "1 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00001000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASRS{<q>} {<Rd>,} <Rm>, #<imm>// Outside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 1 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea5f0020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASRS.W {<Rd>,} <Rm>, #<imm>// Outside IT block, and <Rd>, <Rm>, <imm> can be represented in T2"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ASR #<imm>"
                    }
                  ],
                  "value": "ASRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "16",
      "names": [
        "ASRS",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Arithmetic Shift Right, setting flags (immediate) shifts a register value right by an immediate number of bits,",
          "shifting in copies of its sign bit, and writes the result to the destination register.",
          "If the destination register is not the PC, this instruction updates the condition flags based on the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "         The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from AArch32",
          "state on page G1-3845.",
          "         The instruction is UNDEFINED in Hyp mode.",
          "         The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                   deprecates using the PC as the destination register, but if the PC is used, the instruction performs an",
          "                   exception return, that restores PSTATE from SPSR_<current_mode>.",
          "                   For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                   used.",
          "                   For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>              For encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as",
          "                   <imm> modulo 32.",
          "                   For encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as",
          "                   <imm> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00004100",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rdm>, <Rdm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASRS{<q>} {<Rdm>,} <Rdm>, <Rs>// Outside IT block"
                }
              ],
              "name": "Arithmetic shift right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa50f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASRS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ASR <Rs>"
                    }
                  ],
                  "value": "ASRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "17",
      "names": [
        "ASRS",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Arithmetic Shift Right, setting flags (register) shifts a register value right by a variable number of bits, shifting in",
          "copies of its sign bit, writes the result to the destination register, and updates the condition flags based on the result.",
          "The variable number of bits is read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm24",
              "size": 24,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = SignExtend(imm24:'00', 32);"
          ],
          "mask": "0x0a000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "B{<c>}{<q>} <label>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "!=111x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if cond == '1110' then SEE UDF;",
            "if cond == '1111' then SEE SVC;",
            "imm32 = SignExtend(imm8:'0', 32);",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000d000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "B<c>{<q>} <label>// Not permitted in IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm11",
              "size": 11,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = SignExtend(imm11:'0', 32);",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000e000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "B{<c>}{<q>} <label>// Outside or last in IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=111x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm6",
              "size": 6,
              "type": 2
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "J1",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "J2",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm11",
              "size": 11,
              "type": 2
            }
          ],
          "decode": [
            "if cond<3:1> == '111' then SEE \"Related encodings\";",
            "imm32 = SignExtend(S:J2:J1:imm6:imm11:'0', 32);",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf0008000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "B<c>.W <label>// Not permitted in IT block, and <label> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "B<c>{<q>} <label>// Not permitted in IT block"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm10",
              "size": 10,
              "type": 2
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "J1",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "J2",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm11",
              "size": 11,
              "type": 2
            }
          ],
          "decode": [
            "I1 = NOT(J1 EOR S); I2 = NOT(J2 EOR S); imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf0009000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "B{<c>}.W <label>// <label> can be represented in T2"
                },
                {
                  "aliases": [],
                  "value": "B{<c>}{<q>} <label>"
                }
              ],
              "name": "T4 variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "18",
      "names": [
        "B",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    BranchWritePC(PC + imm32);"
        ]
      },
      "summary": {
        "lines": [
          "Branch causes a branch to a target address."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1, T2 and T4: see Standard assembler syntax fields on page F2-2506.",
          "                For encoding T1: see Standard assembler syntax fields on page F2-2506. Must not be AL or omitted.",
          "                For encoding T3: see Standard assembler syntax fields on page F2-2506. <c> must not be AL or",
          "                omitted.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<label>         For encoding A1: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the B instruction to this label, then selects an",
          "                encoding that sets imm32 to that offset. Permitted offsets are multiples of 4 in the range 33554432",
          "                to 33554428.",
          "                For encoding T1: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the B instruction to this label, then selects an",
          "                encoding that sets imm32 to that offset. Permitted offsets are even numbers in the range 256 to 254.",
          "                For encoding T2: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the B instruction to this label, then selects an",
          "                encoding that sets imm32 to that offset. Permitted offsets are even numbers in the range 2048 to",
          "                2046.",
          "                For encoding T3: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the B instruction to this label, then selects an",
          "                encoding that sets imm32 to that offset. Permitted offsets are even numbers in the range 1048576 to",
          "                1048574.",
          "        For encoding T4: the label of the instruction that is to be branched to. The assembler calculates the",
          "        required value of the offset from the PC value of the B instruction to this label, then selects an",
          "        encoding that sets imm32 to that offset. Permitted offsets are even numbers in the range 16777216",
          "        to 16777214."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "msb",
              "size": 5,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "lsb",
              "size": 5,
              "type": 0
            },
            {
              "name": "0 0 1 1 1 1 1",
              "size": 7,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); msbit = UInt(msb);          lsbit = UInt(lsb);",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07c0001f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 0 1 1 0 1 1 1 1 0",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "msb",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "d = UInt(Rd); msbit = UInt(msb); lsbit = UInt(imm3:imm2);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf36f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "19",
      "names": [
        "BFC",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if msbit >= lsbit then",
          "        R[d]<msbit:lsbit> = Replicate('0', msbit-lsbit+1);",
          "        // Other bits of R[d] are unchanged",
          "    else",
          "        UNPREDICTABLE;"
        ]
      },
      "summary": {
        "lines": [
          "Bit Field Clear clears any number of adjacent bits at any position in a register, without affecting the other bits in the",
          "register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<lsb>              For encoding A1: is the least significant bit to be cleared, in the range 0 to 31, encoded in the \"lsb\"",
          "                   field.",
          "                   For encoding T1: is the least significant bit that is to be cleared, in the range 0 to 31, encoded in the",
          "                   \"imm3:imm2\" field.",
          "<width>            Is the number of bits to be cleared, in the range 1 to 32-<lsb>, encoded in the \"msb\" field as",
          "                   <lsb>+<width>-1."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "msb",
              "size": 5,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "lsb",
              "size": 5,
              "type": 0
            },
            {
              "name": "0 0 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE BFC;",
            "d = UInt(Rd); n = UInt(Rn); msbit = UInt(msb);                lsbit = UInt(lsb);",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07c00010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 0 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "msb",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE BFC;",
            "d = UInt(Rd); n = UInt(Rn); msbit = UInt(msb); lsbit = UInt(imm3:imm2);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3600000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "20",
      "names": [
        "BFI",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if msbit >= lsbit then",
          "        R[d]<msbit:lsbit> = R[n]<(msbit-lsbit):0>;",
          "        // Other bits of R[d] are unchanged",
          "    else",
          "        UNPREDICTABLE;"
        ]
      },
      "summary": {
        "lines": [
          "Bit Field Insert copies any number of low order bits from a register into the same number of adjacent bits at any",
          "position in the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the general-purpose source register, encoded in the \"Rn\" field.",
          "<lsb>              For encoding A1: is the least significant destination bit, in the range 0 to 31, encoded in the \"lsb\"",
          "                   field.",
          "                   For encoding T1: is the least significant destination bit, in the range 0 to 31, encoded in the",
          "                   \"imm3:imm2\" field.",
          "<width>            Is the number of bits to be copied, in the range 1 to 32-<lsb>, encoded in the \"msb\" field as",
          "                   <lsb>+<width>-1."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x03c00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "BIC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "BICS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0200000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "BIC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "BICS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "21",
      "names": [
        "BIC",
        "BICS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] AND NOT(imm32);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise Bit Clear (immediate) performs a bitwise AND of a register value and the complement of an immediate",
          "value, and writes the result to the destination register.",
          "If the destination register is not the PC, the BICS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The BIC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The BICS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "              PC is used:",
          "                     For the BIC variant, the instruction is a branch to the address calculated by the operation. This",
          "                      is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the BICS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>.",
          "              For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>.",
          "<Rn>          For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>       For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "              page F4-2559 for the range of values.",
          "              For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "              page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01c00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "BIC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "BIC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "BICS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "BICS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 1 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);             setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004380",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "BICS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 0 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea200000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "BIC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "BIC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "BICS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "BICS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "22",
      "names": [
        "BIC",
        "BICS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] AND NOT(shifted);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise Bit Clear (register) performs a bitwise AND of a register value and the complement of an optionally-shifted",
          "register value, and writes the result to the destination register.",
          "If the destination register is not the PC, the BICS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The BIC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The BICS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>           Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                PC is used:",
          "                       For the BIC variant, the instruction is a branch to the address calculated by the operation. This",
          "                        is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the BICS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>.",
          "<Rn>            For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                be used.",
          "                For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>            For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                can be used.",
          "                For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>         Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                the following values:",
          "                LSL          when type = 00",
          "                LSR          when type = 01",
          "                ASR          when type = 10",
          "                ROR          when type = 11",
          "<amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01c00010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "23",
      "names": [
        "BIC",
        "BICS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] AND NOT(shifted);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise Bit Clear (register-shifted register) performs a bitwise AND of a register value and the complement of a",
          "register-shifted register value. It writes the result to the destination register, and can optionally update the condition",
          "flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\"",
          "                   field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            },
            {
              "name": "0 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "imm16 = imm12:imm4;",
            "if cond != '1110' then UNPREDICTABLE;           // BKPT must be encoded with AL condition"
          ],
          "mask": "0x01200070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BKPT{<q>} {#}<imm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "imm16 = ZeroExtend(imm8, 16);"
          ],
          "mask": "0x0000be00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BKPT{<q>} {#}<imm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "24",
      "names": [
        "BKPT",
        ""
      ],
      "operation": {
        "lines": [
          "EncodingSpecificOperations();",
          "AArch32.SoftwareBreakpoint(imm16);"
        ]
      },
      "summary": {
        "lines": [
          "Breakpoint causes a Software Breakpoint Instruction exception.",
          "Breakpoint is always unconditional, even when inside an IT block."
        ]
      },
      "symbols": {
        "lines": [
          "<q>                See Standard assembler syntax fields on page F2-2506. An BKPT instruction must be unconditional.",
          "<imm>              For encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                   \"imm12:imm4\" field. The PE:",
          "                          Records this value in the Comment field of ESR_ELx.ISS if the Software Breakpoint",
          "                           Instruction exception is taken to an exception level that is using AArch64.",
          "                          Ignores this value otherwise.",
          "                   For encoding T1: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "                   The PE:",
          "                          Records this value in the Comment field of ESR_ELx.ISS if the Software Breakpoint",
          "                           Instruction exception is taken to an exception level that is using AArch64.",
          "                          Ignores this value otherwise."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm24",
              "size": 24,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = SignExtend(imm24:'00', 32);         targetInstrSet = InstrSet_A32;"
          ],
          "mask": "0x0b000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BL{<c>}{<q>} <label>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 0 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "H",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm24",
              "size": 24,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = SignExtend(imm24:H:'0', 32);         targetInstrSet = InstrSet_T32;"
          ],
          "mask": "0x0a000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BLX{<c>}{<q>} <label>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm10",
              "size": 10,
              "type": 2
            },
            {
              "name": "1 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "J1",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "J2",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm11",
              "size": 11,
              "type": 2
            }
          ],
          "decode": [
            "I1 = NOT(J1 EOR S); I2 = NOT(J2 EOR S); imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);",
            "targetInstrSet = CurrentInstrSet();",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf000d000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BL{<c>}{<q>} <label>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm10H",
              "size": 10,
              "type": 2
            },
            {
              "name": "1 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "J1",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "J2",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm10L",
              "size": 10,
              "type": 2
            },
            {
              "name": "H",
              "size": 1,
              "type": 3
            }
          ],
          "decode": [
            "if H == '1' then UNDEFINED;",
            "I1 = NOT(J1 EOR S); I2 = NOT(J2 EOR S); imm32 = SignExtend(S:I1:I2:imm10H:imm10L:'00', 32);",
            "targetInstrSet = InstrSet_A32;",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf000c000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BLX{<c>}{<q>} <label>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "25",
      "names": [
        "BL",
        "BLX (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if CurrentInstrSet() == InstrSet_A32 then",
          "        LR = PC - 4;",
          "    else",
          "        LR = PC<31:1> : '1';",
          "    if targetInstrSet == InstrSet_A32 then",
          "        targetAddress = Align(PC,4) + imm32;",
          "    else",
          "        targetAddress = PC + imm32;",
          "    SelectInstrSet(targetInstrSet);",
          "    BranchWritePC(targetAddress);"
        ]
      },
      "summary": {
        "lines": [
          "Branch with Link calls a subroutine at a PC-relative address.",
          "Branch with Link and Exchange Instruction Sets (immediate) calls a subroutine at a PC-relative address, and",
          "changes instruction set from A32 to T32, or from T32 to A32."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "                For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<label>         For encoding A1: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the BL instruction to this label, then selects an",
          "                encoding that sets imm32 to that offset. Permitted offsets are multiples of 4 in the range 33554432",
          "                to 33554428.",
          "                For encoding A2: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the BLX instruction to this label, then selects an",
          "                encoding with imm32 set to that offset. Permitted offsets are even numbers in the range 33554432",
          "                to 33554430.",
          "                For encoding T1: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the PC value of the BL instruction to this label, then selects an",
          "                encoding with imm32 set to that offset. Permitted offsets are even numbers in the range 16777216",
          "                to 16777214.",
          "                For encoding T2: the label of the instruction that is to be branched to. The assembler calculates the",
          "                required value of the offset from the Align(PC, 4) value of the BLX instruction to this label, then",
          "                selects an encoding with imm32 set to that offset. Permitted offsets are multiples of 4 in the range",
          "                16777216 to 16777212."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) 0 0 1 1",
              "size": 24,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "m = UInt(Rm);",
            "if m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x012fff30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BLX{<c>}{<q>} <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 1 1 1",
              "size": 9,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0)",
              "size": 3,
              "type": 5
            }
          ],
          "decode": [
            "m = UInt(Rm);",
            "if m == 15 then UNPREDICTABLE;",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x00004780",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BLX{<c>}{<q>} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "26",
      "names": [
        "BLX",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    target = R[m];",
          "    if CurrentInstrSet() == InstrSet_A32 then",
          "        next_instr_addr = PC - 4;",
          "        LR = next_instr_addr;",
          "    else",
          "              next_instr_addr = PC - 2;",
          "              LR = next_instr_addr<31:1> : '1';",
          "          BXWritePC(target);"
        ]
      },
      "summary": {
        "lines": [
          "Branch with Link and Exchange (register) calls a subroutine at an address and instruction set specified by a register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rm>               Is the general-purpose register holding the address to be branched to, encoded in the \"Rm\" field. The",
          "                   SP can be used, but this is deprecated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) 0 0 0 1",
              "size": 24,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "m = UInt(Rm);"
          ],
          "mask": "0x012fff10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BX{<c>}{<q>} <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 1 1 0",
              "size": 9,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0)",
              "size": 3,
              "type": 5
            }
          ],
          "decode": [
            "m = UInt(Rm);",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x00004700",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BX{<c>}{<q>} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "27",
      "names": [
        "BX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    BXWritePC(R[m]);"
        ]
      },
      "summary": {
        "lines": [
          "Branch and Exchange causes a branch to an address and instruction set specified by a register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rm>               For encoding A1: is the general-purpose register holding the address to be branched to, encoded in",
          "                   the \"Rm\" field. The SP can be used, but this is deprecated. The PC can be used.",
          "                   For encoding T1: is the general-purpose register holding the address to be branched to, encoded in",
          "                   the \"Rm\" field. The SP can be used, but this is deprecated. The PC can be used. Note: If <Rm> is the",
          "                   PC at a non word-aligned address, it results in UNPREDICTABLE behavior because the address passed",
          "                   to the BXWritePC() pseudocode function has bits<1:0> = '10'."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0 (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) 0 0 1 0",
              "size": 24,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "m = UInt(Rm);",
            "if m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x012fff20",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BXJ{<c>}{<q>} <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 (0) 0 (1) (1) (1) (1) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "m = UInt(Rm);",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf3c08f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "BXJ{<c>}{<q>} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "28",
      "names": [
        "BXJ",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    BXWritePC(R[m]);"
        ]
      },
      "summary": {
        "lines": [
          "Branch and Exchange, previously Branch and Exchange Jazelle.",
          "In ARMv8, BXJ behaves as a BX instruction, see BX. This means it causes a branch to an address and instruction set",
          "specified by a register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rm>               Is the general-purpose register holding the address to be branched to, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "op",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); imm32 = ZeroExtend(i:imm5:'0', 32);      nonzero = (op == '1');",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000b100",
          "mnemonics": [
            {
              "constraint": " op = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CBNZ{<q>} <Rn>, <label>"
                }
              ],
              "name": "CBNZ variant"
            },
            {
              "constraint": " op = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CBZ{<q>} <Rn>, <label>"
                }
              ],
              "name": "CBZ variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "29",
      "names": [
        "CBNZ",
        "CBZ"
      ],
      "operation": {
        "lines": [
          "EncodingSpecificOperations();",
          "if nonzero != IsZero(R[n]) then",
          "    BranchWritePC(PC + imm32);"
        ]
      },
      "summary": {
        "lines": [
          "Compare and Branch on Nonzero and Compare and Branch on Zero compare the value in a register with zero, and",
          "conditionally branch forward a constant value. They do not affect the condition flags."
        ]
      },
      "symbols": {
        "lines": [
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          Is the general-purpose register to be tested, encoded in the \"Rn\" field.",
          "<label>       Is the program label to be conditionally branched to. Its offset from the PC, a multiple of 2 and in",
          "              the range 0 to 126, is encoded as \"i:imm5\" times 4."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Floating-point instructions\";",
            "cp = UInt(coproc);"
          ],
          "mask": "0x0e000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CDP{<c>}{<q>} <coproc>, {#}<opc1>, <CRd>, <CRn>, <CRm> {, {#}<opc2>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Floating-point instructions\";",
            "cp = UInt(coproc);"
          ],
          "mask": "0x0e000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CDP2{<c>}{<q>} <coproc>, {#}<opc1>, <CRd>, <CRn>, <CRm> {, {#}<opc2>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Floating-point instructions\";",
            "cp = UInt(coproc);"
          ],
          "mask": "0xee000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CDP{<c>}{<q>} <coproc>, {#}<opc1>, <CRd>, <CRn>, <CRm> {, {#}<opc2>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Floating-point instructions\";",
            "cp = UInt(coproc);"
          ],
          "mask": "0xfe000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CDP2{<c>}{<q>} <coproc>, {#}<opc1>, <CRd>, <CRn>, <CRm> {, {#}<opc2>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "30",
      "names": [
        "CDP",
        "CDP2"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    Coproc_InternalOperation(cp, ThisInstr());"
        ]
      },
      "summary": {
        "lines": [
          "Coprocessor Data Processing is a generic coprocessor instruction. The coproc field identifies the target conceptual",
          "coprocessor. This must be one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the opc1,",
          "opc2, CRd, CRn, and CRm field values that are valid CDP and CDP2 instructions. Other encodings are UNDEFINED. For more",
          "information see Conceptual coprocessor support on page E1-2414 and General behavior of System registers on",
          "page G4-4172."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "               For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<coproc>       Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "               p11, p14, and p15.",
          "<opc1>         Is a coprocessor-specific opcode, in the range 0 to 15, encoded in the \"opc1\" field.",
          "<CRd>          Is the destination coprocessor register, encoded in the \"CRd\" field.",
          "<CRn>          Is the coprocessor register that contains the first operand, encoded in the \"CRn\" field.",
          "<CRm>          Is the coprocessor register that contains the second operand, encoded in the \"CRm\" field.",
          "<opc2>         Is a coprocessor-specific opcode in the range 0 to 7, defaulting to 0 and encoded in the \"opc2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 1 (1) (1) (1) (1)",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf57ff01f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CLREX{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 0 1 0 (1) (1) (1) (1)",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3bf8f2f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CLREX{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "31",
      "names": [
        "CLREX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    ClearExclusiveLocal(ProcessorID());"
        ]
      },
      "summary": {
        "lines": [
          "Clear-Exclusive clears the local monitor of the executing PE."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "                For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x016f0f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CLZ{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if !Consistent(Rm) then UNPREDICTABLE;",
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfab0f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CLZ{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "32",
      "names": [
        "CLZ",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = CountLeadingZeroBits(R[m]);",
          "    R[d] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Count Leading Zeros returns the number of binary zero bits before the first binary one bit in a value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field.",
          "                   For encoding T1: is the general-purpose source register, encoded in the \"Rm\" field. Its number must",
          "                   be encoded twice."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);       imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x03700000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 0 0 0 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf1100f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "33",
      "names": [
        "CMN",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(R[n], imm32, '0');",
          "    PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Compare Negative (immediate) adds a register value and an immediate value. It updates the condition flags based",
          "on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                   used.",
          "                   For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>            For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                   page F4-2559 for the range of values.",
          "                   For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "                   page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01700000",
          "mnemonics": [
            {
              "constraint": " imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 0 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x000042c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeb100f00",
          "mnemonics": [
            {
              "constraint": " imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}.W <Rn>, <Rm>// <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "34",
      "names": [
        "CMN",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, '0');",
          "    PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Compare Negative (register) adds a register value and an optionally-shifted register value. It updates the condition",
          "flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "              be used.",
          "              For encoding T1 and T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>          For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "              can be used.",
          "              For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>       Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "              the following values:",
          "              LSL         when type = 00",
          "              LSR         when type = 01",
          "              ASR         when type = 10",
          "              ROR         when type = 11",
          "<amount>      Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "              LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "shift_t = DecodeRegShift(type);",
            "if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01700010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMN{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "35",
      "names": [
        "CMN",
        "(register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], shifted, '0');",
          "    PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Compare Negative (register-shifted register) adds a register value and a register-shifted register value. It updates the",
          "condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);       imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x03500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 1 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);       imm32 = ZeroExtend(imm8, 32);"
          ],
          "mask": "0x00002800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, #<imm8>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 1 0 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf1b00f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}.W <Rn>, #<const>// <Rd>, <const> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "36",
      "names": [
        "CMP",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');",
          "    PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Compare (immediate) subtracts an immediate value from a register value. It updates the condition flags based on",
          "the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rn>            For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                     used.",
          "                     For encoding T1: is a general-purpose source register, encoded in the \"Rn\" field.",
          "                     For encoding T2: is the general-purpose source register, encoded in the \"Rn\" field.",
          "     <imm8>          Is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "     <const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                     page F4-2559 for the range of values.",
          "                     For encoding T2: an immediate value. See Modified immediate constants in T32 instructions on",
          "                     page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01500000",
          "mnemonics": [
            {
              "constraint": " imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004280",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm>// <Rn> and <Rm> both from R0-R7"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(N:Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if n < 8 && m < 8 then UNPREDICTABLE;",
            "if n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00004500",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm>// <Rn> and <Rm> not both from R0-R7"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 1 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xebb00f00",
          "mnemonics": [
            {
              "constraint": " imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}.W <Rn>, <Rm>// <Rn>, <Rm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm>, <shift> #<amount>"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "37",
      "names": [
        "CMP",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');",
          "    PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Compare (register) subtracts an optionally-shifted register value from a register value. It updates the condition flags",
          "based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rn>            For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                be used.",
          "                For encoding T1, T2 and T3: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>            For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                can be used.",
          "                For encoding T1, T2 and T3: is the second general-purpose source register, encoded in the \"Rm\"",
          "                field.",
          "<shift>         Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                the following values:",
          "                LSL          when type = 00",
          "                LSR          when type = 01",
          "                ASR          when type = 10",
          "                ROR          when type = 11",
          "<amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "shift_t = DecodeRegShift(type);",
            "if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01500010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CMP{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "38",
      "names": [
        "CMP",
        "(register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');",
          "    PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Compare (register-shifted register) subtracts a register-shifted register value from a register value. It updates the",
          "condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 0 1 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "imod",
              "size": 2,
              "type": 0
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 (0) (0) (0) (0) (0) (0) (0)",
              "size": 8,
              "type": 5
            },
            {
              "name": "A",
              "size": 1,
              "type": 3
            },
            {
              "name": "I",
              "size": 1,
              "type": 3
            },
            {
              "name": "F",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "mode",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "if mode != '00000' && M == '0' then UNPREDICTABLE;",
            "if (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;",
            "enable = (imod == '10'); disable = (imod == '11'); changemode = (M == '1');",
            "affectA = (A == '1'); affectI = (I == '1'); affectF = (F == '1');",
            "if (imod == '00' && M == '0') || imod == '01' then UNPREDICTABLE;"
          ],
          "mask": "0xf1000000",
          "mnemonics": [
            {
              "constraint": " imod = 00 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPS{<q>} #<mode>// Cannot be conditional"
                }
              ],
              "name": "CPS variant"
            },
            {
              "constraint": " imod = 11 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSID{<q>} <iflags>// Cannot be conditional"
                }
              ],
              "name": "CPSID variant"
            },
            {
              "constraint": " imod = 11 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSID{<q>} <iflags> , #<mode>// Cannot be conditional"
                }
              ],
              "name": "CPSID variant"
            },
            {
              "constraint": " imod = 10 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSIE{<q>} <iflags>// Cannot be conditional"
                }
              ],
              "name": "CPSIE variant"
            },
            {
              "constraint": " imod = 10 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSIE{<q>} <iflags> , #<mode>// Cannot be conditional"
                }
              ],
              "name": "CPSIE variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 1 1 0 0 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "im",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "A",
              "size": 1,
              "type": 3
            },
            {
              "name": "I",
              "size": 1,
              "type": 3
            },
            {
              "name": "F",
              "size": 1,
              "type": 3
            }
          ],
          "decode": [
            "if A:I:F == '000' then UNPREDICTABLE;",
            "enable = (im == '0'); disable = (im == '1'); changemode = FALSE;",
            "affectA = (A == '1'); affectI = (I == '1'); affectF = (F == '1');",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000b660",
          "mnemonics": [
            {
              "constraint": " im = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSID{<q>} <iflags>// Not permitted in IT block"
                }
              ],
              "name": "CPSID variant"
            },
            {
              "constraint": " im = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSIE{<q>} <iflags>// Not permitted in IT block"
                }
              ],
              "name": "CPSIE variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0)",
              "size": 21,
              "type": 5
            },
            {
              "name": "imod",
              "size": 2,
              "type": 0
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "A",
              "size": 1,
              "type": 3
            },
            {
              "name": "I",
              "size": 1,
              "type": 3
            },
            {
              "name": "F",
              "size": 1,
              "type": 3
            },
            {
              "name": "mode",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "if imod == '00' && M == '0' then SEE \"Hint instructions\";",
            "if mode != '00000' && M == '0' then UNPREDICTABLE;",
            "if (imod<1> == '1' && A:I:F == '000') || (imod<1> == '0' && A:I:F != '000') then UNPREDICTABLE;",
            "enable = (imod == '10'); disable = (imod == '11'); changemode = (M == '1');",
            "affectA = (A == '1'); affectI = (I == '1'); affectF = (F == '1');",
            "if imod == '01' || InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf3af8000",
          "mnemonics": [
            {
              "constraint": " imod = 00 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPS{<q>} #<mode>// Not permitted in IT block"
                }
              ],
              "name": "CPS variant"
            },
            {
              "constraint": " imod = 11 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSID.W <iflags>// Not permitted in IT block"
                }
              ],
              "name": "CPSID variant"
            },
            {
              "constraint": " imod = 11 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSID{<q>} <iflags>, #<mode>// Not permitted in IT block"
                }
              ],
              "name": "CPSID variant"
            },
            {
              "constraint": " imod = 10 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSIE.W <iflags>// Not permitted in IT block"
                }
              ],
              "name": "CPSIE variant"
            },
            {
              "constraint": " imod = 10 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CPSIE{<q>} <iflags>, #<mode>// Not permitted in IT block"
                }
              ],
              "name": "CPSIE variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "39",
      "names": [
        "CPS",
        "CPSID CPSIE"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL != EL0 then",
          "        if enable then",
          "            if affectA then PSTATE.A = '0';",
          "            if affectI then PSTATE.I = '0';",
          "            if affectF then PSTATE.F = '0';",
          "        if disable then",
          "            if affectA then PSTATE.A = '1';",
          "            if affectI then PSTATE.I = '1';",
          "            if affectF then PSTATE.F = '1';",
          "        if changemode then",
          "            // WriteMode will set PSTATE.IL if 'mode' is not legal.",
          "            AArch32.WriteMode(mode);",
          "else",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL != EL0 then",
          "        if enable then",
          "            if affectA then PSTATE.A = '0';",
          "            if affectI then PSTATE.I = '0';",
          "            if affectF then PSTATE.F = '0';",
          "        if disable then",
          "            if affectA then PSTATE.A = '1';",
          "            if affectI then PSTATE.I = '1';",
          "            if affectF then PSTATE.F = '1';",
          "        if changemode then",
          "            // WriteMode will set PSTATE.IL if 'mode' is not legal.",
          "            AArch32.WriteMode(mode);"
        ]
      },
      "summary": {
        "lines": [
          "Change PE State changes one or more of the PSTATE.{A, I, F} interrupt mask bits and, optionally, the PSTATE.M",
          "mode field, without changing any other PSTATE bits.",
          "CPS is treated as NOP if executed in User mode unless it is defined as being CONSTRAINED UNPREDICTABLE elsewhere",
          "in this section.",
          "The PE checks whether the value being written to PSTATE.M is legal. See Illegal changes to PSTATE.M on",
          "page G1-3822."
        ]
      },
      "symbols": {
        "lines": [
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<iflags>        Is a sequence of one or more of the following, specifying which interrupt mask bits are affected:",
          "                a            Sets the A bit in the instruction, causing the specified effect on PSTATE.A, the",
          "                             asynchronous abort mask bit.",
          "                i            Sets the I bit in the instruction, causing the specified effect on PSTATE.I, the IRQ",
          "                             interrupt mask bit.",
          "                f            Sets the F bit in the instruction, causing the specified effect on PSTATE.F, the FIQ",
          "                             interrupt mask bit.",
          "<mode>          Is the number of the mode to change to, in the range 0 to 31, encoded in the \"mode\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "sz",
              "size": 2,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 0 (0) 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "size = 8 << UInt(sz);",
            "crc32c = (C == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if size == 64 then UNPREDICTABLE;",
            "if cond != '1110' then UNPREDICTABLE;"
          ],
          "mask": "0x01000040",
          "mnemonics": [
            {
              "constraint": " sz = 00.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32B{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32B variant"
            },
            {
              "constraint": " sz = 01.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32H{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32H variant"
            },
            {
              "constraint": " sz = 10.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32W{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32W variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "sz",
              "size": 2,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "size = 8 << UInt(sz);",
            "crc32c = (C == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if size == 64 then UNPREDICTABLE;",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xfac0f080",
          "mnemonics": [
            {
              "constraint": " sz = 00.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32B{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32B variant"
            },
            {
              "constraint": " sz = 01.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32H{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32H variant"
            },
            {
              "constraint": " sz = 10.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32W{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32W variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "40",
      "names": [
        "CRC32",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "       if !HaveCRCExt() then",
          "           UNDEFINED;",
          "       acc = R[n];             // accumulator",
          "       val = R[m]<size-1:0>;   // input value",
          "       poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;",
          "       tempacc = BitReverse(acc):Zeros(size);",
          "       tempval = BitReverse(val):Zeros(32);",
          "       // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation",
          "       R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"
        ]
      },
      "summary": {
        "lines": [
          "CRC32 performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It is an",
          "OPTIONAL instruction. It takes an input CRC value in the first source operand, and performs a CRC on an input value",
          "in the second source operand that can be 8, 16, or 32 bits, and returns the output CRC value. To align with common",
          "usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x04C11DB7 is used for the",
          "CRC calculation.",
          "Note",
          "ID_ISAR5.CRC32 indicates whether this instruction is supported in the T32 and A32 instruction sets."
        ]
      },
      "symbols": {
        "lines": [
          "<q>             See Standard assembler syntax fields on page F2-2506. An CRC32 instruction must be unconditional.",
          "<Rd>            Is the general-purpose accumulator output register, encoded in the \"Rd\" field.",
          "<Rn>            Is the general-purpose accumulator input register, encoded in the \"Rn\" field.",
          "<Rm>            Is the general-purpose data source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "sz",
              "size": 2,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 1 (0) 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "size = 8 << UInt(sz);",
            "crc32c = (C == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if size == 64 then UNPREDICTABLE;",
            "if cond != '1110' then UNPREDICTABLE;"
          ],
          "mask": "0x01000240",
          "mnemonics": [
            {
              "constraint": " sz = 00.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32CB{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32CB variant"
            },
            {
              "constraint": " sz = 01.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32CH{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32CH variant"
            },
            {
              "constraint": " sz = 10.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32CW{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32CW variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "sz",
              "size": 2,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "size = 8 << UInt(sz);",
            "crc32c = (C == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if size == 64 then UNPREDICTABLE;",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xfad0f080",
          "mnemonics": [
            {
              "constraint": " sz = 00.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32CB{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32CB variant"
            },
            {
              "constraint": " sz = 01.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32CH{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32CH variant"
            },
            {
              "constraint": " sz = 10.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "CRC32CW{<q>} <Rd>, <Rn>, <Rm>"
                }
              ],
              "name": "CRC32CW variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "41",
      "names": [
        "CRC32C",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "       if !HaveCRCExt() then",
          "           UNDEFINED;",
          "       acc = R[n];             // accumulator",
          "       val = R[m]<size-1:0>;   // input value",
          "       poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;",
          "       tempacc = BitReverse(acc):Zeros(size);",
          "       tempval = BitReverse(val):Zeros(32);",
          "       // Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation",
          "       R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));"
        ]
      },
      "summary": {
        "lines": [
          "CRC32C performs a cyclic redundancy check (CRC) calculation on a value held in a general-purpose register. It is an",
          "OPTIONAL instruction. It takes an input CRC value in the first source operand, and performs a CRC on an input value",
          "in the second source operand that can be 8, 16, or 32 bits, and returns the output CRC value. To align with common",
          "usage, the bit order of the values is reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for the",
          "CRC calculation.",
          "Note",
          "ID_ISAR5.CRC32 indicates whether this instruction is supported in the T32 and A32 instruction sets."
        ]
      },
      "symbols": {
        "lines": [
          "<q>             See Standard assembler syntax fields on page F2-2506. An CRC32C instruction must be",
          "                unconditional.",
          "<Rd>            Is the general-purpose accumulator output register, encoded in the \"Rd\" field.",
          "<Rn>            Is the general-purpose accumulator input register, encoded in the \"Rn\" field.",
          "<Rm>            Is the general-purpose data source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 1 1 1 1",
              "size": 24,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// Any decoding of 'option' is specified by the debug system"
          ],
          "mask": "0x0320f0f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DBG{<c>}{<q>} #<option>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 1 1 1 1",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// Any decoding of 'option' is specified by the debug system"
          ],
          "mask": "0xf3af80f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DBG{<c>}{<q>} #<option>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "42",
      "names": [
        "DBG",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Hint_Debug(option);"
        ]
      },
      "summary": {
        "lines": [
          "Debug Hint provides a hint to debug and related systems. See the system documentation for what use (if any) is",
          "made of this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<option>           Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"option\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 1 1 1 0 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0",
              "size": 30,
              "type": 5
            },
            {
              "name": "opt",
              "size": 2,
              "type": 0
            }
          ],
          "decode": [
            "if !Halted() || opt == '00' then UNDEFINED;",
            "Operation",
            "DCPSInstruction(opt);"
          ],
          "mask": "0xf78f8000",
          "mnemonics": [
            {
              "constraint": " opt = 01.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DCPS1"
                }
              ],
              "name": "DCPS1 variant"
            },
            {
              "constraint": " opt = 10.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DCPS2"
                }
              ],
              "name": "DCPS2 variant"
            },
            {
              "constraint": " opt = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DCPS3"
                }
              ],
              "name": "DCPS3 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "43",
      "names": [
        "DCPS1",
        "DCPS2 DCPS3"
      ],
      "operation": {
        "lines": []
      },
      "summary": {
        "lines": [
          "Debug Change PE State allows the debugger to move the PE into a higher Exception Level or to a specific mode at",
          "the current Exception Level.",
          "These instructions are always UNDEFINED in Non-debug state.",
          "DCPS1 targets EL1 and:",
          "        If EL1 is using AArch32, the PE enters SVC mode. If EL3 is using AArch32, Secure SVC is an EL3 mode.",
          "This means DCPS1 causes the PE to enter EL3.",
          "        If EL1 is using AArch64, the PE enters EL1h, and executes future instructions as A64 instructions.",
          "DCPS2 targets EL2 and:",
          "        If EL2 is using AArch32, the PE enters Hyp mode.",
          "        If EL2 is using AArch64, the PE enters EL2h, and executes future instructions as A64 instructions.",
          "DCPS3 targets EL3 and:",
          "        If EL3 is using AArch32, the PE enters Monitor mode.",
          "        If EL3 is using AArch64, the PE enters EL3h, and executes future instructions as A64 instructions.",
          "For more information on the operation of these instructions, see DCPS on page H2-4963."
        ]
      },
      "symbols": {
        "lines": []
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 1 0 1",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf57ff050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DMB{<c>}{<q>} {<option>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 1 0 1",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3bf8f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DMB{<c>}{<q>} {<option>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "44",
      "names": [
        "DMB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    case option of",
          "        when '0001' domain = MBReqDomain_OuterShareable;          types   =   MBReqTypes_Reads;",
          "        when '0010' domain = MBReqDomain_OuterShareable;          types   =   MBReqTypes_Writes;",
          "        when '0011' domain = MBReqDomain_OuterShareable;          types   =   MBReqTypes_All;",
          "        when '0101' domain = MBReqDomain_Nonshareable;            types   =   MBReqTypes_Reads;",
          "        when '0110' domain = MBReqDomain_Nonshareable;            types   =   MBReqTypes_Writes;",
          "        when '0111' domain = MBReqDomain_Nonshareable;            types   =   MBReqTypes_All;",
          "        when '1001' domain = MBReqDomain_InnerShareable;          types   =   MBReqTypes_Reads;",
          "        when '1010' domain = MBReqDomain_InnerShareable;          types   =   MBReqTypes_Writes;",
          "        when '1011' domain = MBReqDomain_InnerShareable;          types   =   MBReqTypes_All;",
          "        when '1101' domain = MBReqDomain_FullSystem;              types   =   MBReqTypes_Reads;",
          "        when '1110' domain = MBReqDomain_FullSystem;              types   =   MBReqTypes_Writes;",
          "        otherwise    domain = MBReqDomain_FullSystem;             types   =   MBReqTypes_All;",
          "    if HaveEL(EL2)   && !IsSecure() && PSTATE.EL IN {EL0,EL1} then",
          "        if HCR.BSU   == '11' then",
          "            domain   = MBReqDomain_FullSystem;",
          "        if HCR.BSU   == '10' && domain != MBReqDomain_FullSystem then",
          "            domain   = MBReqDomain_OuterShareable;",
          "               if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then",
          "                   domain = MBReqDomain_InnerShareable;",
          "           DataMemoryBarrier(domain, types);"
        ]
      },
      "summary": {
        "lines": [
          "Data Memory Barrier is a memory barrier that ensures the ordering of observations of memory accesses, see Data",
          "Memory Barrier (DMB) on page B2-85."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "                For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<option>        Specifies an optional limitation on the barrier operation. Values are:",
          "                SY           Full system is the required shareability domain, reads and writes are the required access",
          "                             types in both Group A on page E2-2439 and Group B on page E2-2439. Can be omitted.",
          "                             This option is referred to as the full system DMB. Encoded as option = 0b1111.",
          "                ST           Full system is the required shareability domain, writes are the required access type in",
          "                             both Group A on page E2-2439 and Group B on page E2-2439. SYST is a synonym for",
          "                             ST. Encoded as option = 0b1110.",
          "                LD           Full system is the required shareability domain, reads are the required access type in",
          "                             Group A on page E2-2439, and reads and writes are the required access types in both",
          "                             Group A on page E2-2439 and Group B on page E2-2439. Encoded as option = 0b1101.",
          "        ISH          Inner Shareable is the required shareability domain, reads and writes are the required",
          "                     access types in Group B on page E2-2439. Encoded as option = 0b1011.",
          "        ISHST        Inner Shareable is the required shareability domain, writes are the required access type",
          "                     in both Group A on page E2-2439 and Group B on page E2-2439. Encoded as option =",
          "                     0b1010.",
          "        ISHLD        Inner Shareable is the required shareability domain, reads are the required access type",
          "                     in Group A on page E2-2439. Encoded as option = 0b1001.",
          "        NSH          Non-shareable is the required shareability domain, reads and writes are the required",
          "                     access types in Group B on page E2-2439. Encoded as option = 0b0111.",
          "        NSHST        Non-shareable is the required shareability domain, writes are the required access type",
          "                     in both Group A on page E2-2439 and Group B on page E2-2439. Encoded as option =",
          "                     0b0110.",
          "        NSHLD        Non-shareable is the required shareability domain, reads are the required access type in",
          "                     Group A on page E2-2439. Encoded as option = 0b0101.",
          "        OSH          Outer Shareable is the required shareability domain, reads and writes are the required",
          "                     access types in Group B on page E2-2439. Encoded as option = 0b0011.",
          "        OSHST        Outer Shareable is the required shareability domain, writes are the required access type",
          "                     in both Group A on page E2-2439 and Group B on page E2-2439. Encoded as option =",
          "                     0b0010.",
          "        OSHLD        Outer Shareable is the required shareability domain, reads are the required access type",
          "                     in Group A on page E2-2439. Encoded as option = 0b0001.",
          "         All other encodings of option are reserved. It is IMPLEMENTATION DEFINED whether options other",
          "        than SY are implemented. All unsupported and reserved options must execute as a full system barrier",
          "        operation, but software must not rely on this behavior.",
          "                  Note",
          "        The instruction supports the following alternative <option> values, but ARM recommends that",
          "        software does not use these alternative values:",
          "               SH as an alias for ISH.",
          "               SHST as an alias for ISHST.",
          "               UN as an alias for NSH.",
          "               UNST is an alias for NSHST."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 1 0 0",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf57ff040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DSB{<c>}{<q>} {<option>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 1 0 0",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3bf8f40",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "DSB{<c>}{<q>} {<option>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "45",
      "names": [
        "DSB",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          case option of",
          "              when '0001' domain = MBReqDomain_OuterShareable;          types   =   MBReqTypes_Reads;",
          "              when '0010' domain = MBReqDomain_OuterShareable;          types   =   MBReqTypes_Writes;",
          "              when '0011' domain = MBReqDomain_OuterShareable;          types   =   MBReqTypes_All;",
          "              when '0101' domain = MBReqDomain_Nonshareable;            types   =   MBReqTypes_Reads;",
          "              when '0110' domain = MBReqDomain_Nonshareable;            types   =   MBReqTypes_Writes;",
          "              when '0111' domain = MBReqDomain_Nonshareable;            types   =   MBReqTypes_All;",
          "              when '1001' domain = MBReqDomain_InnerShareable;          types   =   MBReqTypes_Reads;",
          "              when '1010' domain = MBReqDomain_InnerShareable;          types   =   MBReqTypes_Writes;",
          "              when '1011' domain = MBReqDomain_InnerShareable;          types   =   MBReqTypes_All;",
          "              when '1101' domain = MBReqDomain_FullSystem;              types   =   MBReqTypes_Reads;",
          "              when '1110' domain = MBReqDomain_FullSystem;              types   =   MBReqTypes_Writes;",
          "              otherwise    domain = MBReqDomain_FullSystem;             types   =   MBReqTypes_All;",
          "           if HaveEL(EL2)    && !IsSecure() && PSTATE.EL IN {EL0,EL1} then",
          "               if HCR.BSU    == '11' then",
          "                   domain    = MBReqDomain_FullSystem;",
          "               if HCR.BSU    == '10' && domain != MBReqDomain_FullSystem then",
          "                   domain    = MBReqDomain_OuterShareable;",
          "   if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then",
          "       domain = MBReqDomain_InnerShareable;",
          "DataSynchronizationBarrier(domain, types);"
        ]
      },
      "summary": {
        "lines": [
          "Data Synchronization Barrier is a memory barrier that ensures the completion of memory accesses, see Data",
          "Synchronization Barrier (DSB) on page B2-86."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "               For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<option>       Specifies an optional limitation on the barrier operation. Values are:",
          "               SY          Full system is the required shareability domain, reads and writes are the required access",
          "                           types in both Group A on page E2-2439 and Group B on page E2-2439. Can be omitted.",
          "                           This option is referred to as the full system DMB. Encoded as option = 0b1111.",
          "               ST          Full system is the required shareability domain, writes are the required access type in",
          "                           both Group A on page E2-2439 and Group B on page E2-2439. SYST is a synonym for",
          "                           ST. Encoded as option = 0b1110.",
          "               LD          Full system is the required shareability domain, reads are the required access type in",
          "                           Group A on page E2-2439, and reads and writes are the required access types in both",
          "                           Group A on page E2-2439 and Group B on page E2-2439. Encoded as option = 0b1101.",
          "                     ISH          Inner Shareable is the required shareability domain, reads and writes are the required",
          "                                  access types in Group B on page E2-2439. Encoded as option = 0b1011.",
          "                     ISHST        Inner Shareable is the required shareability domain, writes are the required access type",
          "                                  in both Group A on page E2-2439 and Group B on page E2-2439. Encoded as option =",
          "                                  0b1010.",
          "                     ISHLD        Inner Shareable is the required shareability domain, reads are the required access type",
          "                                  in Group A on page E2-2439. Encoded as option = 0b1001.",
          "                     NSH          Non-shareable is the required shareability domain, reads and writes are the required",
          "                                  access types in Group B on page E2-2439. Encoded as option = 0b0111.",
          "                     NSHST        Non-shareable is the required shareability domain, writes are the required access type",
          "                                  in both Group A on page E2-2439 and Group B on page E2-2439. Encoded as option =",
          "                                  0b0110.",
          "                     NSHLD        Non-shareable is the required shareability domain, reads are the required access type in",
          "                                  Group A on page E2-2439. Encoded as option = 0b0101.",
          "                     OSH          Outer Shareable is the required shareability domain, reads and writes are the required",
          "                                  access types in Group B on page E2-2439. Encoded as option = 0b0011.",
          "                     OSHST        Outer Shareable is the required shareability domain, writes are the required access type",
          "                                  in both Group A on page E2-2439 and Group B on page E2-2439. Encoded as option =",
          "                                  0b0010.",
          "                     OSHLD        Outer Shareable is the required shareability domain, reads are the required access type",
          "                                  in Group A on page E2-2439. Encoded as option = 0b0001.",
          "                      All other encodings of option are reserved. It is IMPLEMENTATION DEFINED whether options other",
          "                     than SY are implemented. All unsupported and reserved options must execute as a full system barrier",
          "                     operation, but software must not rely on this behavior.",
          "                               Note",
          "                     The instruction supports the following alternative <option> values, but ARM recommends that",
          "                     software does not use these alternative values:",
          "                            SH as an alias for ISH.",
          "                            SHST as an alias for ISHST.",
          "                            UN as an alias for NSH.",
          "                            UNST is an alias for NSHST."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x02200000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "EOR variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "EORS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 1 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE TEQ (immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0800000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "EOR variant"
            },
            {
              "constraint": " S = 1 && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "EORS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "46",
      "names": [
        "EOR",
        "EORS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] EOR imm32;",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register value and an immediate value,",
          "and writes the result to the destination register.",
          "If the destination register is not the PC, the EORS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The EOR variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The EORS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "              PC is used:",
          "                     For the EOR variant, the instruction is a branch to the address calculated by the operation.",
          "                      This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the EORS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>.",
          "              For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>.",
          "<Rn>          For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>       For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "              page F4-2559 for the range of values.",
          "              For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "              page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00200000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "EOR, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "EOR, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "EORS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "EORS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 0 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);             setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "EORS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 1 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE TEQ (register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea800000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "EOR, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "EOR, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && Rd != 1111 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "EORS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11) && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "EORS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "47",
      "names": [
        "EOR",
        "EORS (register)"
      ],
      "operation": {
        "lines": [
          "         if ConditionPassed() then",
          "             EncodingSpecificOperations();",
          "             (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "             result = R[n] EOR shifted;",
          "             if d == 15 then          // Can only occur for A32 encoding",
          "                 if setflags then",
          "                     ALUExceptionReturn(result);",
          "                 else",
          "                     ALUWritePC(result);",
          "             else",
          "                 R[d] = result;",
          "                 if setflags then",
          "PSTATE.N = result<31>;",
          "PSTATE.Z = IsZeroBit(result);",
          "PSTATE.C = carry;",
          "// PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise Exclusive OR (register) performs a bitwise Exclusive OR of a register value and an optionally-shifted",
          "register value, and writes the result to the destination register.",
          "If the destination register is not the PC, the EORS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The EOR variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The EORS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>               See Standard assembler syntax fields on page F2-2506.",
          "<q>               See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>             Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>              For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                  PC is used:",
          "                         For the EOR variant, the instruction is a branch to the address calculated by the operation.",
          "                          This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                          general-purpose registers and the PC on page E1-2378.",
          "                         For the EORS variant, the instruction performs an exception return, that restores PSTATE",
          "                          from SPSR_<current_mode>.",
          "                  For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>.",
          "<Rn>              For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                  be used.",
          "                  For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>              For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                  can be used.",
          "                  For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>           Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                  the following values:",
          "                  LSL          when type = 00",
          "                  LSR          when type = 01",
          "                  ASR          when type = 10",
          "                  ROR          when type = 11",
          "<amount>          Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                  LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "In T32 assembly:",
          "        Outside an IT block, if EORS <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though EORS <Rd>, <Rn> had been written",
          "        Inside an IT block, if EOR<c> <Rd>, <Rn>, <Rd> has <Rd> and <Rn> both in the range R0-R7, it is assembled",
          "         using encoding T1 as though EOR<c> <Rd>, <Rn> had been written.",
          "To prevent either of these happening, use the .W qualifier."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00200010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "48",
      "names": [
        "EOR",
        "EORS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] EOR shifted;",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise Exclusive OR (register-shifted register) performs a bitwise Exclusive OR of a register value and a",
          "register-shifted register value. It writes the result to the destination register, and can optionally update the condition",
          "flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 0 (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) 0 1 1 0 (1) (1) (1) (0)",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0160006e",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ERET{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 0 1 0 (0) 0 (1) (1) (1) (1) 0 0 0 0 0 0 0 0",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "if imm8 != '00000000' then SEE SUBS PC, LR and related instructions;",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf3de8f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ERET{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "49",
      "names": [
        "ERET",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.M IN {M32_User,M32_System} then",
          "        UNPREDICTABLE;                        // UNDEFINED or NOP",
          "    else",
          "        new_pc_value = if PSTATE.EL == EL2 then ELR_hyp else R[14];",
          "        AArch32.ExceptionReturn(new_pc_value, SPSR[]);"
        ]
      },
      "summary": {
        "lines": [
          "Exception Return.",
          "The PE branches to the address held in the register holding the preferred return address, and restores PSTATE from",
          "SPSR_<current_mode>.",
          "The register holding the preferred return address is:",
          "          ELR_hyp, when executing in Hyp mode.",
          "          LR, when executing in a mode other than Hyp mode, User mode, or System mode.",
          "The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from AArch32 state on",
          "page G1-3845.",
          "Exception Return is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "In Debug state, the T1 encoding of ERET is decoded as DRPS."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            },
            {
              "name": "0 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;",
            "if cond != '1110' then UNPREDICTABLE; // HLT must be encoded with AL condition",
            "// imm12:imm4 are for assembly/disassembly only and ignored by hardware"
          ],
          "mask": "0x01000070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "HLT{<q>} {#}<imm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 0 1 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "imm6",
              "size": 6,
              "type": 2
            }
          ],
          "decode": [
            "if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;",
            "// imm6 is for assembly/disassembly only and ignored by hardware"
          ],
          "mask": "0x0000ba80",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "HLT{<q>} {#}<imm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "50",
      "names": [
        "HLT",
        ""
      ],
      "operation": {
        "lines": [
          "EncodingSpecificOperations();",
          "Halt(DebugHalt_HaltInstruction);"
        ]
      },
      "summary": {
        "lines": [
          "Halting breakpoint causes a software breakpoint to occur.",
          "Halting breakpoint is always unconditional, even inside an IT block."
        ]
      },
      "symbols": {
        "lines": [
          "<q>                See Standard assembler syntax fields on page F2-2506. An HLT instruction must be unconditional.",
          "<imm>              For encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                   \"imm12:imm4\" field. This value is ignored by the PE, but can be used by a debugger to store more",
          "                   information about the halting breakpoint.",
          "                   For encoding T1: is a 6-bit unsigned immediate, in the range 0 to 63, encoded in the \"imm6\" field.",
          "                   This value is ignored by the PE, but can be used by a debugger to store more information about the",
          "                   halting breakpoint."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            },
            {
              "name": "0 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if cond != '1110' then UNPREDICTABLE;",
            "imm16 = imm12:imm4;",
            "// imm16 is for assembly/disassembly. It is reported in the HSR but otherwise is ignored by",
            "// hardware. An HVC handler might interpret imm16, for example to determine the required service."
          ],
          "mask": "0x01400070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "HVC{<q>} {#}<imm16>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 1 1 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "// imm16 is for assembly/disassembly. It is reported in the HSR but otherwise is ignored by",
            "// hardware. An HVC handler might interpret imm16, for example to determine the required service.",
            "imm16 = imm4:imm12;",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf7e08000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "HVC{<q>} {#}<imm16>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "51",
      "names": [
        "HVC",
        ""
      ],
      "operation": {
        "lines": [
          "EncodingSpecificOperations();",
          "if !HaveEL(EL2) || PSTATE.EL == EL0 || IsSecure() then",
          "    UNDEFINED;",
          "hvc_enable = if HaveEL(EL3) then SCR_GEN[].HCE else NOT(HCR.HCD);",
          "if hvc_enable == '0' then",
          "    UNDEFINED;",
          "else",
          "    AArch32.CallHypervisor(imm16);"
        ]
      },
      "summary": {
        "lines": [
          "Hypervisor Call causes a Hypervisor Call exception. For more information see Hypervisor Call (HVC) exception",
          "on page G1-3867. Non-secure software executing at EL1 can use this instruction to call the hypervisor to request a",
          "service.",
          "The HVC instruction is:",
          "          UNDEFINED     in Secure state, and in User mode in Non-secure state.",
          "          When SCR.HCE is set to 0, UNDEFINED in Non-secure EL1 modes and CONSTRAINED UNPREDICTABLE in",
          "Hyp mode.",
          "On executing an HVC instruction, the HSR reports the exception as a Hypervisor Call exception, using the EC value",
          "0x12, and captures the value of the immediate argument, see Use of the HSR on page G4-4159."
        ]
      },
      "symbols": {
        "lines": [
          "<q>                   See Standard assembler syntax fields on page F2-2506. An HVC instruction must be unconditional.",
          "     <imm16>         For encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                     \"imm12:imm4\" field.",
          "                     For encoding T1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                     \"imm4:imm12\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 1 0 1 1 1 (1) (1) (1) (1) (1) (1) (1) (1) (0) (0) (0) (0) 0 1 1 0",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf57ff060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ISB{<c>}{<q>} {<option>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 1 (1) (1) (1) (1) 1 0 (0) 0 (1) (1) (1) (1) 0 1 1 0",
              "size": 28,
              "type": 5
            },
            {
              "name": "option",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3bf8f60",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ISB{<c>}{<q>} {<option>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "52",
      "names": [
        "ISB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    InstructionSynchronizationBarrier();"
        ]
      },
      "summary": {
        "lines": [
          "Instruction Synchronization Barrier flushes the pipeline in the PE, so that all instructions following the ISB are",
          "fetched from cache or memory, after the instruction has been completed. It ensures that the effects of context",
          "changing operations executed before the ISB instruction are visible to the instructions fetched after the ISB. Context",
          "changing operations include changing the Address Space Identifier (ASID), TLB maintenance instructions, branch",
          "predictor maintenance operations, and all changes to the System registers. In addition, any branches that appear in",
          "program order after the ISB instruction are written into the branch prediction logic with the context that is visible",
          "after the ISB instruction. This is needed to ensure correct execution of the instruction stream."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "                For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<option>        Specifies an optional limitation on the barrier operation. Values are:",
          "                SY          Full system barrier operation, encoded as option = 0b1111. Can be omitted.",
          "                All other encodings of option are reserved. The corresponding instructions execute as full system",
          "                barrier operations, but must not be relied upon by software."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "firstcond",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=0000",
              "size": 4,
              "type": 4
            }
          ],
          "decode": [
            "if mask == '0000' then SEE \"Related encodings\";",
            "if firstcond == '1111' || (firstcond == '1110' && BitCount(mask) != 1) then UNPREDICTABLE;",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000bf00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "IT{<x>{<y>{<z>}}}{<q>} <cond>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "53",
      "names": [
        "IT",
        ""
      ],
      "operation": {
        "lines": [
          "EncodingSpecificOperations();",
          "AArch32.CheckITEnabled(mask);",
          "PSTATE.IT<7:0> = firstcond:mask;"
        ]
      },
      "summary": {
        "lines": [
          "If-Then makes up to four following instructions (the IT block) conditional. The conditions for the instructions in the",
          "IT block are the same as, or the inverse of, the condition the IT instruction specifies for the first instruction in the",
          "block.",
          "The IT instruction itself does not affect the condition flags, but the execution of the instructions in the IT block can",
          "change the condition flags.",
          "16-bit instructions in the IT block, other than CMP, CMN and TST, do not set the condition flags. An IT instruction with",
          "the AL condition can change the behavior without conditional execution.",
          "The architecture permits exception return to an instruction in the IT block only if the restoration of the CPSR",
          "restores ITSTATE to a state consistent with the conditions specified by the IT instruction. Any other exception",
          "return to an instruction in an IT block is UNPREDICTABLE. Any branch to a target instruction in an IT block is not",
          "permitted, and if such a branch is made it is UNPREDICTABLE what condition is used when executing that target",
          "instruction and any subsequent instruction in the IT block.",
          "See also Conditional instructions on page F1-2469 and Conditional execution on page F2-2507."
        ]
      },
      "symbols": {
        "lines": [
          "<x>             The condition for the second instruction in the IT block. If omitted, the \"mask\" field is set to 0b1000.",
          "                If present it is encoded in the \"mask[3]\" field:",
          "                T            firstcond[0]",
          "                E            NOT firstcond[0]",
          "<y>             The condition for the third instruction in the IT block. If omitted and <x> is present, the \"mask[2:0]\"",
          "                field is set to 0b100. If <y> is present it is encoded in the \"mask[2]\" field:",
          "                T            firstcond[0]",
          "                E            NOT firstcond[0]",
          "<z>             The condition for the fourth instruction in the IT block. If omitted and <y> is present, the \"mask[1:0]\"",
          "                field is set to 0b10. If <z> is present, the \"mask[0]\" field is set to 1, and it is encoded in the \"mask[1]\"",
          "                field:",
          "                T            firstcond[0]",
          "                     E            NOT firstcond[0]",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <cond>          The condition for the first instruction in the IT block, encoded in the \"firstcond\" field. See",
          "                     Table F2-1 on page F2-2507 for the range of conditions available, and the encodings.",
          "     The conditions specified in an IT instruction must match those specified in the syntax of the instructions in its IT",
          "     block. When assembling to A32 code, assemblers check IT instruction syntax for validity but do not generate",
          "     assembled instructions for them. See Conditional instructions on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 0 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01900c9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDA{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 1 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d00faf",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDA{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "54",
      "names": [
        "LDA",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    R[t] = MemO[address, 4];"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Word loads a word from memory and writes it to a register. The instruction also has memory ordering",
          "semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 0 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01d00c9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d00f8f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "55",
      "names": [
        "LDAB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    R[t] = ZeroExtend(MemO[address, 1], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Byte loads a byte from memory, zero-extends it to form a 32-bit word and writes it to a register. The",
          "instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01900e9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEX{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d00fef",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEX{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "56",
      "names": [
        "LDAEX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address, 4);",
          "    R[t] = MemO[address, 4];"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Exclusive Word loads a word from memory, writes it to a register and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>                  Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01d00e9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEXB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 0 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d00fcf",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEXB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "57",
      "names": [
        "LDAEXB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address, 1);",
          "    R[t] = ZeroExtend(MemO[address, 1], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Exclusive Byte loads a byte from memory, zero-extends it to form a 32-bit word, writes it to a register",
          "and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>                  Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); t2 = t + 1; n = UInt(Rn);",
            "if Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01b00e9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1 (1) (1) (1) (1)",
              "size": 8,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn);",
            "if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d000ff",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "58",
      "names": [
        "LDAEXD",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address, 8);",
          "    value = MemO[address, 8];",
          "    // Extract words from 64-bit loaded value such that R[t] is",
          "    // loaded from address and R[t2] from address+4.",
          "    R[t] = if BigEndian() then value<63:32> else value<31:0>;",
          "    R[t2] = if BigEndian() then value<31:0> else value<63:32>;"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Exclusive Doubleword loads a doubleword from memory, writes it to two registers and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "The instruction also acts as a barrier instruction with the ordering requirements described in Load-Acquire,",
          "Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                      <Rt> must be even-numbered and not R14.",
          "                      For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rt2>           For encoding A1: is the second general-purpose register to be transferred. <Rt2> must be <R(t+1)>.",
          "                     For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "     <Rn>            Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01f00e9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEXH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d00fdf",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAEXH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "59",
      "names": [
        "LDAEXH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address, 2);",
          "    R[t] = ZeroExtend(MemO[address, 2], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Exclusive Halfword loads a halfword from memory, zero-extends it to form a 32-bit word, writes it",
          "to a register and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>                  Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 0 0 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01f00c9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8d00f9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDAH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "60",
      "names": [
        "LDAH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    R[t] = ZeroExtend(MemO[address, 2], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load-Acquire Halfword loads a halfword from memory, zero-extends it to form a 32-bit word and writes it to a",
          "register. The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on",
          "page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDC (literal);",
            "if P == '0' && U == '0' && D == '0' && W ==         '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W ==         '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then SEE \"Advanced SIMD         and Floating-point\";",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index =          (P == '1');       add = (U == '1');      wback = (W == '1');"
          ],
          "mask": "0x0c100000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDC (literal);",
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then UNDEFINED;",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index = (P == '1'); add = (U == '1');                 wback = (W == '1');"
          ],
          "mask": "0x0c100000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDC (literal);",
            "if P == '0' && U == '0' && D == '0' && W ==    '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W ==    '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then SEE \"Advanced SIMD    and Floating-point\";",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index =     (P == '1');     add = (U == '1');      wback = (W == '1');"
          ],
          "mask": "0xec100000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDC (literal);",
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then UNDEFINED;",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index = (P == '1'); add = (U == '1');              wback = (W == '1');"
          ],
          "mask": "0xfc100000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "61",
      "names": [
        "LDC",
        "LDC2 (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "    address = if index then offset_addr else R[n];",
          "    repeat",
          "        Coproc_SendLoadedWord(MemA[address,4], cp, ThisInstr());",
          "        address = address + 4;",
          "    until Coproc_DoneLoading(cp, ThisInstr());",
          "    if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Coprocessor (immediate) loads data from consecutive memory addresses to a conceptual coprocessor.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the imm8, CRd, and D field values",
          "that are valid LDC and LDC2 instructions. Other encodings are UNDEFINED. For more information see Conceptual",
          "coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, the permitted LDC access to a system control register can be trapped to Hyp",
          "mode, meaning that an attempt to execute an LDC instruction in a Non-secure mode other than Hyp mode, that would",
          "be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see",
          "Trapping general CP14 accesses to debug registers on page G1-3923.",
          "For simplicity, the LDC pseudocode does not show this possible trap to Hyp mode."
        ]
      },
      "symbols": {
        "lines": [
          "L              If specified, selects the D == 1 form of the encoding. If omitted, selects the D == 0 form.",
          "<c>            For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "               For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "     <coproc>        Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "                     p11, p14, and p15.",
          "     <CRd>           Is the coprocessor register to be transferred, encoded in the \"CRd\" field.",
          "     <Rn>            Is the general-purpose base register, encoded in the \"Rn\" field. If the PC is used, see LDC, LDC2",
          "                     (literal).",
          "     <option>        Is a coprocessor option, in the range 0 to 255 enclosed in { }, encoded in the \"imm8\" field.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     <imm>           Is the immediate offset used for forming the address, a multiple of 4 in the range 0-1020, defaulting",
          "                     to 0 and encoded in the \"imm8\" field, as <imm>/4."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "index = (P == '1'); add = (U == '1'); cp = UInt(coproc); imm32 = ZeroExtend(imm8:'00', 32);",
            "if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0x0c1f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && U == 0 && W == 0).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, <label>"
                },
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [PC, #{+/-}<imm>]"
                },
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [PC], <option>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then UNDEFINED;",
            "index = (P == '1'); add = (U == '1'); cp = UInt(coproc); imm32 = ZeroExtend(imm8:'00', 32);",
            "if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0x0c1f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && U == 0 && W == 0).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, <label>"
                },
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [PC, #{+/-}<imm>]"
                },
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [PC], <option>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "index = (P == '1'); add = (U == '1'); cp = UInt(coproc); imm32 = ZeroExtend(imm8:'00', 32);",
            "if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0xec1f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && U == 0 && W == 0).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, <label>"
                },
                {
                  "aliases": [],
                  "value": "LDC{L}{<c>}{<q>} <coproc>, <CRd>, [PC, #{+/-}<imm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MRRC, MRRC2;",
            "if coproc == '101x' then UNDEFINED;",
            "index = (P == '1'); add = (U == '1'); cp = UInt(coproc); imm32 = ZeroExtend(imm8:'00', 32);",
            "if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0xfc1f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && U == 0 && W == 0).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, <label>"
                },
                {
                  "aliases": [],
                  "value": "LDC2{L}{<c>}{<q>} <coproc>, <CRd>, [PC, #{+/-}<imm>]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "62",
      "names": [
        "LDC",
        "LDC2 (literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    offset_addr = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);",
          "    address = if index then offset_addr else Align(PC,4);",
          "    repeat",
          "        Coproc_SendLoadedWord(MemA[address,4], cp, ThisInstr());",
          "        address = address + 4;",
          "    until Coproc_DoneLoading(cp, ThisInstr());"
        ]
      },
      "summary": {
        "lines": [
          "Load Coprocessor (literal) loads data from consecutive memory addresses to a conceptual coprocessor.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the imm8, CRd, and D field values",
          "that are valid LDC and LDC2 instructions. Other encodings are UNDEFINED. For more information see Conceptual",
          "coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, the permitted LDC access to a system control register can be trapped to Hyp",
          "mode, meaning that an attempt to execute an LDC instruction in a Non-secure mode other than Hyp mode, that would",
          "be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see",
          "Trapping general CP14 accesses to debug registers on page G1-3923.",
          "For simplicity, the LDC pseudocode does not show this possible trap to Hyp mode."
        ]
      },
      "symbols": {
        "lines": [
          "     L               If specified, selects the D == 1 form of the encoding. If omitted, selects the D == 0 form.",
          "     <c>             For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "                     For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "<coproc>        Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "                p11, p14, and p15.",
          "<CRd>           Is the coprocessor register to be transferred, encoded in the \"CRd\" field.",
          "<option>        Is a coprocessor option, in the range 0 to 255 enclosed in { }, encoded in the \"imm8\" field.",
          "<label>         The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required",
          "                value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of",
          "                the offset are multiples of 4 in the range -1020 to 1020. If the offset is zero or positive, imm32 is equal",
          "                to the offset and add == TRUE (encoded as U == 1). If the offset is negative, imm32 is equal to minus",
          "                the offset and add == FALSE (encoded as U == 0).",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<imm>           Is the immediate offset used for forming the address, a multiple of 4 in the range 0-1020, defaulting",
          "                to 0 and encoded in the \"imm8\" field, as <imm>/4.",
          "The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 0 1 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0x08900000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMFD{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Descending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 0 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 8,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = '00000000':register_list;           wback = (registers<n> == '0');",
            "if BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x0000c800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMFD{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Descending stack"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 13,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = P:M:'0':register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;",
            "if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xe8900000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDM{IA}{<c>}.W <Rn>{!}, <registers>// Preferred syntax, if <Rn>, '!' and <registers> can be represented"
                },
                {
                  "aliases": [],
                  "value": "in T1"
                },
                {
                  "aliases": [],
                  "value": "LDMFD{<c>}.W <Rn>{!}, <registers>// Alternate syntax, Full Descending stack, if <Rn>, '!' and <registers>"
                },
                {
                  "aliases": [],
                  "value": "can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMFD{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Descending stack"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "63",
      "names": [
        "LDM",
        "LDMIA LDMFD"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            R[i] = MemA[address,4]; address = address + 4;",
          "    if registers<15> == '1' then",
          "        LoadWritePC(MemA[address,4]);",
          "    if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);",
          "    if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"
        ]
      },
      "summary": {
        "lines": [
          "Load Multiple (Increment After, Full Descending) loads multiple registers from consecutive memory locations",
          "using an address from a base register. The consecutive memory locations start at this address, and the address just",
          "above the highest of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "The registers loaded can include the PC, causing a branch to a loaded address. This is an interworking branch, see",
          "Pseudocode description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "Related system instructions are LDM (User registers) and LDM (exception return).",
          "This instruction is used by the alias POP (multiple registers). See the Alias conditions on page F7-2761 table for",
          "details of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "IA            Is an optional suffix for the Increment After form.",
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!             For encoding A1 and T2: the address adjusted by the size of the data loaded is written back to the",
          "              base register. If specified, it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "              For encoding T1: the address adjusted by the size of the data loaded is written back to the base",
          "              register. It is omitted if <Rn> is included in <registers>, otherwise it must be present.",
          "<registers>   For encoding A1: is a list of one or more registers to be loaded, separated by commas and",
          "              surrounded by { and }. The PC can be in the list. ARM deprecates using these instructions with both",
          "              the LR and the PC in the list.",
          "              For encoding T1: is a list of one or more registers to be loaded, separated by commas and surrounded",
          "              by { and }. The registers in the list must be in the range R0-R7, encoded in the \"register_list\" field.",
          "              For encoding T2: is a list of one or more registers to be loaded, separated by commas and surrounded",
          "              by { and }. The registers in the list must be in the range R0-R12, encoded in the \"register_list\" field,",
          "              and can optionally contain one of the LR or the PC. If the LR is in the list, the \"M\" field is set to 1,",
          "              otherwise it defaults to 0. If the PC is in the list, the \"P\" field is set to 1, otherwise it defaults to 0.",
          "              If the PC is in the list:",
          "                      The LR must not be in the list.",
          "                      The instruction must be either outside any IT block, or the last instruction in an IT block."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 15,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list;",
            "wback = (W == '1'); increment = (U == '1'); wordhigher = (P == U);",
            "if n == 15 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0x08508000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDM{<amode>}{<c>}{<q>} <Rn>{!}, <registers_with_pc>^"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "64",
      "names": [
        "LDM",
        "(exception return)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL2 then",
          "        UNDEFINED;",
          "    elsif PSTATE.M IN {M32_User,M32_System} then",
          "        UNPREDICTABLE;                        // UNDEFINED or NOP",
          "    else",
          "        length = 4*BitCount(registers) + 4;",
          "        address = if increment then R[n] else R[n]-length;",
          "        if wordhigher then address = address+4;",
          "         for i = 0 to 14",
          "             if registers<i> == '1' then",
          "                 R[i] = MemA[address,4];      address = address + 4;",
          "         new_pc_value = MemA[address,4];",
          "         if wback && registers<n> == '0' then R[n] = if increment then R[n]+length else R[n]-length;",
          "         if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;",
          "         AArch32.ExceptionReturn(new_pc_value, SPSR[]);"
        ]
      },
      "summary": {
        "lines": [
          "Load Multiple (exception return) loads multiple registers from consecutive memory locations using an address from",
          "a base register. The SPSR of the current mode is copied to the CPSR. An address adjusted by the size of the data",
          "loaded can optionally be written back to the base register.",
          "The registers loaded include the PC. The word loaded for the PC is treated as an address and a branch occurs to that",
          "address.",
          "Load Multiple (exception return) is:",
          "          UNDEFINED       in Hyp mode.",
          "          UNPREDICTABLE       in debug state, and in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<amode>               is one of:",
          "                      DA           Decrement After. The consecutive memory addresses end at the address in the base",
          "                                   register. Encoded as P = 0, U = 0.",
          "                      FA           Full Ascending. For this instruction, a synonym for DA.",
          "                      DB           Decrement Before. The consecutive memory addresses end one word below the address",
          "                                   in the base register. Encoded as P = 1, U = 0.",
          "                      EA           Empty Ascending. For this instruction, a synonym for DB.",
          "                      IA           Increment After. The consecutive memory addresses start at the address in the base",
          "                                   register. This is the default. Encoded as P = 0, U = 1.",
          "                      FD           Full Descending. For this instruction, a synonym for IA.",
          "                      IB           Increment Before. The consecutive memory addresses start one word above the address",
          "                                   in the base register. Encoded as P = 1, U = 1.",
          "                      ED           Empty Descending. For this instruction, a synonym for IB.",
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "     <Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     !               The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                     it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "     <registers_with_pc> Is a list of one or more registers, separated by commas and surrounded by { and }. It specifies",
          "                     the set of registers to be loaded. The registers are loaded with the lowest-numbered register from the",
          "                     lowest memory address, through to the highest-numbered register from the highest memory address.",
          "                     The PC must be specified in the register list, and the instruction causes a branch to the address (data)",
          "                     loaded into the PC. See also Encoding of lists of general-purpose registers and the PC on",
          "                     page F2-2514.",
          "     Instructions with similar syntax but without the PC included in the registers list are described in LDM (User",
          "     registers)."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 (0) 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 15,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; increment = (U == '1');               wordhigher = (P == U);",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x08500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDM{<amode>}{<c>}{<q>} <Rn>, <registers_without_pc>^"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "65",
      "names": [
        "LDM",
        "(User registers)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL2 then UNDEFINED;",
          "    elsif PSTATE.M IN {M32_User,M32_System} then UNPREDICTABLE;",
          "    else",
          "        length = 4*BitCount(registers);",
          "        address = if increment then R[n] else R[n]-length;",
          "        if wordhigher then address = address+4;",
          "        for i = 0 to 14",
          "            if registers<i> == '1' then // Load User mode register",
          "                Rmode[i, M32_User] = MemA[address,4]; address = address + 4;"
        ]
      },
      "summary": {
        "lines": [
          "In an EL1 mode other than System mode, Load Multiple (User registers) loads multiple User mode registers from",
          "consecutive memory locations using an address from a base register. The registers loaded cannot include the PC.",
          "The PE reads the base register value normally, using the current mode to determine the correct Banked version of",
          "the register. This instruction cannot writeback to the base register.",
          "Load Multiple (User registers) is UNDEFINED in Hyp mode, and UNPREDICTABLE in User and System modes."
        ]
      },
      "symbols": {
        "lines": [
          "<amode>            is one of:",
          "                   DA           Decrement After. The consecutive memory addresses end at the address in the base",
          "                                register. Encoded as P = 0, U = 0.",
          "                   FA           Full Ascending. For this instruction, a synonym for DA.",
          "                   DB           Decrement Before. The consecutive memory addresses end one word below the address",
          "                                in the base register. Encoded as P = 1, U = 0.",
          "                   EA           Empty Ascending. For this instruction, a synonym for DB.",
          "                   IA           Increment After. The consecutive memory addresses start at the address in the base",
          "                                register. This is the default. Encoded as P = 0, U = 1.",
          "                   FD           Full Descending. For this instruction, a synonym for IA.",
          "                   IB           Increment Before. The consecutive memory addresses start one word above the address",
          "                                in the base register. Encoded as P = 1, U = 1.",
          "                   ED           Empty Descending. For this instruction, a synonym for IB.",
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field.",
          "<registers_without_pc> Is a list of one or more registers, separated by commas and surrounded by { and }. It",
          "               specifies the set of registers to be loaded by the LDM instruction. The registers are loaded with the",
          "                   lowest-numbered register from the lowest memory address, through to the highest-numbered",
          "                   register from the highest memory address. The PC must not be in the register list. See also Encoding",
          "                   of lists of general-purpose registers and the PC on page F2-2514.",
          "     Instructions with similar syntax but with the PC included in <registers_without_pc> are described in LDM",
          "     (exception return)."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0x08100000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDMDA{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMFA{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Ascending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "66",
      "names": [
        "LDMDA",
        "LDMFA"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n] - 4*BitCount(registers) + 4;",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            R[i] = MemA[address,4]; address = address + 4;",
          "    if registers<15> == '1' then",
          "              LoadWritePC(MemA[address,4]);",
          "          if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);",
          "          if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"
        ]
      },
      "summary": {
        "lines": [
          "Load Multiple Decrement After (Full Ascending) loads multiple registers from consecutive memory locations using",
          "an address from a base register. The consecutive memory locations end at this address, and the address just below",
          "the lowest of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "The registers loaded can include the PC, causing a branch to a loaded address. This is an interworking branch, see",
          "Pseudocode description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "Related system instructions are LDM (User registers) and LDM (exception return)."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rn>                 Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!                    The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                     it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<registers>          Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The",
          "                     PC can be in the list. ARM deprecates using these instructions with both the LR and the PC in the",
          "                     list."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 1 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0x09100000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDMDB{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMEA{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Empty Ascending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 1 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 13,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = P:M:'0':register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;",
            "if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xe9100000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDMDB{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMEA{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Empty Ascending stack"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "67",
      "names": [
        "LDMDB",
        "LDMEA"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n] - 4*BitCount(registers);",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            R[i] = MemA[address,4]; address = address + 4;",
          "    if registers<15> == '1' then",
          "        LoadWritePC(MemA[address,4]);",
          "    if wback && registers<n> == '0' then R[n] = R[n] - 4*BitCount(registers);",
          "    if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"
        ]
      },
      "summary": {
        "lines": [
          "Load Multiple Decrement Before (Empty Ascending) loads multiple registers from consecutive memory locations",
          "using an address from a base register. The consecutive memory locations end just below this address, and the",
          "address of the lowest of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "The registers loaded can include the PC, causing a branch to a loaded address. This is an interworking branch, see",
          "Pseudocode description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "Related system instructions are LDM (User registers) and LDM (exception return)."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     !               The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                     it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "     <registers>     For encoding A1: is a list of one or more registers to be loaded, separated by commas and",
          "                     surrounded by { and }. The PC can be in the list. ARM deprecates using these instructions with both",
          "                     the LR and the PC in the list.",
          "                     For encoding T1: is a list of one or more registers to be loaded, separated by commas and surrounded",
          "                     by { and }. The registers in the list must be in the range R0-R12, encoded in the \"register_list\" field,",
          "                     and can optionally contain one of the LR or the PC. If the LR is in the list, the \"M\" field is set to 1,",
          "                     otherwise it defaults to 0. If the PC is in the list, the \"P\" field is set to 1, otherwise it defaults to 0.",
          "                     If the PC is in the list:",
          "                            The LR must not be in the list.",
          "                            The instruction must be either outside any IT block, or the last instruction in an IT block."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 1 1 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0x09900000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDMIB{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDMED{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Empty Descending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "68",
      "names": [
        "LDMIB",
        "LDMED"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n] + 4;",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            R[i] = MemA[address,4];           address = address + 4;",
          "    if registers<15> == '1' then",
          "              LoadWritePC(MemA[address,4]);",
          "          if wback && registers<n> == '0' then R[n] = R[n] + 4*BitCount(registers);",
          "          if wback && registers<n> == '1' then R[n] = bits(32) UNKNOWN;"
        ]
      },
      "summary": {
        "lines": [
          "Load Multiple Increment Before (Empty Descending) loads multiple registers from consecutive memory locations",
          "using an address from a base register. The consecutive memory locations start just above this address, and the",
          "address of the last of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "The registers loaded can include the PC, causing a branch to a loaded address. This is an interworking branch, see",
          "Pseudocode description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "Related system instructions are LDM (User registers) and LDM (exception return)."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rn>                 Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!                    The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                     it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<registers>          Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The",
          "                     PC can be in the list. ARM deprecates using these instructions with both the LR and the PC in the",
          "                     list."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDR (literal);",
            "if P == '0' && W == '1' then SEE LDRT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if wback && n == t then UNPREDICTABLE;"
          ],
          "mask": "0x04100000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 1 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rb",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt);       n = UInt(Rn); imm32 = ZeroExtend(imm5:'00', 32);",
            "index = TRUE;       add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00006800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 0 0 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt);    n = 13; imm32 = ZeroExtend(imm8:'00', 32);",
            "index = TRUE;    add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00009800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [SP{, #{+}<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDR (literal);",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32); index = TRUE; add = TRUE;",
            "wback = FALSE; if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf8d00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]// <Rt>, <Rn>, <imm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDR (literal);",
            "if P == '1' && U == '1' && W == '0' then SEE LDRT;",
            "if P == '0' && W == '0' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn);",
            "imm32 = ZeroExtend(imm8, 32); index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;"
          ],
          "mask": "0xf8500800",
          "mnemonics": [
            {
              "constraint": " P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "69",
      "names": [
        "LDR",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)       else (R[n] - imm32);",
          "        address = if index then offset_addr else       R[n];",
          "        data = MemU[address,4];",
          "        if wback then R[n] = offset_addr;",
          "        if t == 15 then",
          "            if address<1:0> == '00' then",
          "                LoadWritePC(data);",
          "            else",
          "                UNPREDICTABLE;",
          "        else",
          "            R[t] = data;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)       else (R[n] - imm32);",
          "        address = if index then offset_addr else       R[n];",
          "        data = MemU[address,4];",
          "        if wback then R[n] = offset_addr;",
          "        if t == 15 then",
          "            if address<1:0> == '00' then",
          "                LoadWritePC(data);",
          "            else",
          "                UNPREDICTABLE;",
          "        else",
          "            R[t] = data;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register (immediate) calculates an address from a base register value and an immediate offset, loads a word",
          "from memory, and writes it to a register. It can use offset, post-indexed, or pre-indexed addressing. For information",
          "about memory accesses see Memory accesses on page F2-2513.",
          "This instruction is used by the alias POP (single register). See the Alias conditions on page F7-2775 table for details",
          "of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<Rt>           For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "               can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This",
          "               is an interworking branch, see Pseudocode description of operations on the AArch32",
          "               general-purpose registers and the PC on page E1-2378.",
          "               For encoding T1 and T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "               For encoding T3: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The SP",
          "               can be used. The PC can be used, provided the instruction is either outside an IT block or the last",
          "               instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to",
          "               the PC. This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "               general-purpose registers and the PC on page E1-2378.",
          "               For encoding T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "               can be used, provided the instruction is either outside an IT block or the last instruction of an IT",
          "               block. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an",
          "               interworking branch, see Pseudocode description of operations on the AArch32 general-purpose",
          "               registers and the PC on page E1-2378.",
          "<Rn>           For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "               used. For PC use see LDR (literal).",
          "               For encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "               For encoding T3 and T4: is the general-purpose base register, encoded in the \"Rn\" field. For PC use",
          "               see LDR (literal).",
          "+/-            Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "               encoded in the \"U\" field. It can have the following values:",
          "               -            when U = 0",
          "               +            when U = 1",
          "     +               Specifies the offset is added to the base register.",
          "     <imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "                     0 to 255, encoded in the \"imm8\" field.",
          "                     For the post-indexed or pre-indexed variant: is the 12-bit unsigned immediate byte offset, in the",
          "                     range 0 to 4095, encoded in the \"imm12\" field.",
          "                     For encoding T1 or T2: is the optional positive unsigned immediate byte offset, a multiple of 4, in",
          "                     the same 0 to 124, defaulting to 0 and encoded in the \"imm5\" field as <imm>/4.",
          "                     For encoding T3: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For encoding T4: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRT;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32);",
            "add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if wback then UNPREDICTABLE;"
          ],
          "mask": "0x041f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && W == 1).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt);       imm32 = ZeroExtend(imm8:'00', 32);     add = TRUE;"
          ],
          "mask": "0x00004800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, <label>// Normal form"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 0 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == '1');",
            "if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf85f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}.W <Rt>, <label>// Preferred syntax, and <Rt>, <label> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "70",
      "names": [
        "LDR",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    base = Align(PC,4);",
          "    address = if add then (base + imm32) else (base - imm32);",
          "    data = MemU[address,4];",
          "    if t == 15 then",
          "        if address<1:0> == '00' then",
          "            LoadWritePC(data);",
          "        else",
          "            UNPREDICTABLE;",
          "    else",
          "        R[t] = data;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register (literal) calculates an address from the PC value and an immediate offset, loads a word from memory,",
          "and writes it to a register. For information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This",
          "                is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                general-purpose registers and the PC on page E1-2378.",
          "                For encoding T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                For encoding T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The SP",
          "                can be used. The PC can be used, provided the instruction is either outside an IT block or the last",
          "                instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to",
          "                the PC. This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                general-purpose registers and the PC on page E1-2378.",
          "<label>         For encoding A1 and T2: the label of the literal data item that is to be loaded into <Rt>. The",
          "                assembler calculates the required value of the offset from the Align(PC, 4) value of the instruction",
          "                to this label. Permitted values of the offset are -4095 to 4095. If the offset is zero or positive, imm32",
          "                is equal to the offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to",
          "                minus the offset and add == FALSE, encoded as U == 0.",
          "                For encoding T1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                Permitted values of the offset are Multiples of four in the range 0 to 1020.",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                defaulting to 0 and encoded in the \"imm12\" field.",
          "                For encoding T2: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                \"imm12\" field.",
          "The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x06100000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDR (literal);",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf8500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDR{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "71",
      "names": [
        "LDR",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "        offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "        address = if index then offset_addr else R[n];",
          "        data = MemU[address,4];",
          "        if wback then R[n] = offset_addr;",
          "        if t == 15 then",
          "            if address<1:0> == '00' then",
          "                LoadWritePC(data);",
          "            else",
          "                UNPREDICTABLE;",
          "        else",
          "            R[t] = data;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "        offset_addr = (R[n] + offset);",
          "        address = offset_addr;",
          "        data = MemU[address,4];",
          "        if t == 15 then",
          "            if address<1:0> == '00' then",
          "                LoadWritePC(data);",
          "            else",
          "                UNPREDICTABLE;",
          "        else",
          "            R[t] = data;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register (register) calculates an address from a base register value and an offset register value, loads a word",
          "from memory, and writes it to a register. The offset register value can optionally be shifted. For information about",
          "memory accesses, see Memory accesses on page F2-2513.",
          "The T32 form of LDR (register) does not support register writeback."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>            For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                     can be used, but this is deprecated.",
          "                     For the offset or post-indexed variant: is the general-purpose register to be transferred, encoded in",
          "                     the \"Rt\" field. The PC can be used. If the PC is used, the instruction branches to the address (data)",
          "                     loaded to the PC. This branch is an interworking branch, see Pseudocode description of operations",
          "                     on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                     For encoding T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                     For encoding T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The SP",
          "                     can be used. The PC can be used, provided the instruction is either outside an IT block or the last",
          "                     instruction of an IT block. If the PC is used, the instruction branches to the address (data) loaded to",
          "                     the PC. This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                     general-purpose registers and the PC on page E1-2378.",
          "     <Rn>            For encoding A1, T1 or T2: is the general-purpose base register, encoded in the \"Rn\" field.",
          "                     For the offset or post-indexed variant: is the general-purpose base register, encoded in the \"Rn\"",
          "                     field. The PC can be used.",
          "     +/-             Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "                     and encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     +               Specifies the index register is added to the base register.",
          "     <Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "     <shift>         The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "                     applied to a register on page F2-2510.",
          "<imm>        If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "             in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRB (literal);",
            "if P == '0' && W == '1' then SEE LDRBT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x04500000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rb",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt);       n = UInt(Rn); imm32 = ZeroExtend(imm5, 32);",
            "index = TRUE;       add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00007800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLD;",
            "if Rn == '1111' then SEE LDRB (literal);",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8900000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]// <Rt>, <Rn>, <imm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE PLD, PLDW (immediate);",
            "if Rn == '1111' then SEE LDRB (literal);",
            "if P == '1' && U == '1' && W == '0' then SEE LDRBT;",
            "if P == '0' && W == '0' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8100800",
          "mnemonics": [
            {
              "constraint": " Rt != 1111 && P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "72",
      "names": [
        "LDRB",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)       else (R[n] - imm32);",
          "        address = if index then offset_addr else       R[n];",
          "        R[t] = ZeroExtend(MemU[address,1], 32);",
          "        if wback then R[n] = offset_addr;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)       else (R[n] - imm32);",
          "        address = if index then offset_addr else       R[n];",
          "        R[t] = ZeroExtend(MemU[address,1], 32);",
          "        if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Byte (immediate) calculates an address from a base register value and an immediate offset, loads a",
          "byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset, post-indexed,",
          "or pre-indexed addressing. For information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "                     used. For PC use see LDRB (literal).",
          "                     For encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "                     For encoding T2 and T3: is the general-purpose base register, encoded in the \"Rn\" field. For PC use",
          "                     see LDRB (literal).",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     +               Specifies the offset is added to the base register.",
          "     <imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "                     0 to 255, encoded in the \"imm8\" field.",
          "                     For the post-indexed or pre-indexed variant: is the 12-bit unsigned immediate byte offset, in the",
          "                     range 0 to 4095, encoded in the \"imm12\" field.",
          "                     For encoding T1: is an optional 5-bit unsigned immediate byte offset, in the same 0 to 31, defaulting",
          "                     to 0 and encoded in the \"imm5\" field.",
          "                     For encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For encoding T3: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRBT;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32);",
            "add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || wback then UNPREDICTABLE;"
          ],
          "mask": "0x045f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && W == 1).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLD;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32);           add = (U == '1');",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf81f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "73",
      "names": [
        "LDRB",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    base = Align(PC,4);",
          "    address = if add then (base + imm32) else (base - imm32);",
          "    R[t] = ZeroExtend(MemU[address,1], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte from",
          "memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory accesses",
          "see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <label>         The label of the literal data item that is to be loaded into <Rt>. The assembler calculates the required",
          "                     value of the offset from the Align(PC, 4) value of the instruction to this label. Permitted values of",
          "                     the offset are -4095 to 4095. If the offset is zero or positive, imm32 is equal to the offset and add ==",
          "                     TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset and add == FALSE,",
          "                     encoded as U == 0.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     <imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                     \"imm12\" field.",
          "     The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "     separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "     information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRBT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if t == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x06500000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005c00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLD;",
            "if Rn == '1111' then SEE LDRB (literal);",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8100000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "74",
      "names": [
        "LDRB",
        "(register)"
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "          offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "address = if index then offset_addr else R[n];",
          "R[t] = ZeroExtend(MemU[address,1],32);",
          "if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Byte (register) calculates an address from a base register value and an offset register value, loads a",
          "byte from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value can",
          "optionally be shifted. For information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                can be used, but this is deprecated.",
          "                For encoding A1, T1, T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            For encoding A1, T1 or T2: is the general-purpose base register, encoded in the \"Rn\" field.",
          "                For the offset or post-indexed variant: is the general-purpose base register, encoded in the \"Rn\"",
          "                field. The PC can be used.",
          "+/-             Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "                and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "+               Specifies the index register is added to the base register.",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>         The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "                applied to a register on page F2-2510.",
          "<imm>           If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "                in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm12, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x04700000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == '1');",
            "register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRB (literal);",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8100e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "75",
      "names": [
        "LDRBT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    R[t] = ZeroExtend(MemU_unpriv[address,1],32);",
          "    if postindex then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Byte Unprivileged loads a byte from memory, zero-extends it to form a 32-bit word, and writes it to",
          "a register. For information about memory accesses see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "LDRBT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or an optionally-shifted register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "              can be used, but this is deprecated.",
          "              For encoding A2 and T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "              used.",
          "              For encoding A2 and T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-           For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "              + if omitted and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "              For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "              defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "<Rm>          Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>       The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "              applied to a register on page F2-2510.",
          "+             Specifies the offset is added to the base register.",
          "<imm>         For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "              defaulting to 0 and encoded in the \"imm12\" field.",
          "              For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "              defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRD (literal);",
            "if Rt<0> == '1' then UNPREDICTABLE;",
            "t = UInt(Rt); t2 = t+1; n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if P == '0' && W == '1' then UNPREDICTABLE;",
            "if wback && (n == t || n == t2) then UNPREDICTABLE;",
            "if t2 == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x004000d0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '0' then SEE \"Related encodings\";",
            "if Rn == '1111' then SEE LDRD (literal);",
            "t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn); imm32 = ZeroExtend(imm8:'00', 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if wback && (n == t || n == t2) then UNPREDICTABLE;",
            "if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xe8500000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "76",
      "names": [
        "LDRD",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "    address = if index then offset_addr else R[n];",
          "    if address == Align(address, 8) then",
          "        data = MemA[address,8];",
          "              if BigEndian() then",
          "                  R[t] = data<63:32>;",
          "                  R[t2] = data<31:0>;",
          "              else",
          "                  R[t] = data<31:0>;",
          "                  R[t2] = data<63:32>;",
          "          else",
          "              R[t] = MemA[address,4];",
          "              R[t2] = MemA[address+4,4];",
          "          if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Dual (immediate) calculates an address from a base register value and an immediate offset, loads two",
          "words from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing.",
          "For information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<Rt>           For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "               This register must be even-numbered and not R14.",
          "               For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rt2>          For encoding A1: is the second general-purpose register to be transferred. This register must be",
          "               <R(t+1)>.",
          "               For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "<Rn>           For encoding A1 or T1: is the general-purpose base register, encoded in the \"Rn\" field. For PC use",
          "               see LDRD (literal).",
          "               For the post-indexed or pre-indexed variant: is the general-purpose base register, encoded in the",
          "               \"Rn\" field.",
          "+/-            Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "               encoded in the \"U\" field. It can have the following values:",
          "               -            when U = 0",
          "               +            when U = 1",
          "<imm>          For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "               defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "               For the post-indexed or pre-indexed variant: is the unsigned immediate byte offset, a multiple of 4,",
          "               in the range 0 to 1020, encoded in the \"imm8\" field as <imm>/4.",
          "               For the post-indexed or pre-indexed variant: is the 8-bit unsigned immediate byte offset, in the range",
          "               0 to 255, encoded in the \"imm4H:imm4L\" field.",
          "               For encoding T1: is the optional unsigned immediate byte offset, a multiple of 4, in the range 0 to",
          "               1020, defaulting to 0 and encoded in the \"imm8\" field as <imm>/4."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 (0) 0 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if Rt<0> == '1' then UNPREDICTABLE;",
            "t = UInt(Rt); t2 = t+1; imm32 = ZeroExtend(imm4H:imm4L, 32);               add = (U == '1');",
            "if t2 == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x014f00d0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '0' then SEE \"Related encodings\";",
            "t = UInt(Rt); t2 = UInt(Rt2);",
            "imm32 = ZeroExtend(imm8:'00', 32); add = (U == '1');",
            "if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if W == '1' then UNPREDICTABLE;"
          ],
          "mask": "0xe85f0000",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && W == 0).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "77",
      "names": [
        "LDRD",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);",
          "    if address == Align(address, 8) then",
          "        data = MemA[address,8];",
          "        if BigEndian() then",
          "            R[t] = data<63:32>;",
          "            R[t2] = data<31:0>;",
          "        else",
          "            R[t] = data<31:0>;",
          "            R[t2] = data<63:32>;",
          "    else",
          "        R[t] = MemA[address,4];",
          "        R[t2] = MemA[address+4,4];"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Dual (literal) calculates an address from the PC value and an immediate offset, loads two words from",
          "memory, and writes them to two registers. For information about memory accesses see Memory accesses on",
          "page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                   This register must be even-numbered and not R14.",
          "                     For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rt2>           For encoding A1: is the second general-purpose register to be transferred. This register must be",
          "                     <R(t+1)>.",
          "                     For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "     <label>         For encoding A1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                     calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                     Any value in the range -255 to 255 is permitted. If the offset is zero or positive, imm32 is equal to the",
          "                     offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                     and add == FALSE, encoded as U == 0.",
          "                     For encoding T1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                     calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                     Permitted values of the offset are multiples of 4 in the range -1020 to 1020. If the offset is zero or",
          "                     positive, imm32 is equal to the offset and add == TRUE, encoded as U == 1. If the offset is negative,",
          "                     imm32 is equal to minus the offset and add == FALSE, encoded as U == 0.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     <imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                     For encoding T1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm8\" field.",
          "     The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "     separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "     information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rt<0> == '1' then UNPREDICTABLE;",
            "t = UInt(Rt); t2 = t+1; n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if P == '0' && W == '1' then UNPREDICTABLE;",
            "if t2 == 15 || m == 15 || m == t || m == t2 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;"
          ],
          "mask": "0x000000d0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "78",
      "names": [
        "LDRD",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);",
          "    address = if index then offset_addr else R[n];",
          "    if address == Align(address, 8) then",
          "        data = MemA[address,8];",
          "        if BigEndian() then",
          "            R[t] = data<63:32>;",
          "            R[t2] = data<31:0>;",
          "        else",
          "            R[t] = data<31:0>;",
          "            R[t2] = data<63:32>;",
          "    else",
          "        R[t] = MemA[address,4];",
          "        R[t2] = MemA[address+4,4];",
          "      if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Dual (register) calculates an address from a base register value and a register offset, loads two words",
          "from memory, and writes them to two registers. It can use offset, post-indexed, or pre-indexed addressing. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must",
          "                   be even-numbered and not R14.",
          "<Rt2>              Is the second general-purpose register to be transferred. This register must be <R(t+1)>.",
          "<Rn>               For the offset variant: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "                   used.",
          "                   For the post-indexed and pre-indexed variant: is the general-purpose base register, encoded in the",
          "                   \"Rn\" field.",
          "     +/-             Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "                     and encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     <Rm>            Is the general-purpose index register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); imm32 = Zeros(32); // Zero offset",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01900f9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREX{<c>}{<q>} <Rt>, [<Rn> {, {#}<imm>}]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8:'00', 32);",
            "if t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xe8500f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREX{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "79",
      "names": [
        "LDREX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n] + imm32;",
          "    AArch32.SetExclusiveMonitors(address,4);",
          "    R[t] = MemA[address,4];"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Exclusive calculates an address from a base register value and an immediate offset, loads a word from",
          "memory, writes it to a register and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>                  Is the general-purpose base register, encoded in the \"Rn\" field.",
          "<imm>                 For encoding A1: the immediate offset added to the value of <Rn> to calculate the address. <imm> can",
          "                      only be 0 or omitted.",
          "                     For encoding T1: the immediate offset added to the value of <Rn> to calculate the address. <imm> can",
          "                     be omitted, meaning an offset of 0. Values are multiples of 4 in the range 0-1020."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01d00f9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREXB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xe8d00f4f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREXB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "80",
      "names": [
        "LDREXB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address,1);",
          "    R[t] = ZeroExtend(MemA[address,1], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Exclusive Byte derives an address from a base register value, loads a byte from memory, zero-extends",
          "it to form a 32-bit word, writes it to a register and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>                  Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); t2 = t + 1; n = UInt(Rn);",
            "if Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01b00f9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 1 (1) (1) (1) (1)",
              "size": 8,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn);",
            "if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xe8d0007f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "81",
      "names": [
        "LDREXD",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address,8);",
          "    value = MemA[address,8];",
          "    // Extract words from 64-bit loaded value such that R[t] is",
          "    // loaded from address and R[t2] from address+4.",
          "    R[t] = if BigEndian() then value<63:32> else value<31:0>;",
          "    R[t2] = if BigEndian() then value<31:0> else value<63:32>;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Exclusive Doubleword derives an address from a base register value, loads a 64-bit doubleword from",
          "memory, writes it to two registers and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                      <Rt> must be even-numbered and not R14.",
          "                      For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rt2>           For encoding A1: is the second general-purpose register to be transferred. <Rt2> must be <R(t+1)>.",
          "                     For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "     <Rn>            Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01f00f9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREXH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xe8d00f5f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDREXH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "82",
      "names": [
        "LDREXH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    AArch32.SetExclusiveMonitors(address,2);",
          "    R[t] = ZeroExtend(MemA[address,2], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Exclusive Halfword derives an address from a base register value, loads a halfword from memory,",
          "zero-extends it to form a 32-bit word, writes it to a register and:",
          "          If the address has the Shared Memory attribute, marks the physical address as exclusive access for the",
          "executing PE in a global monitor.",
          "          Causes the executing PE to indicate an active exclusive access in the local monitor.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                   See Standard assembler syntax fields on page F2-2506.",
          "<q>                   See Standard assembler syntax fields on page F2-2506.",
          "<Rt>                  Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>                  Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRH (literal);",
            "if P == '0' && W == '1' then SEE LDRHT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x005000b0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 0 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rb",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt);       n = UInt(Rn); imm32 = ZeroExtend(imm5:'0', 32);",
            "index = TRUE;       add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00008800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLD (immediate);",
            "if Rn == '1111' then SEE LDRH (literal);",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8b00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]// <Rt>, <Rn>, <imm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRH (literal);",
            "if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE PLDW (immediate);",
            "if P == '1' && U == '1' && W == '0' then SEE LDRHT;",
            "if P == '0' && W == '0' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8300800",
          "mnemonics": [
            {
              "constraint": " Rt != 1111 && P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "83",
      "names": [
        "LDRH",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)     else (R[n] - imm32);",
          "        address = if index then offset_addr else     R[n];",
          "        data = MemU[address,2];",
          "        if wback then R[n] = offset_addr;",
          "        R[t] = ZeroExtend(data, 32);",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)     else (R[n] - imm32);",
          "        address = if index then offset_addr else     R[n];",
          "        data = MemU[address,2];",
          "        if wback then R[n] = offset_addr;",
          "        R[t] = ZeroExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Halfword (immediate) calculates an address from a base register value and an immediate offset, loads",
          "a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. It can use offset,",
          "post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on",
          "page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>         For encoding A1, T2 or T3: is the general-purpose base register, encoded in the \"Rn\" field. For PC",
          "             use see LDRH (literal).",
          "             For the offset, post-indexed or pre-indexed variant: is the general-purpose base register, encoded in",
          "             the \"Rn\" field.",
          "+/-          Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "             encoded in the \"U\" field. It can have the following values:",
          "             -            when U = 0",
          "             +            when U = 1",
          "+            Specifies the offset is added to the base register.",
          "<imm>        For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "             defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "             For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "             0 to 255, encoded in the \"imm8\" field.",
          "             For the post-indexed or pre-indexed variant: is the 8-bit unsigned immediate byte offset, in the range",
          "             0 to 255, encoded in the \"imm4H:imm4L\" field.",
          "             For encoding T1: is the optional positive unsigned immediate byte offset, a multiple of 2, in the",
          "             same 0 to 62 defaulting to 0 and encoded in the \"imm5\" field as <imm>/2.",
          "             For encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "             defaulting to 0 and encoded in the \"imm12\" field.",
          "             For encoding T3: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "             defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRHT;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || wback then UNPREDICTABLE;"
          ],
          "mask": "0x005f00b0",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && W == 1).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLD (literal);",
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32);           add = (U == '1');",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf83f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "84",
      "names": [
        "LDRH",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    base = Align(PC,4);",
          "    address = if add then (base + imm32) else (base - imm32);",
          "    data = MemU[address,2];",
          "    R[t] = ZeroExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Halfword (literal) calculates an address from the PC value and an immediate offset, loads a halfword",
          "from memory, zero-extends it to form a 32-bit word, and writes it to a register. For information about memory",
          "accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<label>         For encoding A1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                Any value in the range -255 to 255 is permitted. If the offset is zero or positive, imm32 is equal to the",
          "                offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                and add == FALSE, encoded as U == 0.",
          "                For encoding T1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                Permitted values of the offset are -4095 to 4095. If the offset is zero or positive, imm32 is equal to the",
          "                offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                and add == FALSE, encoded as U == 0.",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                For encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                \"imm12\" field.",
          "The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRHT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if t == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x001000b0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005a00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRH (literal);",
            "if Rt == '1111' then SEE PLDW (register);",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8300000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "85",
      "names": [
        "LDRH",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if index then offset_addr else R[n];",
          "    data = MemU[address,2];",
          "    if wback then R[n] = offset_addr;",
          "    R[t] = ZeroExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Halfword (register) calculates an address from a base register value and an offset register value, loads",
          "a halfword from memory, zero-extends it to form a 32-bit word, and writes it to a register. The offset register value",
          "can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see Memory accesses on",
          "page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For the offset, post-indexed, pre-indexed or register-offset variant: is the general-purpose base",
          "              register, encoded in the \"Rn\" field.",
          "+/-           Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "              and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "+             Specifies the index register is added to the base register.",
          "<Rm>          Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<imm>         If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "              in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x007000b0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE;                   add = (U == '1');",
            "register_form = TRUE;",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x003000b0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRH (literal);",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8300e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "86",
      "names": [
        "LDRHT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then R[m] else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    data = MemU_unpriv[address,2];",
          "    if postindex then R[n] = offset_addr;",
          "    R[t] = ZeroExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Halfword Unprivileged loads a halfword from memory, zero-extends it to form a 32-bit word, and",
          "writes it to a register. For information about memory accesses see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "LDRHT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or a register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          Is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-           For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "              + if omitted and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "              For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "              defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "<Rm>          Is the general-purpose index register, encoded in the \"Rm\" field.",
          "+             Specifies the offset is added to the base register.",
          "<imm>         For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "              defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "              For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "              defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSB (literal);",
            "if P == '0' && W == '1' then SEE LDRSBT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x005000d0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLI;",
            "if Rn == '1111' then SEE LDRSB (literal);",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9900000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE PLI;",
            "if Rn == '1111' then SEE LDRSB (literal);",
            "if P == '1' && U == '1' && W == '0' then SEE LDRSBT;",
            "if P == '0' && W == '0' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9100800",
          "mnemonics": [
            {
              "constraint": " P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "87",
      "names": [
        "LDRSB",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "    address = if index then offset_addr else R[n];",
          "    R[t] = SignExtend(MemU[address,1], 32);",
          "    if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Byte (immediate) calculates an address from a base register value and an immediate offset,",
          "loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use offset,",
          "post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on",
          "page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          For encoding A1, T1 or T2: is the general-purpose base register, encoded in the \"Rn\" field. For PC",
          "              use see LDRSB (literal).",
          "              For the post-indexed or pre-indexed variant: is the general-purpose base register, encoded in the",
          "              \"Rn\" field.",
          "+/-           Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "              encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "+             Specifies the offset is added to the base register.",
          "<imm>         For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "              defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                     For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "                     0 to 255, encoded in the \"imm8\" field.",
          "                     For the post-indexed or pre-indexed variant: is the 8-bit unsigned immediate byte offset, in the range",
          "                     0 to 255, encoded in the \"imm4H:imm4L\" field.",
          "                     For encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For encoding T2: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRSBT;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || wback then UNPREDICTABLE;"
          ],
          "mask": "0x005f00d0",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && W == 1).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLI;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32);           add = (U == '1');",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf91f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "88",
      "names": [
        "LDRSB",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    base = Align(PC,4);",
          "    address = if add then (base + imm32) else (base - imm32);",
          "    R[t] = SignExtend(MemU[address,1], 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Byte (literal) calculates an address from the PC value and an immediate offset, loads a byte",
          "from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about memory",
          "accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <label>         For encoding A1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                     calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                     Any value in the range -255 to 255 is permitted. If the offset is zero or positive, imm32 is equal to the",
          "                     offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                     and add == FALSE, encoded as U == 0.",
          "                     For encoding T1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                     calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                     Permitted values of the offset are -4095 to 4095. If the offset is zero or positive, imm32 is equal to the",
          "                     offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                     and add == FALSE, encoded as U == 0.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     <imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                     For encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                     \"imm12\" field.",
          "     The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "     separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "     information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRSBT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if t == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x001000d0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 0 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005600",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE PLI;",
            "if Rn == '1111' then SEE LDRSB (literal);",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9100000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "89",
      "names": [
        "LDRSB",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if index then offset_addr else R[n];",
          "    R[t] = SignExtend(MemU[address,1], 32);",
          "    if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Byte (register) calculates an address from a base register value and an offset register value,",
          "loads a byte from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset register value",
          "can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see Memory accesses on",
          "page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "                used.",
          "                For the offset, post-indexed, pre-indexed or register-offset variant: is the general-purpose base",
          "                register, encoded in the \"Rn\" field.",
          "+/-             Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "                and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "+               Specifies the index register is added to the base register.",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<imm>           If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "                in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x007000d0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE;                   add = (U == '1');",
            "register_form = TRUE;",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x003000d0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSB (literal);",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9100e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "90",
      "names": [
        "LDRSBT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then R[m] else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    R[t] = SignExtend(MemU_unpriv[address,1], 32);",
          "    if postindex then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Byte Unprivileged loads a byte from memory, sign-extends it to form a 32-bit word, and",
          "writes it to a register. For information about memory accesses see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "LDRSBT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or a register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "                + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "                For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "                defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSH (literal);",
            "if P == '0' && W == '1' then SEE LDRSHT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x005000f0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 1 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSH (literal);",
            "if Rt == '1111' then SEE \"Related instructions\";",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9b00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSH (literal);",
            "if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE \"Related instructions\";",
            "if P == '1' && U == '1' && W == '0' then SEE LDRSHT;",
            "if P == '0' && W == '0' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9300800",
          "mnemonics": [
            {
              "constraint": " P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "91",
      "names": [
        "LDRSH",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "    address = if index then offset_addr else R[n];",
          "    data = MemU[address,2];",
          "    if wback then R[n] = offset_addr;",
          "    R[t] = SignExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Halfword (immediate) calculates an address from a base register value and an immediate",
          "offset, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. It can use",
          "offset, post-indexed, or pre-indexed addressing. For information about memory accesses see Memory accesses on",
          "page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rn>            For encoding A1, T1 or T2: is the general-purpose base register, encoded in the \"Rn\" field. For PC",
          "                     use see LDRSH (literal).",
          "                     For the post-indexed or pre-indexed variant: is the general-purpose base register, encoded in the",
          "                     \"Rn\" field.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     +               Specifies the offset is added to the base register.",
          "<imm>        For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "             defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "             For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "             0 to 255, encoded in the \"imm8\" field.",
          "             For the post-indexed or pre-indexed variant: is the 8-bit unsigned immediate byte offset, in the range",
          "             0 to 255, encoded in the \"imm4H:imm4L\" field.",
          "             For encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "             defaulting to 0 and encoded in the \"imm12\" field.",
          "             For encoding T2: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "             defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRSHT;",
            "t = UInt(Rt); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 || wback then UNPREDICTABLE;"
          ],
          "mask": "0x005f00f0",
          "mnemonics": [
            {
              "constraint": " !(P == 0 && W == 1).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rt == '1111' then SEE \"Related instructions\";",
            "t = UInt(Rt); imm32 = ZeroExtend(imm12, 32); add = (U == '1');",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf93f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "92",
      "names": [
        "LDRSH",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    base = Align(PC,4);",
          "    address = if add then (base + imm32) else (base - imm32);",
          "    data = MemU[address,2];",
          "    R[t] = SignExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Halfword (literal) calculates an address from the PC value and an immediate offset, loads a",
          "halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. For information about",
          "memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<label>         For encoding A1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                Any value in the range -255 to 255 is permitted. If the offset is zero or positive, imm32 is equal to the",
          "                offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                and add == FALSE, encoded as U == 0.",
          "                For encoding T1: the label of the literal data item that is to be loaded into <Rt>. The assembler",
          "                calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                Permitted values of the offset are -4095 to 4095. If the offset is zero or positive, imm32 is equal to the",
          "                offset and add == TRUE, encoded as U == 1. If the offset is negative, imm32 is equal to minus the offset",
          "                and add == FALSE, encoded as U == 0.",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                For encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                \"imm12\" field.",
          "The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE LDRSHT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if t == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x001000f0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 8,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSH (literal);",
            "if Rt == '1111' then SEE \"Related instructions\";",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9300000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "93",
      "names": [
        "LDRSH",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if index then offset_addr else R[n];",
          "          data = MemU[address,2];",
          "          if wback then R[n] = offset_addr;",
          "          R[t] = SignExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Halfword (register) calculates an address from a base register value and an offset register",
          "value, loads a halfword from memory, sign-extends it to form a 32-bit word, and writes it to a register. The offset",
          "register value can be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see Memory accesses",
          "on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<Rt>           Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>           For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "               used.",
          "               For the offset, post-indexed, pre-indexed or register-offset variant: is the general-purpose base",
          "               register, encoded in the \"Rn\" field.",
          "+/-            Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "               and encoded in the \"U\" field. It can have the following values:",
          "               -            when U = 0",
          "               +            when U = 1",
          "+              Specifies the index register is added to the base register.",
          "<Rm>           Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<imm>          If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "               in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x007000f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE;                   add = (U == '1');",
            "register_form = TRUE;",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x003000f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDRSH (literal);",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf9300e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRSHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "94",
      "names": [
        "LDRSHT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then R[m] else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    data = MemU_unpriv[address,2];",
          "    if postindex then R[n] = offset_addr;",
          "    R[t] = SignExtend(data, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Signed Halfword Unprivileged loads a halfword from memory, sign-extends it to form a 32-bit word,",
          "and writes it to a register. For information about memory accesses see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "LDRSHT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or a register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "                + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "                For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "                defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm12, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x04300000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == '1');",
            "register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE LDR (literal);",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8500e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "LDRT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "95",
      "names": [
        "LDRT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    data = MemU_unpriv[address,4];",
          "    if postindex then R[n] = offset_addr;",
          "    R[t] = data;"
        ]
      },
      "summary": {
        "lines": [
          "Load Register Unprivileged loads a word from memory, and writes it to a register. For information about memory",
          "accesses see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "LDRT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or an optionally-shifted register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                can be used, but this is deprecated.",
          "                For encoding A2 and T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "                used.",
          "                For encoding A2 and T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "                + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "                For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "                defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>         The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "                applied to a register on page F2-2510.",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                defaulting to 0 and encoded in the \"imm12\" field.",
          "                For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=00000",
              "size": 5,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSL{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "!=00000",
              "size": 5,
              "type": 4
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSL<c>{<q>} {<Rd>,} <Rm>, #<imm>// Inside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 0 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea4f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSL<c>.W {<Rd>,} <Rm>, #<imm>// Inside IT block, and <Rd>, <Rm>, <imm> can be represented in T2"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSL{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "96",
      "names": [
        "LSL",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Left (immediate) shifts a register value left by an immediate number of bits, shifting in zeros, and",
          "writes the result to the destination register.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                   deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch",
          "                   to the address calculated by the operation. This is an interworking branch, see Pseudocode",
          "                   description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                   For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                   used.",
          "                   For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>              For encoding A1 and T2: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field.",
          "                   For encoding T3: is the shift amount, in the range 1 to 31, encoded in the \"imm3:imm2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSL{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00004080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rdm>, <Rdm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSL<c>{<q>} {<Rdm>,} <Rdm>, <Rs>// Inside IT block"
                }
              ],
              "name": "Logical shift left variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa00f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSL<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "97",
      "names": [
        "LSL",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Left (register) shifts a register value left by a variable number of bits, shifting in zeros, and writes the",
          "result to the destination register. The variable number of bits is read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=00000",
              "size": 5,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSLS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "!=00000",
              "size": 5,
              "type": 4
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSLS{<q>} {<Rd>,} <Rm>, #<imm>// Outside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 1 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea5f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSLS.W {<Rd>,} <Rm>, #<imm>// Outside IT block, and <Rd>, <Rm>, <imm> can be represented in T2"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSL #<imm>"
                    }
                  ],
                  "value": "LSLS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "98",
      "names": [
        "LSLS",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Left, setting flags (immediate) shifts a register value left by an immediate number of bits, shifting in",
          "zeros, and writes the result to the destination register.",
          "If the destination register is not the PC, this instruction updates the condition flags based on the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "         The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from AArch32",
          "state on page G1-3845.",
          "         The instruction is UNDEFINED in Hyp mode.",
          "         The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                   deprecates using the PC as the destination register, but if the PC is used, the instruction performs an",
          "                   exception return, that restores PSTATE from SPSR_<current_mode>.",
          "                   For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                   used.",
          "                   For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>              For encoding A1 and T2: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field.",
          "                   For encoding T3: is the shift amount, in the range 1 to 31, encoded in the \"imm3:imm2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSLS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00004080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rdm>, <Rdm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSLS{<q>} {<Rdm>,} <Rdm>, <Rs>// Outside IT block"
                }
              ],
              "name": "Logical shift left variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa10f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSLS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSL <Rs>"
                    }
                  ],
                  "value": "LSLS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "99",
      "names": [
        "LSLS",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Left, setting flags (register) shifts a register value left by a variable number of bits, shifting in zeros,",
          "writes the result to the destination register, and updates the condition flags based on the result. The variable number",
          "of bits is read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00000800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSR<c>{<q>} {<Rd>,} <Rm>, #<imm>// Inside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 0 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea4f0010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSR<c>.W {<Rd>,} <Rm>, #<imm>// Inside IT block, and <Rd>, <Rm>, <imm> can be represented in T2"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "100",
      "names": [
        "LSR",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Right (immediate) shifts a register value right by an immediate number of bits, shifting in zeros, and",
          "writes the result to the destination register.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                   deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch",
          "                   to the address calculated by the operation. This is an interworking branch, see Pseudocode",
          "                   description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                   For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                   used.",
          "                   For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>              For encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as",
          "                   <imm> modulo 32.",
          "                   For encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as",
          "                   <imm> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00030",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 0 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x000040c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rdm>, <Rdm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>// Inside IT block"
                }
              ],
              "name": "Logical shift right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa20f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSR<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "101",
      "names": [
        "LSR",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Right (register) shifts a register value right by a variable number of bits, shifting in zeros, and writes",
          "the result to the destination register. The variable number of bits is read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x00000800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSRS{<q>} {<Rd>,} <Rm>, #<imm>// Outside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 1 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea5f0010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSRS.W {<Rd>,} <Rm>, #<imm>// Outside IT block, and <Rd>, <Rm>, <imm> can be represented in T2"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSR #<imm>"
                    }
                  ],
                  "value": "LSRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "102",
      "names": [
        "LSRS",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Right, setting flags (immediate) shifts a register value right by an immediate number of bits, shifting",
          "in zeros, and writes the result to the destination register.",
          "If the destination register is not the PC, this instruction updates the condition flags based on the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "         The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from AArch32",
          "state on page G1-3845.",
          "         The instruction is UNDEFINED in Hyp mode.",
          "         The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                   deprecates using the PC as the destination register, but if the PC is used, the instruction performs an",
          "                   exception return, that restores PSTATE from SPSR_<current_mode>.",
          "                   For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                   used.",
          "                   For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>              For encoding A1 and T2: is the shift amount, in the range 1 to 32, encoded in the \"imm5\" field as",
          "                   <imm> modulo 32.",
          "                   For encoding T3: is the shift amount, in the range 1 to 32, encoded in the \"imm3:imm2\" field as",
          "                   <imm> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00030",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 0 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x000040c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rdm>, <Rdm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSRS{<q>} {<Rdm>,} <Rdm>, <Rs>// Outside IT block"
                }
              ],
              "name": "Logical shift right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa30f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSRS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, LSR <Rs>"
                    }
                  ],
                  "value": "LSRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "103",
      "names": [
        "LSRS",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Logical Shift Right, setting flags (register) shifts a register value right by an immediate number of bits, shifting in",
          "zeros, writes the result to the destination register, and updates the condition flags based on the result. The variable",
          "number of bits is read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); cp = UInt(coproc);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0e000010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); cp = UInt(coproc);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0e000010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCR2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); cp = UInt(coproc);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xee000010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); cp = UInt(coproc);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfe000010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCR2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "104",
      "names": [
        "MCR",
        "MCR2"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    Coproc_SendOneWord(R[t], cp, ThisInstr());"
        ]
      },
      "summary": {
        "lines": [
          "Move to Coprocessor from general-purpose register passes the value of a general-purpose register to a conceptual",
          "coprocessor.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the opc1, opc2, CRn, and CRd field",
          "values that are valid MCR and MCR2 instructions. Other encodings are UNDEFINED. For more information see",
          "Conceptual coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, MCR accesses to system control registers can be trapped to Hyp mode,",
          "meaning that an attempt to execute an MCR instruction in a Non-secure mode other than Hyp mode, that would be",
          "permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see EL2",
          "configurable controls on page G1-3909.",
          "Because of the range of possible traps to Hyp mode, the MCR pseudocode does not show these possible traps."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "                For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<coproc>        Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "                p11, p14, and p15.",
          "<opc1>          Is a coprocessor-specific opcode in the range 0 to 7, encoded in the \"opc1\" field.",
          "<Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<CRn>           Is the first coprocessor register, encoded in the \"CRn\" field.",
          "<CRm>           Is the second coprocessor register, encoded in the \"CRm\" field.",
          "<opc2>          Is a coprocessor-specific opcode in the range 0 to 7, defaulting to 0 and encoded in the \"opc2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 0 0 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0c400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCRR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 0 0 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0c400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCRR2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xec400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCRR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfc400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MCRR2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "105",
      "names": [
        "MCRR",
        "MCRR2"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    Coproc_SendTwoWords(R[t2], R[t], cp, ThisInstr());"
        ]
      },
      "summary": {
        "lines": [
          "Move to Coprocessor from two general-purpose registers passes the values of two general-purpose registers to a",
          "conceptual coprocessor.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the opc1, and CRm field values that",
          "are valid MCRR and MCRR2 instructions. Other encodings are UNDEFINED. For more information see Conceptual",
          "coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, MCRR accesses to system control registers can be trapped to Hyp mode,",
          "meaning that an attempt to execute an MCRR instruction in a Non-secure mode other than Hyp mode, that would be",
          "permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see EL2",
          "configurable controls on page G1-3909.",
          "Because of the range of possible traps to Hyp mode, the MCRR pseudocode does not show these possible traps."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "                For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<coproc>        Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "                p11, p14, and p15.",
          "<opc1>          Is a coprocessor-specific opcode in the range 0 to 15, encoded in the \"opc1\" field.",
          "<Rt>            Is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rt2>           Is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "<CRm>           Is a coprocessor register, encoded in the \"CRm\" field.",
          "The relative significance of <Rt2> and <Rt> is IMPLEMENTATION DEFINED for IMPLEMENTATION DEFINED uses of the",
          "MCRR and MRRC instructions. For the architected uses, as described in this manual, <Rt2> transfers bits[63:32] of the",
          "selected coprocessor register, while <Rt> transfers bits[31:0]."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); setflags = (S == '1');",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00200090",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MLAS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE MUL;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); setflags = FALSE;",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "106",
      "names": [
        "MLA",
        "MLAS"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand1 = SInt(R[n]); // operand1 = UInt(R[n]) produces the same final results",
          "    operand2 = SInt(R[m]); // operand2 = UInt(R[m]) produces the same final results",
          "    addend   = SInt(R[a]); // addend    = UInt(R[a]) produces the same final results",
          "    result = operand1 * operand2 + addend;",
          "    R[d] = result<31:0>;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result<31:0>);",
          "        // PSTATE.C, PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Multiply Accumulate multiplies two register values, and adds a third register value. The least significant 32 bits of",
          "the result are written to the destination register. These 32 bits do not depend on whether the source register values",
          "are considered to be signed values or unsigned values.",
          "In an A32 instruction, the condition flags can optionally be updated based on the result. Use of this option adversely",
          "affects performance on many implementations."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.",
          "<Ra>         Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00600090",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb000010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "107",
      "names": [
        "MLS",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand1 = SInt(R[n]); // operand1 = UInt(R[n]) produces the same final results",
          "    operand2 = SInt(R[m]); // operand2 = UInt(R[m]) produces the same final results",
          "    addend   = SInt(R[a]); // addend    = UInt(R[a]) produces the same final results",
          "    result = addend - operand1 * operand2;",
          "    R[d] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Multiply and Subtract multiplies two register values, and subtracts the product from a third register value. The least",
          "significant 32 bits of the result are written to the destination register. These 32 bits do not depend on whether the",
          "source register values are considered to be signed values or unsigned values."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.",
          "<Ra>               Is the third general-purpose source register holding the minuend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       setflags = (S == '1');     (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x03a00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MOV variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MOVS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = FALSE;        imm32 = ZeroExtend(imm4:imm12, 32);",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x03000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, #<imm16>// <imm16> can not be represented in A1"
                },
                {
                  "aliases": [],
                  "value": "MOVW{<c>}{<q>} <Rd>, #<imm16>// <imm16> can be represented in A1"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 1 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);   setflags = !InITBlock();    imm32 = ZeroExtend(imm8, 32);      carry = PSTATE.C;"
          ],
          "mask": "0x00002000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>{<q>} <Rd>, #<imm8>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<q>} <Rd>, #<imm8>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = (S == '1'); (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf04f0000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>.W <Rd>, #<const>// Inside IT block, and <Rd>, <const> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MOV variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS.W <Rd>, #<const>// Outside IT block, and <Rd>, <const> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MOVS variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 0 1 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = FALSE; imm32 = ZeroExtend(imm4:i:imm3:imm8, 32);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf2400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, #<imm16>// <imm16> cannot be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "MOVW{<c>}{<q>} <Rd>, #<imm16>// <imm16> can be represented in T1 or T2"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "108",
      "names": [
        "MOV",
        "MOVS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = imm32;",
          "    if d == 15 then          // Can only occur for encoding A1",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Move (immediate) writes an immediate value to the destination register.",
          "If the destination register is not the PC, the MOVS variant of the instruction updates the condition flags based on",
          "the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The MOV variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The MOVS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                deprecates using the PC as the destination register, but if the PC is used:",
          "                       For the MOV variant, the instruction is a branch to the address calculated by the operation.",
          "                        This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the MOVS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding A2, T1, T2 and T3: is the general-purpose destination register, encoded in the \"Rd\"",
          "                field.",
          "<imm8>          Is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "<imm16>         For encoding A2: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                \"imm4:imm12\" field.",
          "                For encoding T3: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                \"imm4:i:imm3:imm8\" field.",
          "<const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                page F4-2559 for the range of values.",
          "                For encoding T2: an immediate value. See Modified immediate constants in T32 instructions on",
          "                page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01a00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MOV, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MOVS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(D:Rd); m = UInt(Rm); setflags = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x00004600",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "!=11",
              "size": 2,
              "type": 4
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = TRUE;",
            "(shift_t, shift_n) = DecodeImmShift(op, imm5);",
            "if op == '00' && imm5 == '00000' && InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x00000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>{<q>} <Rd>, <Rm> {, <shift> #<amount>}// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<q>} <Rd>, <Rm> {, <shift> #<amount>}// Outside IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 (0)",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea4f0000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MOV, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>.W <Rd>, <Rm> {, <shift> #<amount>}// Inside IT block, and <Rd>, <Rm>, <shift>, <amount> can be"
                },
                {
                  "aliases": [],
                  "value": "represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MOVS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS.W <Rd>, <Rm> {, <shift> #<amount>}// Outside IT block, and <Rd>, <Rm>, <shift>, <amount> can be"
                },
                {
                  "aliases": [],
                  "value": "represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "109",
      "names": [
        "MOV",
        "MOVS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = shifted;",
          "    if d == 15 then",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Move (register) copies a value from a register to the destination register.",
          "If the destination register is not the PC, the MOVS variant of the instruction updates the condition flags based on",
          "the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. If the",
          "destination register is the PC:",
          "          The MOV variant of the instruction is a branch. In the T32 instruction set (encoding T1) this is a simple",
          "branch, and in the A32 instruction set it is an interworking branch, see Pseudocode description of operations",
          "on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The MOVS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "This instruction is used by the aliases ASRS (immediate), ASR (immediate), LSLS (immediate), LSL (immediate),",
          "LSRS (immediate), LSR (immediate), RORS (immediate), ROR (immediate), RRXS, and RRX. See the Alias",
          "conditions on page F7-2868 table for details of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "<c>         See Standard assembler syntax fields on page F2-2506.",
          "<q>         See Standard assembler syntax fields on page F2-2506.",
          "<Rd>        For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is",
          "            used:",
          "                   For the MOV variant, the instruction is a branch to the address calculated by the operation.",
          "                    This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                    general-purpose registers and the PC on page E1-2378.",
          "                   For the MOVS variant, the instruction performs an exception return, that restores PSTATE",
          "                    from SPSR_<current_mode>. ARM deprecates use of the instruction if <Rn> is not the LR,",
          "                    or if the optional shift or RRX argument is specified.",
          "            For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is",
          "            used:",
          "                   The instruction causes a branch to the address moved to the PC. This is a simple branch, see",
          "                    Pseudocode description of operations on the AArch32 general-purpose registers and the PC",
          "                    on page E1-2378.",
          "                   The instruction must either be outside an IT block or the last instruction of an IT block.",
          "            For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>        For encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field. The PC",
          "            can be used.",
          "            For encoding T2 and T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "     <shift>         For encoding A1 and T3: is the type of shift to be applied to the source register, encoded in the",
          "                     \"type\" field. It can have the following values:",
          "                     LSL          when type = 00",
          "                     LSR          when type = 01",
          "                     ASR          when type = 10",
          "                     ROR          when type = 11",
          "                     For encoding T2: is the type of shift to be applied to the source register, encoded in the \"op\" field.",
          "                     It can have the following values:",
          "                     LSL          when op = 00",
          "                     LSR          when op = 01",
          "                     ASR          when op = 10",
          "     <amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                     LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01a00010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 x x x",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); m = UInt(Rdn); s = UInt(Rs);",
            "setflags = !InITBlock(); shift_t = DecodeRegShift(op<2>:op<0>);"
          ],
          "mask": "0x00004000",
          "mnemonics": [
            {
              "constraint": " op = 0100.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>{<q>} <Rdm>, <Rdm>, ASR <Rs>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<q>} <Rdm>, <Rdm>, ASR <Rs>// Outside IT block"
                }
              ],
              "name": "Arithmetic shift right variant"
            },
            {
              "constraint": " op = 0010.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>{<q>} <Rdm>, <Rdm>, LSL <Rs>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<q>} <Rdm>, <Rdm>, LSL <Rs>// Outside IT block"
                }
              ],
              "name": "Logical shift left variant"
            },
            {
              "constraint": " op = 0011.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>{<q>} <Rdm>, <Rdm>, LSR <Rs>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<q>} <Rdm>, <Rdm>, LSR <Rs>// Outside IT block"
                }
              ],
              "name": "Logical shift right variant"
            },
            {
              "constraint": " op = 0111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>{<q>} <Rdm>, <Rdm>, ROR <Rs>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<q>} <Rdm>, <Rdm>, ROR <Rs>// Outside IT block"
                }
              ],
              "name": "Rotate right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0",
              "size": 9,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || m == 15 || s == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa00f000",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVS.W <Rd>, <Rm>, <type> <Rs>// Outside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MOVS{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOV<c>.W <Rd>, <Rm>, <type> <Rs>// Inside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MOV{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "110",
      "names": [
        "MOV",
        "MOVS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (result, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Move (register-shifted register) copies a register-shifted register value to the destination register. It can optionally",
          "update the condition flags based on the value.",
          "This instruction is used by the aliases ASRS (register), ASR (register), LSLS (register), LSL (register), LSRS",
          "(register), LSR (register), RORS (register), and ROR (register). See the Alias conditions on page F7-2873 table for",
          "details of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "<c>              See Standard assembler syntax fields on page F2-2506.",
          "<q>              See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>            Is the general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>             Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>             Is the general-purpose source register, encoded in the \"Rm\" field.",
          "     <type>          Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                     the following values:",
          "                     LSL          when type = 00",
          "                     LSR          when type = 01",
          "                     ASR          when type = 10",
          "                     ROR          when type = 11",
          "     <Rs>            Is the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\"",
          "                     field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); imm16 = imm4:imm12;",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x03400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVT{<c>}{<q>} <Rd>, #<imm16>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 1 1 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); imm16 = imm4:i:imm3:imm8;",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf2c00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MOVT{<c>}{<q>} <Rd>, #<imm16>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "111",
      "names": [
        "MOVT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    R[d]<31:16> = imm16;",
          "    // R[d]<15:0> unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Move Top writes an immediate value to the top halfword of the destination register. It does not affect the contents",
          "of the bottom halfword."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<imm16>            For encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                   \"imm4:imm12\" field.",
          "                   For encoding T1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                   \"imm4:i:imm3:imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); cp = UInt(coproc);",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0e100010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); cp = UInt(coproc);",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0e100010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRC2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); cp = UInt(coproc);",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xee100010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "opc1",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRn",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc2",
              "size": 3,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); cp = UInt(coproc);",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfe100010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRC2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "112",
      "names": [
        "MRC",
        "MRC2"
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          Coproc_CheckInstr(cp, ThisInstr());",
          "          value = Coproc_GetOneWord(cp, ThisInstr());",
          "          if t != 15 then",
          "              R[t] = value;",
          "          elsif Coproc_CanWriteAPSR(cp, ThisInstr()) then",
          "              PSTATE.<N,Z,C,V> = value<31:28>;",
          "    // value<27:0> are not used.",
          "else",
          "    PSTATE.<N,Z,C,V> = bits(4) UNKNOWN;"
        ]
      },
      "summary": {
        "lines": [
          "Move to general-purpose register from Coprocessor causes a conceptual coprocessor to transfer a value to a",
          "general-purpose register or to the condition flags.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the opc1, opc2, CRn, and CRd field",
          "values that are valid MRC and MRC2 instructions. Other encodings are UNDEFINED. For more information see",
          "Conceptual coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, MRC accesses to system control registers can be trapped to Hyp mode,",
          "meaning that an attempt to execute an MRC instruction in a Non-secure mode other than Hyp mode, that would be",
          "permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see EL2",
          "configurable controls on page G1-3909.",
          "Because of the range of possible traps to Hyp mode, the MRC pseudocode does not show these possible traps."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "                For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<coproc>        Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "                p11, p14, and p15.",
          "<opc1>          Is a coprocessor-specific opcode in the range 0 to 7, encoded in the \"opc1\" field.",
          "<Rt>            Is the general-purpose register to be transferred or APSR_nzcv (encoded as 0b1111), encoded in the",
          "                \"Rt\" field. If APSR_nzcv is used, bits [31:28] of the transferred value are written to the PSTATE",
          "                condition flags.",
          "<CRn>           Is the first coprocessor register, encoded in the \"CRn\" field.",
          "<CRm>           Is the second coprocessor register, encoded in the \"CRm\" field.",
          "<opc2>          Is a coprocessor-specific opcode in the range 0 to 7, defaulting to 0 and encoded in the \"opc2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 0 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0c500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 0 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0x0c500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRRC2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 0 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xec500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 0 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "opc1",
              "size": 4,
              "type": 0
            },
            {
              "name": "CRm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "if coproc == '101x' then UNDEFINED;",
            "t = UInt(Rt); t2 = UInt(Rt2); cp = UInt(coproc);",
            "if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfc500000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRRC2{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "113",
      "names": [
        "MRRC",
        "MRRC2"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    (R[t2], R[t]) = Coproc_GetTwoWords(cp, ThisInstr());"
        ]
      },
      "summary": {
        "lines": [
          "Move to two general-purpose registers from Coprocessor causes a conceptual coprocessor to transfer values to two",
          "general-purpose registers.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the opc1, and CRm field values that",
          "are valid MRRC and MRRC2 instructions. Other encodings are UNDEFINED. For more information see Conceptual",
          "coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, MRRC accesses to system control registers can be trapped to Hyp mode,",
          "meaning that an attempt to execute an MRRC instruction in a Non-secure mode other than Hyp mode, that would be",
          "permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see EL2",
          "configurable controls on page G1-3909.",
          "Because of the range of possible traps to Hyp mode, the MRRC pseudocode does not show these possible traps."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "               For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<coproc>       Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "               p11, p14, and p15.",
          "<opc1>         Is a coprocessor-specific opcode in the range 0 to 15, encoded in the \"opc1\" field.",
          "<Rt>           Is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rt2>          Is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "<CRm>          Is a coprocessor register, encoded in the \"CRm\" field.",
          "The relative significance of <Rt2> and {syntax{<Rt>} is IMPLEMENTATION DEFINED for IMPLEMENTATION DEFINED",
          "uses of the MCRR and MRRC instructions. For the architected uses, as described in this manual, <Rt2> transfers",
          "bits[63:32] of the selected coprocessor register, while <Rt> transfers bits[31:0]."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "0 0 (1) (1) (1) (1)",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 0 (0) 0 0 0 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); read_spsr = (R == '1');",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x010f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRS{<c>}{<q>} <Rd>, <spec_reg>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 (0) 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 0 (0) (0) (0) (0) (0)",
              "size": 8,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); read_spsr = (R == '1');",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3ef8000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRS{<c>}{<q>} <Rd>, <spec_reg>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "114",
      "names": [
        "MRS",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if read_spsr then",
          "        if PSTATE.M IN {M32_User,M32_System} then",
          "            UNPREDICTABLE;",
          "        else",
          "            R[d] = SPSR[];",
          "    else",
          "        // CPSR has same bit assignments as SPSR, but with the IT, J, SS, IL, and T bits masked out.",
          "        psr_val = GetPSRFromPSTATE() AND '11111000 00001111 00000011 11011111';",
          "        if PSTATE.EL == EL0 then",
          "            // If accessed from User mode return UNKNOWN values for E, A, I, F bits, bits<9:6>,",
          "            // and for the M field, bits<4:0>",
          "            psr_val<9:6> = bits(4) UNKNOWN;",
          "            psr_val<4:0> = bits(5) UNKNOWN;",
          "        R[d] = psr_val;"
        ]
      },
      "summary": {
        "lines": [
          "Move Special register to general-purpose register moves the value of the The Application Program Status Register,",
          "APSR on page E1-2382, CPSR, or SPSR_<current_mode> into a general-purpose register.",
          "ARM recommends the APSR form when only the N, Z, C, V, Q, and GE[3:0] bits are being written. For more",
          "information, see The Application Program Status Register, APSR on page E1-2382.",
          "An MRS that accesses the SPSR is UNPREDICTABLE if executed in User mode or System mode.",
          "An MRS that is executed in User mode and accesses the CPSR returns an UNKNOWN value for the CPSR.{E, A, I, F,",
          "M} fields."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<spec_reg>         Is the special register to be accessed, encoded in the \"R\" field. It can have the following values:",
          "                   CPSR|APSR when R = 0",
          "                   SPSR        when R = 1"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "M1",
              "size": 4,
              "type": 3
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0 0 0 (0) (0) (0) (0)",
              "size": 8,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); read_spsr = (R == '1');",
            "if d == 15 then UNPREDICTABLE;",
            "SYSm = M:M1;"
          ],
          "mask": "0x01000200",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRS{<c>}{<q>} <Rd>, <banked_reg>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "M1",
              "size": 4,
              "type": 3
            },
            {
              "name": "1 0 (0) 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            }
          ],
          "decode": [
            "d = UInt(Rd); read_spsr = (R == '1');",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "SYSm = M:M1;"
          ],
          "mask": "0xf3e08020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MRS{<c>}{<q>} <Rd>, <banked_reg>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "115",
      "names": [
        "MRS",
        "(Banked register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL0 then",
          "       UNPREDICTABLE;",
          "    else",
          "        mode = PSTATE.M;",
          "        if read_spsr then",
          "            SPSRaccessValid(SYSm, mode);           // Check for UNPREDICTABLE cases",
          "            case SYSm of",
          "                when '01110' R[d] = SPSR_fiq;",
          "                when '10000' R[d] = SPSR_irq;",
          "                when '10010' R[d] = SPSR_svc;",
          "                when '10100' R[d] = SPSR_abt;",
          "                when '10110' R[d] = SPSR_und;",
          "                when '11100'",
          "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
          "                    R[d] = SPSR_mon;",
          "                when '11110' R[d] = SPSR_hyp;",
          "        else",
          "            BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases",
          "            case SYSm of",
          "                when '00xxx'                       // Access the User mode registers",
          "                    m = UInt(SYSm<2:0>) + 8;",
          "                    R[d] = Rmode[m,M32_User];",
          "                when '01xxx'                       // Access the FIQ mode registers",
          "                    m = UInt(SYSm<2:0>) + 8;",
          "                    R[d] = Rmode[m,M32_FIQ];",
          "                when '1000x'                       // Access the IRQ mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    R[d] = Rmode[m,M32_IRQ];",
          "                when '1001x'                       // Access the Supervisor mode regsiters",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    R[d] = Rmode[m,M32_Svc];",
          "                when '1010x'                       // Access the Abort mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    R[d] = Rmode[m,M32_Abort];",
          "                when '1011x'                       // Access the Undefined mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    R[d] = Rmode[m,M32_Undef];",
          "                when '1110x'                       // Access Monitor registers",
          "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    R[d] = Rmode[m,M32_Monitor];",
          "                when '11110'                       // Access ELR_hyp register",
          "                    R[d] = ELR_hyp;",
          "                when '11111'                       // Access SP_hyp register",
          "                    R[d] = Rmode[13,M32_Hyp];"
        ]
      },
      "summary": {
        "lines": [
          "Move to Register from Banked or Special register moves the value from the Banked general-purpose register or",
          "SPSR of the specified mode, or the value of ELR_hyp on page G1-3817, to a general-purpose register.",
          "MRS (Banked register) is UNPREDICTABLE if executed in User mode.",
          "The effect of using an MRS (Banked register) instruction with a register argument that is not valid for the current mode",
          "is UNPREDICTABLE. For more information see Usage restrictions on the Banked register transfer instructions on",
          "page F7-3256."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "     <banked_reg>       Is the name of the banked register to be transferred to or from, encoded in the \"R:M:M1\" field. It",
          "                        can have the following values:",
          "                        R8_usr                  when R = 0, M = 0, M1 = 0000",
          "R9_usr                when R = 0, M = 0, M1 = 0001",
          "R10_usr               when R = 0, M = 0, M1 = 0010",
          "R11_usr               when R = 0, M = 0, M1 = 0011",
          "R12_usr               when R = 0, M = 0, M1 = 0100",
          "SP_usr                when R = 0, M = 0, M1 = 0101",
          "LR_usr                when R = 0, M = 0, M1 = 0110",
          "UNPREDICTABLE         when R = 0, M = 0, M1 = 0111",
          "R8_fiq                when R = 0, M = 0, M1 = 1000",
          "R9_fiq                when R = 0, M = 0, M1 = 1001",
          "R10_fiq               when R = 0, M = 0, M1 = 1010",
          "R11_fiq               when R = 0, M = 0, M1 = 1011",
          "R12_fiq               when R = 0, M = 0, M1 = 1100",
          "SP_fiq                when R = 0, M = 0, M1 = 1101",
          "LR_fiq                when R = 0, M = 0, M1 = 1110",
          "UNPREDICTABLE         when R = 0, M = 0, M1 = 1111",
          "LR_irq                when R = 0, M = 1, M1 = 0000",
          "SP_irq                when R = 0, M = 1, M1 = 0001",
          "LR_svc                when R = 0, M = 1, M1 = 0010",
          "SP_svc                when R = 0, M = 1, M1 = 0011",
          "LR_abt                when R = 0, M = 1, M1 = 0100",
          "SP_abt                when R = 0, M = 1, M1 = 0101",
          "LR_und                when R = 0, M = 1, M1 = 0110",
          "SP_und                when R = 0, M = 1, M1 = 0111",
          "UNPREDICTABLE         when R = 0, M = 1, M1 = 10xx",
          "LR_mon                when R = 0, M = 1, M1 = 1100",
          "SP_mon                when R = 0, M = 1, M1 = 1101",
          "ELR_hyp               when R = 0, M = 1, M1 = 1110",
          "SP_hyp                when R = 0, M = 1, M1 = 1111",
          "UNPREDICTABLE         when R = 1, M = 0, M1 = 0xxx",
          "UNPREDICTABLE         when R = 1, M = 0, M1 = 10xx",
          "UNPREDICTABLE         when R = 1, M = 0, M1 = 110x",
          "SPSR_fiq              when R = 1, M = 0, M1 = 1110",
          "UNPREDICTABLE         when R = 1, M = 0, M1 = 1111",
          "SPSR_irq              when R = 1, M = 1, M1 = 0000",
          "UNPREDICTABLE         when R = 1, M = 1, M1 = 0001",
          "SPSR_svc              when R = 1, M = 1, M1 = 0010",
          "UNPREDICTABLE         when R = 1, M = 1, M1 = 0011",
          "SPSR_abt              when R = 1, M = 1, M1 = 0100",
          "UNPREDICTABLE         when R = 1, M = 1, M1 = 0101",
          "SPSR_und              when R = 1, M = 1, M1 = 0110",
          "UNPREDICTABLE         when R = 1, M = 1, M1 = 0111",
          "UNPREDICTABLE         when R = 1, M = 1, M1 = 10xx",
          "SPSR_mon              when R = 1, M = 1, M1 = 1100",
          "UNPREDICTABLE         when R = 1, M = 1, M1 = 1101",
          "                     SPSR_hyp                 when R = 1, M = 1, M1 = 1110",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 1111"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "M1",
              "size": 4,
              "type": 3
            },
            {
              "name": "(1) (1) (1) (1) (0) (0) 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); write_spsr = (R == '1');",
            "if n == 15 then UNPREDICTABLE;",
            "SYSm = M:M1;"
          ],
          "mask": "0x0120f200",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <banked_reg>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 (0) 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "M1",
              "size": 4,
              "type": 3
            },
            {
              "name": "(0) (0) 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            }
          ],
          "decode": [
            "n = UInt(Rn); write_spsr = (R == '1');",
            "if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "SYSm = M:M1;"
          ],
          "mask": "0xf3808020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <banked_reg>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "116",
      "names": [
        "MSR",
        "(Banked register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL0 then",
          "        UNPREDICTABLE;",
          "    else",
          "        mode = PSTATE.M;",
          "        if write_spsr then",
          "            SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases",
          "            case SYSm of",
          "                when '01110' SPSR_fiq = R[n];",
          "                when '10000' SPSR_irq = R[n];",
          "                when '10010' SPSR_svc = R[n];",
          "                when '10100' SPSR_abt = R[n];",
          "                when '10110' SPSR_und = R[n];",
          "                when '11100'",
          "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
          "                    SPSR_mon = R[n];",
          "                when '11110' SPSR_hyp = R[n];",
          "        else",
          "            BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases",
          "            case SYSm of",
          "                when '00xxx'                       // Access the User mode registers",
          "                    m = UInt(SYSm<2:0>) + 8;",
          "                    Rmode[m,M32_User] = R[n];",
          "                when '01xxx'                       // Access the FIQ mode registers",
          "                    m = UInt(SYSm<2:0>) + 8;",
          "                    Rmode[m,M32_FIQ] = R[n];",
          "                when '1000x'                       // Access the IRQ mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_IRQ] = R[n];",
          "                when '1001x'                       // Access the Supervisor mode regsiters",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Svc] = R[n];",
          "                when '1010x'                       // Access the Abort mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Abort] = R[n];",
          "                when '1011x'                       // Access the Undefined mode registers",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Undef] = R[n];",
          "                when '1110x'                       // Access Monitor registers",
          "                    if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();",
          "                    m = 14 - UInt(SYSm<0>);        // LR when SYSm<0> == 0, otherwise SP",
          "                    Rmode[m,M32_Monitor] = R[n];",
          "                when '11110'                       // Access ELR_hyp register",
          "                    ELR_hyp = R[n];",
          "                when '11111'                       // Access SP_hyp register",
          "                    Rmode[13,M32_Hyp] = R[n];"
        ]
      },
      "summary": {
        "lines": [
          "Move to Banked or Special register from general-purpose register moves the value of a general-purpose register to",
          "the Banked general-purpose register or SPSR of the specified mode, or to ELR_hyp on page G1-3817.",
          "MSR (Banked register) is UNPREDICTABLE if executed in User mode.",
          "The effect of using an MSR (Banked register) instruction with a register argument that is not valid for the current mode",
          "is UNPREDICTABLE. For more information see Usage restrictions on the Banked register transfer instructions on",
          "page F7-3256."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<banked_reg>       Is the name of the banked register to be transferred to or from, encoded in the \"R:M:M1\" field. It",
          "                   can have the following values:",
          "                   R8_usr                 when R = 0, M = 0, M1 = 0000",
          "                   R9_usr                 when R = 0, M = 0, M1 = 0001",
          "                     R10_usr                  when R = 0, M = 0, M1 = 0010",
          "                     R11_usr                  when R = 0, M = 0, M1 = 0011",
          "                     R12_usr                  when R = 0, M = 0, M1 = 0100",
          "                     SP_usr                   when R = 0, M = 0, M1 = 0101",
          "                     LR_usr                   when R = 0, M = 0, M1 = 0110",
          "                     UNPREDICTABLE            when R = 0, M = 0, M1 = 0111",
          "                     R8_fiq                   when R = 0, M = 0, M1 = 1000",
          "                     R9_fiq                   when R = 0, M = 0, M1 = 1001",
          "                     R10_fiq                  when R = 0, M = 0, M1 = 1010",
          "                     R11_fiq                  when R = 0, M = 0, M1 = 1011",
          "                     R12_fiq                  when R = 0, M = 0, M1 = 1100",
          "                     SP_fiq                   when R = 0, M = 0, M1 = 1101",
          "                     LR_fiq                   when R = 0, M = 0, M1 = 1110",
          "                     UNPREDICTABLE            when R = 0, M = 0, M1 = 1111",
          "                     LR_irq                   when R = 0, M = 1, M1 = 0000",
          "                     SP_irq                   when R = 0, M = 1, M1 = 0001",
          "                     LR_svc                   when R = 0, M = 1, M1 = 0010",
          "                     SP_svc                   when R = 0, M = 1, M1 = 0011",
          "                     LR_abt                   when R = 0, M = 1, M1 = 0100",
          "                     SP_abt                   when R = 0, M = 1, M1 = 0101",
          "                     LR_und                   when R = 0, M = 1, M1 = 0110",
          "                     SP_und                   when R = 0, M = 1, M1 = 0111",
          "                     UNPREDICTABLE            when R = 0, M = 1, M1 = 10xx",
          "                     LR_mon                   when R = 0, M = 1, M1 = 1100",
          "                     SP_mon                   when R = 0, M = 1, M1 = 1101",
          "                     ELR_hyp                  when R = 0, M = 1, M1 = 1110",
          "                     SP_hyp                   when R = 0, M = 1, M1 = 1111",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 0xxx",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 10xx",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 110x",
          "                     SPSR_fiq                 when R = 1, M = 0, M1 = 1110",
          "                     UNPREDICTABLE            when R = 1, M = 0, M1 = 1111",
          "                     SPSR_irq                 when R = 1, M = 1, M1 = 0000",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0001",
          "                     SPSR_svc                 when R = 1, M = 1, M1 = 0010",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0011",
          "                     SPSR_abt                 when R = 1, M = 1, M1 = 0100",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0101",
          "                     SPSR_und                 when R = 1, M = 1, M1 = 0110",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 0111",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 10xx",
          "                     SPSR_mon                 when R = 1, M = 1, M1 = 1100",
          "                     UNPREDICTABLE            when R = 1, M = 1, M1 = 1101",
          "                     SPSR_hyp                 when R = 1, M = 1, M1 = 1110",
          "             UNPREDICTABLE           when R = 1, M = 1, M1 = 1111",
          "<Rn>         Is the general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "mask",
              "size": 4,
              "type": 0
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if mask == '0000' && R == '0' then SEE \"Related encodings\";",
            "imm32 = A32ExpandImm(imm12); write_spsr = (R == '1');",
            "if mask == '0000' then UNPREDICTABLE;"
          ],
          "mask": "0x0320f000",
          "mnemonics": [
            {
              "constraint": " !(R == 0 && mask == 0000).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <spec_reg>, #<imm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "117",
      "names": [
        "MSR",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if write_spsr then",
          "        if PSTATE.M IN {M32_User,M32_System} then",
          "            UNPREDICTABLE;",
          "        else",
          "            SPSRWriteByInstr(imm32, mask);",
          "    else",
          "        // Attempts to change to an illegal mode will invoke the Illegal Execution State mechanism",
          "        CPSRWriteByInstr(imm32, mask);"
        ]
      },
      "summary": {
        "lines": [
          "Move immediate value to Special register moves selected bits of an immediate value to the corresponding bits in",
          "the The Application Program Status Register, APSR on page E1-2382, CPSR, or SPSR_<current_mode>.",
          "Because of the Do-Not-Modify nature of its reserved bits, the immediate form of MSR is normally only useful at the",
          "Application level for writing to APSR_nzcvq (CPSR_f).",
          "If an MSR (immediate) moves selected bits of an immediate value to the CPSR, the PE checks whether the value being",
          "written to PSTATE.M is legal. See Illegal changes to PSTATE.M on page G1-3822.",
          "An MSR (immediate) executed in User mode:",
          "          Is CONSTRAINED UNPREDICTABLE if it attempts to update the SPSR.",
          "          Otherwise, does not update any CPSR field that is accessible only at EL1 or higher,",
          "An MSR (immediate) executed in System mode is CONSTRAINED UNPREDICTABLE if it attempts to update the SPSR.",
          "The CPSR.E bit is writable from any mode using an MSR instruction. ARM deprecates using this to change its value."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                   See Standard assembler syntax fields on page F2-2506.",
          "     <q>                   See Standard assembler syntax fields on page F2-2506.",
          "     <spec_reg>            Is one of:",
          "                                  APSR_<bits>.",
          "                                  CPSR_<fields>.",
          "                                  SPSR_<fields>.",
          "                            For CPSR and SPSR, <fields> is a sequence of one or more of the following:",
          "                           c            mask<0> = '1' to enable writing of bits<7:0> of the destination PSR.",
          "                           x            mask<1> = '1' to enable writing of bits<15:8> of the destination PSR.",
          "                           s            mask<2> = '1' to enable writing of bits<23:16> of the destination PSR.",
          "             f            mask<3> = '1' to enable writing of bits<31:24> of the destination PSR.",
          "              For APSR, <bits> is one of nzcvq, g, or nzcvqg. These map to the following CPSR_<fields> values:",
          "                    APSR_nzcvq is the same as CPSR_f (mask== '1000').",
          "                    APSR_g is the same as CPSR_s (mask == '0100').",
          "                    APSR_nzcvqg is the same as CPSR_fs (mask == '1100').",
          "             ARM recommends the APSR_<bits> forms when only the N, Z, C, V, Q, and GE[3:0] bits are being",
          "             written. For more information, see The Application Program Status Register, APSR on",
          "             page E1-2382.",
          "<imm>        Is an immediate value. See Modified immediate constants in A32 instructions on page F4-2559 for",
          "             the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "mask",
              "size": 4,
              "type": 0
            },
            {
              "name": "(1) (1) (1) (1) (0) (0) 0 (0) 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); write_spsr = (R == '1');",
            "if mask == '0000' then UNPREDICTABLE;",
            "if n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0120f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <spec_reg>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 (0) 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "mask",
              "size": 4,
              "type": 0
            },
            {
              "name": "(0) (0) 0 (0) (0) (0) (0) (0)",
              "size": 8,
              "type": 5
            }
          ],
          "decode": [
            "n = UInt(Rn); write_spsr = (R == '1');",
            "if mask == '0000' then UNPREDICTABLE;",
            "if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3808000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MSR{<c>}{<q>} <spec_reg>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "118",
      "names": [
        "MSR",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if write_spsr then",
          "        if PSTATE.M IN {M32_User,M32_System} then",
          "            UNPREDICTABLE;",
          "        else",
          "            SPSRWriteByInstr(R[n], mask);",
          "    else",
          "        // Attempts to change to an illegal mode will invoke the Illegal Execution State mechanism",
          "        CPSRWriteByInstr(R[n], mask);"
        ]
      },
      "summary": {
        "lines": [
          "Move general-purpose register to Special register moves selected bits of a general-purpose register to the The",
          "Application Program Status Register, APSR on page E1-2382, CPSR or SPSR_<current_mode>.",
          "Because of the Do-Not-Modify nature of its reserved bits, a read-modify-write sequence is normally required when",
          "the MSR instruction is being used at Application level and its destination is not APSR_nzcvq (CPSR_f).",
          "If an MSR (register) moves selected bits of an immediate value to the CPSR, the PE checks whether the value being",
          "written to PSTATE.M is legal. See Illegal changes to PSTATE.M on page G1-3822.",
          "An MSR (register) executed in User mode:",
          "          Is UNPREDICTABLE if it attempts to update the SPSR.",
          "          Otherwise, does not update any CPSR field that is accessible only at EL1 or higher.",
          "An MSR (register) executed in System mode is UNPREDICTABLE if it attempts to update the SPSR.",
          "The CPSR.E bit is writable from any mode using an MSR instruction. ARM deprecates using this to change its value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<spec_reg>   Is one of:",
          "                    APSR_<bits>.",
          "                    CPSR_<fields>.",
          "                    SPSR_<fields>.",
          "              For CPSR and SPSR, <fields> is a sequence of one or more of the following:",
          "             c            mask<0> = '1' to enable writing of bits<7:0> of the destination PSR.",
          "             x            mask<1> = '1' to enable writing of bits<15:8> of the destination PSR.",
          "             s            mask<2> = '1' to enable writing of bits<23:16> of the destination PSR.",
          "             f            mask<3> = '1' to enable writing of bits<31:24> of the destination PSR.",
          "              For APSR, <bits> is one of nzcvq, g, or nzcvqg. These map to the following CPSR_<fields> values:",
          "                    APSR_nzcvq is the same as CPSR_f (mask== '1000').",
          "                    APSR_g is the same as CPSR_s (mask == '0100').",
          "                    APSR_nzcvqg is the same as CPSR_fs (mask == '1100').",
          "             ARM recommends the APSR_<bits> forms when only the N, Z, C, V, Q, and GE[3:0] bits are being",
          "             written. For more information, see The Application Program Status Register, APSR on",
          "             page E1-2382.",
          "<Rn>         Is the general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00000090",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MULS{<c>}{<q>} <Rd>, <Rn>{, <Rm>}"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MUL{<c>}{<q>} <Rd>, <Rn>{, <Rm>}"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 1 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdm);       n = UInt(Rn);   m = UInt(Rdm);        setflags = !InITBlock();"
          ],
          "mask": "0x00004340",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MUL<c>{<q>} <Rdm>, <Rn>{, <Rdm>}// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MULS{<q>} <Rdm>, <Rn>{, <Rdm>}// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb00f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MUL<c>.W <Rd>, <Rn>{, <Rm>}// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MUL{<c>}{<q>} <Rd>, <Rn>{, <Rm>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "119",
      "names": [
        "MUL",
        "MULS"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand1 = SInt(R[n]); // operand1 = UInt(R[n]) produces the same final results",
          "    operand2 = SInt(R[m]); // operand2 = UInt(R[m]) produces the same final results",
          "    result = operand1 * operand2;",
          "    R[d] = result<31:0>;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result<31:0>);",
          "        // PSTATE.C, PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Multiply multiplies two register values. The least significant 32 bits of the result are written to the destination",
          "register. These 32 bits do not depend on whether the source register values are considered to be signed values or",
          "unsigned values.",
          "Optionally, it can update the condition flags based on the result. In the T32 instruction set, this option is limited to",
          "only a few forms of the instruction. Use of this option adversely affects performance on many implementations."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>         Is the second general-purpose source register holding the multiplier and the destination register,",
          "              encoded in the \"Rdm\" field.",
          "<Rd>          Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>          Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field. If",
          "              omitted, <Rd> is used."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = (S == '1');",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x03e00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MVN variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MVNS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = (S == '1');",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf06f0000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MVN variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, #<const>"
                }
              ],
              "name": "MVNS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "120",
      "names": [
        "MVN",
        "MVNS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = NOT(imm32);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise NOT (immediate) writes the bitwise inverse of an immediate value to the destination register.",
          "If the destination register is not the PC, the MVNS variant of the instruction updates the condition flags based on",
          "the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The MVN variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The MVNS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "              deprecates using the PC as the destination register, but if the PC is used:",
          "                     For the MVN variant, the instruction is a branch to the address calculated by the operation.",
          "                      This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the MVNS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>.",
          "              For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<const>       For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "              page F4-2559 for the range of values.",
          "              For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "              page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01e00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MVN, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MVN, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MVNS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MVNS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 1 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x000043c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN<c>{<q>} <Rd>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "MVNS{<q>} <Rd>, <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 (0)",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea6f0000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MVN, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN<c>.W <Rd>, <Rm>// Inside IT block, and <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MVN, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, <Rm>, RRX"
                }
              ],
              "name": "MVNS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS.W <Rd>, <Rm>// Outside IT block, and <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "MVNS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "121",
      "names": [
        "MVN",
        "MVNS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = NOT(shifted);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise NOT (register) writes the bitwise inverse of a register value to the destination register.",
          "If the destination register is not the PC, the MVNS variant of the instruction updates the condition flags based on",
          "the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The MVN variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The MVNS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                     deprecates using the PC as the destination register, but if the PC is used:",
          "                            For the MVN variant, the instruction is a branch to the address calculated by the operation.",
          "                             This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                             general-purpose registers and the PC on page E1-2378.",
          "                            For the MVNS variant, the instruction performs an exception return, that restores PSTATE",
          "                             from SPSR_<current_mode>.",
          "                     For encoding T1 and T2: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "     <Rm>            For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                     used.",
          "                     For encoding T1 and T2: is the general-purpose source register, encoded in the \"Rm\" field.",
          "     <shift>         Is the type of shift to be applied to the source register, encoded in the \"type\" field. It can have the",
          "                     following values:",
          "                     LSL          when type = 00",
          "                     LSR          when type = 01",
          "                     ASR          when type = 10",
          "                     ROR          when type = 11",
          "     <amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                     LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01e00010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVNS{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "MVN{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "122",
      "names": [
        "MVN",
        "MVNS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "          result = NOT(shifted);",
          "          R[d] = result;",
          "          if setflags then",
          "              PSTATE.N = result<31>;",
          "              PSTATE.Z = IsZeroBit(result);",
          "              PSTATE.C = carry;",
          "              // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise NOT (register-shifted register) writes the bitwise inverse of a register-shifted register value to the",
          "destination register. It can optionally update the condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               Is the general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\"",
          "                   field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 0 0",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0320f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "NOP{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0000bf00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "NOP{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 0 0",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3af8000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "NOP{<c>}.W"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "123",
      "names": [
        "NOP",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    // Do nothing"
        ]
      },
      "summary": {
        "lines": [
          "No Operation does nothing. This instruction can be used for instruction alignment purposes.",
          "Note",
          "The timing effects of including a NOP instruction in a program are not guaranteed. It can increase execution time,",
          "leave it unchanged, or even reduce it. Therefore, NOP instructions are not suitable for timing loops."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE MVN (immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0600000",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORNS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORN{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "124",
      "names": [
        "ORN",
        "ORNS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] OR NOT(imm32);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise OR NOT (immediate) performs a bitwise (inclusive) OR of a register value and the complement of an",
          "immediate value, and writes the result to the destination register. It can optionally update the condition flags based",
          "on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            Is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the",
          "                same as <Rn>.",
          "<Rn>            Is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>         An immediate value. See Modified immediate constants in T32 instructions on page F3-2530 for the",
          "                range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE MVN (register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea600000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORN{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ORN, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORN{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ORN, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORNS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ORNS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORNS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ORNS, shift or rotate by value variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "125",
      "names": [
        "ORN",
        "ORNS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] OR NOT(shifted);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise OR NOT (register) performs a bitwise (inclusive) OR of a register value and the complement of an",
          "optionally-shifted register value, and writes the result to the destination register. It can optionally update the",
          "condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>            Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "     <Rn>            Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "     <Rm>            Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>      Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "             the following values:",
          "             LSL         when type = 00",
          "             LSR         when type = 01",
          "             ASR         when type = 10",
          "             ROR         when type = 11",
          "<amount>     Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "             LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x03800000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ORR variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ORRS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE MOV (immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0400000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ORR variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "ORRS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "126",
      "names": [
        "ORR",
        "ORRS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] OR imm32;",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.N = result<31>;",
          "            PSTATE.Z = IsZeroBit(result);",
          "            PSTATE.C = carry;",
          "            // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and an immediate value, and writes",
          "the result to the destination register.",
          "If the destination register is not the PC, the ORRS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The ORR variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The ORRS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "              PC is used:",
          "                     For the ORR variant, the instruction is a branch to the address calculated by the operation.",
          "                      This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the ORRS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>.",
          "              For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>.",
          "<Rn>          For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>       For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "              page F4-2559 for the range of values.",
          "              For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "              page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01800000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ORR, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ORR, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ORRS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ORRS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 1 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);            setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004300",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "ORRS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE \"Related encodings\";",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea400000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ORR, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ORR, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "ORRS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "ORRS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "127",
      "names": [
        "ORR",
        "ORRS (register)"
      ],
      "operation": {
        "lines": [
          "         if ConditionPassed() then",
          "             EncodingSpecificOperations();",
          "             (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "             result = R[n] OR shifted;",
          "             if d == 15 then          // Can only occur for A32 encoding",
          "                 if setflags then",
          "                     ALUExceptionReturn(result);",
          "                 else",
          "                     ALUWritePC(result);",
          "             else",
          "                 R[d] = result;",
          "                 if setflags then",
          "PSTATE.N = result<31>;",
          "PSTATE.Z = IsZeroBit(result);",
          "PSTATE.C = carry;",
          "// PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise OR (register) performs a bitwise (inclusive) OR of a register value and an optionally-shifted register value,",
          "and writes the result to the destination register.",
          "If the destination register is not the PC, the ORRS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The ORR variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The ORRS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>               See Standard assembler syntax fields on page F2-2506.",
          "<q>               See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>             Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>              For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                  PC is used:",
          "                         For the ORR variant, the instruction is a branch to the address calculated by the operation.",
          "                          This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                          general-purpose registers and the PC on page E1-2378.",
          "                         For the ORRS variant, the instruction performs an exception return, that restores PSTATE",
          "                          from SPSR_<current_mode>.",
          "                  For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                  this register is the same as <Rn>.",
          "<Rn>              For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                  be used.",
          "                  For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>              For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                  can be used.",
          "                  For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>           Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                  the following values:",
          "                  LSL          when type = 00",
          "                  LSR          when type = 01",
          "                  ASR          when type = 10",
          "                  ROR          when type = 11",
          "<amount>          Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                  LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "In T32 assembly:",
          "        Outside an IT block, if ORRS <Rd>, <Rn>, <Rd> is written with <Rd> and <Rn> both in the range R0-R7, it is",
          "         assembled using encoding T1 as though ORRS <Rd>, <Rn> had been written.",
          "        Inside an IT block, if ORR<c> <Rd>, <Rn>, <Rd> is written with <Rd> and <Rn> both in the range R0-R7, it is",
          "         assembled using encoding T1 as though ORR<c> <Rd>, <Rn> had been written.",
          "To prevent either of these happening, use the .W qualifier."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01800010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "128",
      "names": [
        "ORR",
        "ORRS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] OR shifted;",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.N = result<31>;",
          "        PSTATE.Z = IsZeroBit(result);",
          "        PSTATE.C = carry;",
          "        // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Bitwise OR (register-shifted register) performs a bitwise (inclusive) OR of a register value and a register-shifted",
          "register value, and writes the result to the destination register. It can optionally update the condition flags based on",
          "the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the general-purpose source register holding a shift amount in its bottom 8 bits, encoded in the \"Rs\"",
          "                   field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "tb",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); tbform = (tb == '1');",
            "(shift_t, shift_n) = DecodeImmShift(tb:'0', imm5);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06800010",
          "mnemonics": [
            {
              "constraint": " tb = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>}"
                }
              ],
              "name": "PKHBT variant"
            },
            {
              "constraint": " tb = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>}"
                }
              ],
              "name": "PKHTB variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "tb",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if S == '1' || T == '1' then UNDEFINED;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); tbform = (tb == '1');",
            "(shift_t, shift_n) = DecodeImmShift(tb:'0', imm3:imm2);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeac00000",
          "mnemonics": [
            {
              "constraint": " tb = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>}// tbform == FALSE"
                }
              ],
              "name": "PKHBT variant"
            },
            {
              "constraint": " tb = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>}// tbform == TRUE"
                }
              ],
              "name": "PKHTB variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "129",
      "names": [
        "PKHBT",
        "PKHTB"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = Shift(R[m], shift_t, shift_n, PSTATE.C); // PSTATE.C ignored",
          "    R[d]<15:0> = if tbform then operand2<15:0> else R[n]<15:0>;",
          "    R[d]<31:16> = if tbform then R[n]<31:16>    else operand2<31:16>;"
        ]
      },
      "summary": {
        "lines": [
          "Pack Halfword combines one halfword of its first operand with the other halfword of its shifted second operand."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>        For encoding A1: the shift to apply to the value read from <Rm>, encoded in imm5. Is one of:",
          "             omitted      No shift, encoded as 0b00000.",
          "             1-31         Left shift by specified number of bits, encoded as a binary number.",
          "             For encoding A1: the shift to apply to the value read from <Rm>, encoded in imm5. Is one of:",
          "             omitted      Instruction is a pseudo-instruction and is assembled as though PKHBT{<c>}{<q>} <Rd>,",
          "                          <Rm>, <Rn> had been written.",
          "             1-32         Arithmetic right shift by specified number of bits. A shift by 32 bits is encoded as",
          "                          0b00000. Other shift amounts are encoded as binary numbers.",
          "                       Note",
          "             An assembler can permit <imm> = 0 to mean the same thing as omitting the shift, but this is not",
          "             standard UAL and must not be used for disassembly.",
          "             For encoding T1: the shift to apply to the value read from <Rm>, encoded in imm3:imm2. For PKHBT,",
          "             it is one of:",
          "             omitted      No shift, encoded as 0b00000.",
          "             1-31         Left shift by specified number of bits, encoded as a binary number.",
          "              For PKHTB, it is one of:",
          "             omitted      Instruction is a pseudo-instruction and is assembled as though PKHBT{<c>}{<q>} <Rd>,",
          "                          <Rm>, <Rn> had been written.",
          "             1-32         Arithmetic right shift by specified number of bits. A shift by 32 bits is encoded as",
          "                          0b00000. Other shift amounts are encoded as binary numbers.",
          "                       Note",
          "             An assembler can permit <imm> = 0 to mean the same thing as omitting the shift, but this is not",
          "             standard UAL and must not be used for disassembly."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE PLD (literal);",
            "n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);           add = (U == '1');       is_pldw = (R == '0');"
          ],
          "mask": "0xf510f000",
          "mnemonics": [
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Preload read variant"
            },
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLDW{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Preload write variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE PLD (literal);",
            "n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);           add = TRUE;       is_pldw = (W == '1');"
          ],
          "mask": "0xf890f000",
          "mnemonics": [
            {
              "constraint": " W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "Preload read variant"
            },
            {
              "constraint": " W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLDW{<c>}{<q>} [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "Preload write variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1 1 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE PLD (literal);",
            "n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);       add = FALSE;     is_pldw = (W == '1');"
          ],
          "mask": "0xf810fc00",
          "mnemonics": [
            {
              "constraint": " W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Preload read variant"
            },
            {
              "constraint": " W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLDW{<c>}{<q>} [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Preload write variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "130",
      "names": [
        "PLD",
        "PLDW (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = if add then (R[n] + imm32) else (R[n] - imm32);",
          "    if is_pldw then",
          "        Hint_PreloadDataForWrite(address);",
          "    else",
          "        Hint_PreloadData(address);"
        ]
      },
      "summary": {
        "lines": [
          "Preload Data (immediate) signals the memory system that data memory accesses from a specified address are likely",
          "in the near future. The memory system can respond by taking actions that are expected to speed up the memory",
          "accesses when they do occur, such as preloading the cache line containing the specified address into the data cache.",
          "The PLD instruction signals that the likely memory access is a read, and the PLDW instruction signals that it is a write.",
          "The effect of a PLD or PLDW instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches",
          "on page E2-2425."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "              For encoding T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          Is the general-purpose base register, encoded in the \"Rn\" field. If the PC is used, see PLD (literal).",
          "+/-           Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "              encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "+             Specifies the offset is added to the base register.",
          "<imm>         For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "              defaulting to 0 and encoded in the \"imm12\" field.",
          "              For encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "              defaulting to 0 and encoded in the \"imm12\" field.",
          "              For encoding T2: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "              defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "(1) 0 1 1 1 1 1 (1) (1) (1) (1)",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm12, 32);      add = (U == '1');"
          ],
          "mask": "0xf55ff000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 1 1 1 1 1 1 1",
              "size": 9,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm12, 32);      add = (U == '1');"
          ],
          "mask": "0xf81ff000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "131",
      "names": [
        "PLD",
        "(literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);",
          "    Hint_PreloadData(address);"
        ]
      },
      "summary": {
        "lines": [
          "Preload Data (literal) signals the memory system that data memory accesses from a specified address are likely in",
          "the near future. The memory system can respond by taking actions that are expected to speed up the memory",
          "accesses when they do occur, such as preloading the cache line containing the specified address into the data cache.",
          "The effect of a PLD instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches on",
          "page E2-2425."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "                     For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <label>         The label of the literal data item that is likely to be accessed in the near future. The assembler",
          "                     calculates the required value of the offset from the Align(PC, 4) value of the instruction to this label.",
          "                     The offset must be in the range 4095 to 4095. If the offset is zero or positive, imm32 is equal to the",
          "                     offset and add == TRUE. If the offset is negative, imm32 is equal to minus the offset and add == FALSE.",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<imm>           For encoding A1: is the 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in",
          "                the \"imm12\" field.",
          "                For encoding T1: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                \"imm12\" field.",
          "The alternative syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); add = (U == '1'); is_pldw = (R == '0');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if m == 15 || (n == 15 && is_pldw) then UNPREDICTABLE;"
          ],
          "mask": "0xf710f000",
          "mnemonics": [
            {
              "constraint": " R = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]"
                }
              ],
              "name": "Preload read, optional shift or rotate variant"
            },
            {
              "constraint": " R = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]"
                }
              ],
              "name": "Preload read, rotate right with extend variant"
            },
            {
              "constraint": " R = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLDW{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]"
                }
              ],
              "name": "Preload write, optional shift or rotate variant"
            },
            {
              "constraint": " R = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLDW{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]"
                }
              ],
              "name": "Preload write, rotate right with extend variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1 0 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE PLD (literal);",
            "n = UInt(Rn); m = UInt(Rm); add = TRUE; is_pldw = (W == '1');",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf810f000",
          "mnemonics": [
            {
              "constraint": " W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLD{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]"
                }
              ],
              "name": "Preload read variant"
            },
            {
              "constraint": " W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLDW{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]"
                }
              ],
              "name": "Preload write variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "132",
      "names": [
        "PLD",
        "PLDW (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    address = if add then (R[n] + offset) else (R[n] - offset);",
          "    if is_pldw then",
          "        Hint_PreloadDataForWrite(address);",
          "    else",
          "        Hint_PreloadData(address);"
        ]
      },
      "summary": {
        "lines": [
          "Preload Data (register) signals the memory system that data memory accesses from a specified address are likely in",
          "the near future. The memory system can respond by taking actions that are expected to speed up the memory",
          "accesses when they do occur, such as preloading the cache line containing the specified address into the data cache.",
          "The PLD instruction signals that the likely memory access is a read, and the PLDW instruction signals that it is a write.",
          "The effect of a PLD or PLDW instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches",
          "on page E2-2425."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           For encoding A1: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "              For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For encoding T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-           Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "              and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "+             Specifies the index register is added to the base register.",
          "<Rm>          Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>       Is the type of shift to be applied to the index register, encoded in the \"type\" field. It can have the",
          "              following values:",
          "              LSL          when type = 00",
          "              LSR          when type = 01",
          "              ASR          when type = 10",
          "              ROR          when type = 11",
          "<amount>      For encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32",
          "              (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "              For encoding T1: is the shift amount, in the range 0 to 3, defaulting to 0 and encoded in the \"imm2\"",
          "              field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 0 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);    imm32 = ZeroExtend(imm12, 32);        add = (U == '1');"
          ],
          "mask": "0xf450f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]"
                },
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} <label>// Normal form"
                },
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [PC, #{+/-}<imm>]// Alternative form"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE encoding T3;",
            "n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);           add = TRUE;"
          ],
          "mask": "0xf990f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1 1 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE encoding T3;",
            "n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);           add = FALSE;"
          ],
          "mask": "0xf910fc00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0 1 1 1 1 1 1 1 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "n = 15;   imm32 = ZeroExtend(imm12, 32);       add = (U == '1');"
          ],
          "mask": "0xf91ff000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} <label>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [PC, #{+/-}<imm>]// Alternative syntax"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "133",
      "names": [
        "PLI",
        "(immediate literal)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    base = if n == 15 then Align(PC,4) else R[n];",
          "    address = if add then (base + imm32) else (base - imm32);",
          "    Hint_PreloadInstr(address);"
        ]
      },
      "summary": {
        "lines": [
          "Preload Instruction signals the memory system that instruction memory accesses from a specified address are likely",
          "in the near future. The memory system can respond by taking actions that are expected to speed up the memory",
          "accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction",
          "cache.",
          "The effect of a PLI instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches on",
          "page E2-2425."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. Must be AL or omitted.",
          "                For encoding T1, T2 and T3: see Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<label>         The label of the instruction that is likely to be accessed in the near future. The assembler calculates",
          "                the required value of the offset from the Align(PC, 4) value of the instruction to this label. The offset",
          "                must be in the range 4095 to 4095. If the offset is zero or positive, imm32 is equal to the offset and",
          "                add == TRUE. If the offset is negative, imm32 is equal to minus the offset and add == FALSE.",
          "<Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                defaulting to 0 and encoded in the \"imm12\" field.",
          "                For encoding T1: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                defaulting to 0 and encoded in the \"imm12\" field.",
          "                For encoding T2: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field.",
          "                For encoding T3: is a 12-bit unsigned immediate byte offset, in the range 0 to 4095, encoded in the",
          "                \"imm12\" field.",
          "For the literal forms of the instruction, encoding T3 is used, or Rn is encoded as 0b1111 in encoding A1, to indicate",
          "that the PC is the base register.",
          "The alternative literal syntax permits the addition or subtraction of the offset and the immediate offset to be specified",
          "separately, including permitting a subtraction of 0 that cannot be specified using the normal syntax. For more",
          "information, see Use of labels in UAL instruction syntax on page F1-2469."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 0 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); add = (U == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf650f000",
          "mnemonics": [
            {
              "constraint": " imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1 0 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE PLI (immediate, literal);",
            "n = UInt(Rn); m = UInt(Rm); add = TRUE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf910f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PLI{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "134",
      "names": [
        "PLI",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    address = if add then (R[n] + offset) else (R[n] - offset);",
          "    Hint_PreloadInstr(address);"
        ]
      },
      "summary": {
        "lines": [
          "Preload Instruction signals the memory system that instruction memory accesses from a specified address are likely",
          "in the near future. The memory system can respond by taking actions that are expected to speed up the memory",
          "accesses when they do occur, such as pre-loading the cache line containing the specified address into the instruction",
          "cache.",
          "The effect of a PLI instruction is IMPLEMENTATION DEFINED. For more information, see Preloading caches on",
          "page E2-2425."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "                     For encoding T1: see Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     +/-             Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "                     and encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     +               Specifies the index register is added to the base register.",
          "     <Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "     <shift>         Is the type of shift to be applied to the index register, encoded in the \"type\" field. It can have the",
          "                     following values:",
          "                     LSL          when type = 00",
          "                     LSR          when type = 01",
          "                     ASR          when type = 10",
          "                     ROR          when type = 11",
          "     <amount>        For encoding A1: is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32",
          "                     (when <shift> = LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32.",
          "                     For encoding T1: is the shift amount, in the range 0 to 3, defaulting to 0 and encoded in the \"imm2\"",
          "                     field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "register_list",
              "size": 8,
              "type": 0
            }
          ],
          "decode": [
            "registers = P:'0000000':register_list;   UnalignedAllowed = FALSE;",
            "if BitCount(registers) < 1 then UNPREDICTABLE;",
            "if registers<15> == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000bc00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "POP{<c>}{<q>} <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "LDM{<c>}{<q>} SP!, <registers>// Alternate syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "135",
      "names": [
        "POP",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = SP;",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];",
          "            address = address + 4;",
          "    if registers<15> == '1' then",
          "        if UnalignedAllowed then",
          "            if address<1:0> == '00' then",
          "                LoadWritePC(MemU[address,4]);",
          "            else",
          "                      UNPREDICTABLE;",
          "              else",
          "                  LoadWritePC(MemA[address,4]);",
          "          if registers<13> == '0' then SP = SP + 4*BitCount(registers);",
          "          if registers<13> == '1' then SP = bits(32) UNKNOWN;"
        ]
      },
      "summary": {
        "lines": [
          "Pop Multiple Registers from Stack loads multiple general-purpose registers from the stack, loading from",
          "consecutive memory locations starting at the address in SP, and updates SP to point just above the loaded data.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "The registers loaded can include the PC, causing a branch to a loaded address. This is an interworking branch, see",
          "Pseudocode description of operations on the AArch32 general-purpose registers and the PC on page E1-2378."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<registers>    Is a list of one or more registers to be loaded, separated by commas and surrounded by { and }. The",
          "               registers in the list must be in the range R0-R7, encoded in the \"register_list\" field, and can",
          "               optionally include the PC. If the PC is in the list, the \"P\" field is set to 1, otherwise this field defaults",
          "               to 0. If the PC is in the list, the instruction must be either outside any IT block, or the last instruction",
          "               in an IT block."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 0 1 0 1 1 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [],
          "mask": "0x08bd0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when BitCount(register_list) > 1.",
                      "target": "LDM{<c>}{<q>} SP!, <registers>"
                    }
                  ],
                  "value": "POP{<c>}{<q>} <registers>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1",
              "size": 16,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 13,
              "type": 0
            }
          ],
          "decode": [],
          "mask": "0xe8bd0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when BitCount(register_list) > 1.",
                      "target": "LDM{<c>}{<q>} SP!, <registers>"
                    }
                  ],
                  "value": "POP{<c>}{<q>} <registers>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "136",
      "names": [
        "POP",
        "(multiple registers)"
      ],
      "operation": {
        "lines": [
          "The description of LDM, LDMIA, LDMFD gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Pop Multiple Registers from Stack loads multiple general-purpose registers from the stack, loading from",
          "consecutive memory locations starting at the address in SP, and updates SP to point just above the loaded data.",
          "This instruction is an alias of the LDM, LDMIA, LDMFD instruction. This means that:",
          "         The encodings in this description are named to match the encodings of LDM, LDMIA, LDMFD.",
          "         The description of LDM, LDMIA, LDMFD gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<registers>          For encoding A1: is a list of two or more registers to be loaded, separated by commas and",
          "                     surrounded by { and }. The lowest-numbered register is loaded from the lowest memory address,",
          "                     through to the highest-numbered register from the highest memory address. See also Encoding of",
          "                     lists of general-purpose registers and the PC on page F2-2514. If the SP is in the list, the value of",
          "                     the SP after such an instruction is UNKNOWN. The PC can be in the list. If it is, the instruction",
          "                     branches to the address loaded to the PC. This is an interworking branch, see Pseudocode",
          "                     description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                     ARM deprecates the use of this instruction with both the LR and the PC in the list.",
          "                     For encoding T2: is a list of two or more registers to be loaded, separated by commas and",
          "                     surrounded by { and }. The lowest-numbered register is loaded from the lowest memory address,",
          "                     through to the highest-numbered register from the highest memory address. See also Encoding of",
          "                     lists of general-purpose registers and the PC on page F2-2514. The registers in the list must be in",
          "                     the range R0-R12, encoded in the \"register_list\" field, and can optionally contain one of the LR or",
          "                     the PC. If the LR is in the list, the \"M\" field is set to 1, otherwise it defaults to 0. If the PC is in the",
          "                     list, the \"P\" field is set to 1, otherwise it defaults to 0. The PC can be in the list. If it is, the instruction",
          "                     branches to the address loaded to the PC. This is an interworking branch, see Pseudocode",
          "                     description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                     If the PC is in the list:",
          "                            The LR must not be in the list.",
          "                            The instruction must be either outside any IT block, or the last instruction in an IT block."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0 0 1 0 0 1 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [],
          "mask": "0x049d0004",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "LDR{<c>}{<q>} <Rt>, [SP], #4"
                    }
                  ],
                  "value": "POP{<c>}{<q>} <single_register_list>"
                }
              ],
              "name": "Post-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 1 1 1 0 1",
              "size": 16,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 1 1 0 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [],
          "mask": "0xf85d0b04",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "LDR{<c>}{<q>} <Rt>, [SP], #4"
                    }
                  ],
                  "value": "POP{<c>}{<q>} <single_register_list>"
                }
              ],
              "name": "Post-indexed variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "137",
      "names": [
        "POP",
        "(single register)"
      ],
      "operation": {
        "lines": [
          "The description of LDR (immediate) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Pop Single Register from Stack loads a single general-purpose register from the stack, loading from the address in",
          "SP, and updates SP to point just above the loaded data.",
          "This instruction is an alias of the LDR (immediate) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of LDR (immediate).",
          "         The description of LDR (immediate) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<single_register_list> Is the general-purpose register <Rt> to be loaded surrounded by { and }.",
          "<Rt>                 For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                     can be used. If the PC is used, the instruction branches to the address (data) loaded to the PC. This",
          "                     is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                     general-purpose registers and the PC on page E1-2378.",
          "                     For encoding T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                     can be used, provided the instruction is either outside an IT block or the last instruction of an IT",
          "                     block. If the PC is used, the instruction branches to the address (data) loaded to the PC. This is an",
          "                     interworking branch, see Pseudocode description of operations on the AArch32 general-purpose",
          "                     registers and the PC on page E1-2378."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 0 1 1 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "register_list",
              "size": 8,
              "type": 0
            }
          ],
          "decode": [
            "registers = '0':M:'000000':register_list; UnalignedAllowed = FALSE;",
            "if BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x0000b400",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "PUSH{<c>}{<q>} <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMDB{<c>}{<q>} SP!, <registers>// Alternate syntax"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "138",
      "names": [
        "PUSH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = SP - 4*BitCount(registers);",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            if i == 13 && i != LowestSetBit(registers) then // Only possible for encoding A1",
          "                MemA[address,4] = bits(32) UNKNOWN;",
          "            else",
          "                if UnalignedAllowed then",
          "                     MemU[address,4] = R[i];",
          "                else",
          "                     MemA[address,4] = R[i];",
          "            address = address + 4;",
          "    if registers<15> == '1' then // Only possible for encoding A1 or A2",
          "        if UnalignedAllowed then",
          "            MemU[address,4] = PCStoreValue();",
          "        else",
          "            MemA[address,4] = PCStoreValue();",
          "    SP = SP - 4*BitCount(registers);"
        ]
      },
      "summary": {
        "lines": [
          "Push Multiple Registers to Stack stores multiple general-purpose registers to the stack, storing to consecutive",
          "memory locations ending just below the address in SP, and updates SP to point to the start of the stored data.",
          "The lowest-numbered register is stored to the lowest memory address, through to the highest-numbered register to",
          "the highest memory address. See also Encoding of lists of general-purpose registers and the PC on page F2-2514."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<registers>     Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The",
          "                registers in the list must be in the range R0-R7, encoded in the \"register_list\" field, and can",
          "                optionally include the LR. If the LR is in the list, the \"M\" field is set to 1, otherwise this field defaults",
          "                to 0."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 1 0 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [],
          "mask": "0x092d0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when BitCount(register_list) > 1.",
                      "target": "STMDB{<c>}{<q>} SP!, <registers>"
                    }
                  ],
                  "value": "PUSH{<c>}{<q>} <registers>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 1 0 0 1 0 1 1 0 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 13,
              "type": 0
            }
          ],
          "decode": [],
          "mask": "0xe92d0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when BitCount(register_list) > 1.",
                      "target": "STMDB{<c>}{<q>} SP!, <registers>"
                    }
                  ],
                  "value": "PUSH{<c>}{<q>} <registers>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "139",
      "names": [
        "PUSH",
        "(multiple registers)"
      ],
      "operation": {
        "lines": [
          "The description of STMDB, STMFD gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Push multiple registers to Stack stores multiple general-purpose registers to the stack, storing to consecutive",
          "memory locations ending just below the address in SP, and updates SP to point to the start of the stored data.",
          "This instruction is an alias of the STMDB, STMFD instruction. This means that:",
          "         The encodings in this description are named to match the encodings of STMDB, STMFD.",
          "         The description of STMDB, STMFD gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<registers>          For encoding A1: is a list of two or more registers to be stored, separated by commas and surrounded",
          "                     by { and }. The lowest-numbered register is stored to the lowest memory address, through to the",
          "                     highest-numbered register to the highest memory address. See also Encoding of lists of",
          "                     general-purpose registers and the PC on page F2-2514. The SP and PC can be in the list. However:",
          "                            ARM deprecates the use of instructions that include the PC in the list.",
          "                            If the SP is in the list, and it is not the lowest-numbered register in the list, the instruction",
          "                             stores an UNKNOWN value for the SP.",
          "                     For encoding T1: is a list of one or more registers to be stored, separated by commas and surrounded",
          "                     by { and }. The lowest-numbered register is stored to the lowest memory address, through to the",
          "                     highest-numbered register to the highest memory address. See also Encoding of lists of",
          "         general-purpose registers and the PC on page F2-2514. The registers in the list must be in the range",
          "         R0-R12, encoded in the \"register_list\" field, and can optionally contain the LR. If the LR is in the",
          "         list, the \"M\" field is set to 1, otherwise it defaults to 0."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0 1 0 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [],
          "mask": "0x052d0004",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "STR{<c>}{<q>} <Rt>, [SP, #4]!"
                    }
                  ],
                  "value": "PUSH{<c>}{<q>} <single_register_list>"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 0 1 1 0 1",
              "size": 16,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 0 1 0 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [],
          "mask": "0xf84d0d04",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "STR{<c>}{<q>} <Rt>, [SP, #-4]!"
                    }
                  ],
                  "value": "PUSH{<c>}{<q>} <single_register_list>// Standard syntax"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "140",
      "names": [
        "PUSH",
        "(single register)"
      ],
      "operation": {
        "lines": [
          "The description of STR (immediate) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Push Single Register to Stack stores a single general-purpose register to the stack, storing to the 32-bit word below",
          "the address in SP, and updates SP to point to the start of the stored data.",
          "This instruction is an alias of the STR (immediate) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of STR (immediate).",
          "         The description of STR (immediate) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<single_register_list>",
          "                     Is the general-purpose register <Rt> to be stored surrounded by { and }.",
          "<Rt>                 For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                     can be used, but this is deprecated.",
          "                     For encoding T4: is the general-purpose register to be transferred, encoded in the \"Rt\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01000050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "141",
      "names": [
        "QADD",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (R[d], sat) = SignedSatQ(SInt(R[m]) + SInt(R[n]), 32);",
          "    if sat then",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Add adds two register values, saturates the result to the 32-bit signed integer range -231 to (231 - 1), and",
          "writes the result to the destination register. If saturation occurs, it sets PSTATE.Q to 1."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rn>               Is the second general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "142",
      "names": [
        "QADD16",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);",
          "sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);",
          "R[d]<15:0> = SignedSat(sum1, 16);",
          "R[d]<31:16> = SignedSat(sum2, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Add 16 performs two 16-bit integer additions, saturates the results to the 16-bit signed integer range -215",
          "<= x <= 215 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "143",
      "names": [
        "QADD8",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);",
          "          sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);",
          "          sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);",
          "sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);",
          "R[d]<7:0>   = SignedSat(sum1, 8);",
          "R[d]<15:8> = SignedSat(sum2, 8);",
          "R[d]<23:16> = SignedSat(sum3, 8);",
          "R[d]<31:24> = SignedSat(sum4, 8);"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Add 8 performs four 8-bit integer additions, saturates the results to the 8-bit signed integer range -27 <=",
          "x <= 27 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "144",
      "names": [
        "QASX",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);",
          "sum = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);",
          "R[d]<15:0> = SignedSat(diff, 16);",
          "R[d]<31:16> = SignedSat(sum, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one",
          "16-bit integer addition and one 16-bit subtraction, saturates the results to the 16-bit signed integer range -215 <= x",
          "<= 215 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01400050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f090",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "145",
      "names": [
        "QDADD",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);",
          "(R[d], sat2) = SignedSatQ(SInt(R[m]) + SInt(doubled), 32);",
          "if sat1 || sat2 then",
          "    PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Double and Add adds a doubled register value to another register value, and writes the result to the",
          "destination register. Both the doubling and the addition have their results saturated to the 32-bit signed integer range",
          "-231 <= x <= 231 - 1. If saturation occurs in either operation, it sets PSTATE.Q to 1."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rn>               Is the second general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01600050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f0b0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "146",
      "names": [
        "QDSUB",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          (doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);",
          "(R[d], sat2) = SignedSatQ(SInt(R[m]) - SInt(doubled), 32);",
          "if sat1 || sat2 then",
          "    PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Double and Subtract subtracts a doubled register value from another register value, and writes the result",
          "to the destination register. Both the doubling and the subtraction have their results saturated to the 32-bit signed",
          "integer range -231 <= x <= 231 - 1. If saturation occurs in either operation, it sets PSTATE.Q to 1."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rn>               Is the second general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfae0f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "147",
      "names": [
        "QSAX",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);",
          "diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);",
          "R[d]<15:0> = SignedSat(sum, 16);",
          "R[d]<31:16> = SignedSat(diff, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one",
          "16-bit integer subtraction and one 16-bit addition, saturates the results to the 16-bit signed integer range -215 <= x",
          "<= 215 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01200050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f0a0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "148",
      "names": [
        "QSUB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (R[d], sat) = SignedSatQ(SInt(R[m]) - SInt(R[n]), 32);",
          "    if sat then",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Subtract subtracts one register value from another register value, saturates the result to the 32-bit signed",
          "integer range -231 <= x <= 231 - 1, and writes the result to the destination register. If saturation occurs, it sets",
          "PSTATE.Q to 1."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rn>               Is the second general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200f70",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfad0f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "149",
      "names": [
        "QSUB16",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);",
          "diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);",
          "R[d]<15:0> = SignedSat(diff1, 16);",
          "R[d]<31:16> = SignedSat(diff2, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Subtract 16 performs two 16-bit integer subtractions, saturates the results to the 16-bit signed integer",
          "range -215 <= x <= 215 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200ff0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfac0f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "150",
      "names": [
        "QSUB8",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);",
          "          diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);",
          "          diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);",
          "diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);",
          "R[d]<7:0>   = SignedSat(diff1, 8);",
          "R[d]<15:8> = SignedSat(diff2, 8);",
          "R[d]<23:16> = SignedSat(diff3, 8);",
          "R[d]<31:24> = SignedSat(diff4, 8);"
        ]
      },
      "summary": {
        "lines": [
          "Saturating Subtract 8 performs four 8-bit integer subtractions, saturates the results to the 8-bit signed integer range",
          "-27 <= x <= 27 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06ff0f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RBIT{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if !Consistent(Rm) then UNPREDICTABLE;",
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f0a0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RBIT{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "151",
      "names": [
        "RBIT",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          bits(32) result;",
          "for i = 0 to 31",
          "    result<31-i> = R[m]<i>;",
          "R[d] = result;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Bits reverses the bit order in a 32-bit register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field.",
          "                   For encoding T1: is the general-purpose source register, encoded in the \"Rm\" field. Its number must",
          "                   be encoded twice."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06bf0f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REV{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 0 1 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);"
          ],
          "mask": "0x0000ba00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REV{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if !Consistent(Rm) then UNPREDICTABLE;",
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REV{<c>}.W <Rd>, <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "REV{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "152",
      "names": [
        "REV",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    bits(32) result;",
          "    result<31:24> = R[m]<7:0>;",
          "    result<23:16> = R[m]<15:8>;",
          "    result<15:8> = R[m]<23:16>;",
          "    result<7:0>    = R[m]<31:24>;",
          "    R[d] = result;"
        ]
      },
      "summary": {
        "lines": [
          "Byte-Reverse Word reverses the byte order in a 32-bit register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>         For encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field.",
          "             For encoding T2: is the general-purpose source register, encoded in the \"Rm\" field. Its number must",
          "             be encoded twice."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06bf0fb0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REV16{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 0 1 0 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);"
          ],
          "mask": "0x0000ba40",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REV16{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if !Consistent(Rm) then UNPREDICTABLE;",
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f090",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REV16{<c>}.W <Rd>, <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "REV16{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "153",
      "names": [
        "REV16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    bits(32) result;",
          "    result<31:24> = R[m]<23:16>;",
          "    result<23:16> = R[m]<31:24>;",
          "    result<15:8> = R[m]<7:0>;",
          "    result<7:0>    = R[m]<15:8>;",
          "    R[d] = result;"
        ]
      },
      "summary": {
        "lines": [
          "Byte-Reverse Packed Halfword reverses the byte order in each16-bit halfword of a 32-bit register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>         For encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field.",
          "             For encoding T2: is the general-purpose source register, encoded in the \"Rm\" field. Its number must",
          "             be encoded twice."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06ff0fb0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REVSH{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 0 1 0 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);"
          ],
          "mask": "0x0000bac0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REVSH{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if !Consistent(Rm) then UNPREDICTABLE;",
            "d = UInt(Rd); m = UInt(Rm);",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f0b0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "REVSH{<c>}.W <Rd>, <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "REVSH{<c>}{<q>} <Rd>, <Rm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "154",
      "names": [
        "REVSH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    bits(32) result;",
          "    result<31:8> = SignExtend(R[m]<7:0>, 24);",
          "    result<7:0>    = R[m]<15:8>;",
          "    R[d] = result;"
        ]
      },
      "summary": {
        "lines": [
          "Byte-Reverse Signed Halfword reverses the byte order in the lower 16-bit halfword of a 32-bit register, and",
          "sign-extends the result to 32 bits."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>         For encoding A1 and T1: is the general-purpose source register, encoded in the \"Rm\" field.",
          "             For encoding T2: is the general-purpose source register, encoded in the \"Rm\" field. Its number must",
          "             be encoded twice."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) (1) (0) (1) (0) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "n = UInt(Rn);",
            "wback = (W == '1'); increment = (U == '1');      wordhigher = (P == U);",
            "if n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf8100a00",
          "mnemonics": [
            {
              "constraint": " P = 0 && U = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RFEDA{<c>}{<q>} <Rn>{!}"
                }
              ],
              "name": "Decrement After variant"
            },
            {
              "constraint": " P = 1 && U = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RFEDB{<c>}{<q>} <Rn>{!}"
                }
              ],
              "name": "Decrement Before variant"
            },
            {
              "constraint": " P = 0 && U = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RFE{IA}{<c>}{<q>} <Rn>{!}"
                }
              ],
              "name": "Increment After variant"
            },
            {
              "constraint": " P = 1 && U = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RFEIB{<c>}{<q>} <Rn>{!}"
                }
              ],
              "name": "Increment Before variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "n = UInt(Rn); wback = (W == '1'); increment = FALSE;            wordhigher = FALSE;",
            "if n == 15 then UNPREDICTABLE;",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xe810c000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RFEDB{<c>}{<q>} <Rn>{!}// Outside or last in IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 1 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "n = UInt(Rn); wback = (W == '1'); increment = TRUE; wordhigher = FALSE;",
            "if n == 15 then UNPREDICTABLE;",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xe990c000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RFE{IA}{<c>}{<q>} <Rn>{!}// Outside or last in IT block"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "155",
      "names": [
        "RFE",
        "RFEDA RFEDB RFEIA RFEIB"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL2 then",
          "        UNDEFINED;",
          "    elsif PSTATE.EL == EL0 then",
          "        UNPREDICTABLE;                        // UNDEFINED or NOP",
          "    else",
          "        address = if increment then R[n] else R[n]-8;",
          "        if wordhigher then address = address+4;",
          "        new_pc_value = MemA[address,4];",
          "        spsr = MemA[address+4,4];",
          "        if wback then R[n] = if increment then R[n]+8 else R[n]-8;",
          "        AArch32.ExceptionReturn(new_pc_value, spsr);"
        ]
      },
      "summary": {
        "lines": [
          "Return From Exception loads two consecutive memory locations using an address in a base register:",
          "        The word loaded from the lower address is treated as an instruction address. The PE branches to it.",
          "        The word loaded from the higher address is used to restore PSTATE. This word must be in the format of an",
          "SPSR.",
          "An address adjusted by the size of the data loaded can optionally be written back to the base register.",
          "The PE checks the value of the word loaded from the higher address for an illegal return event. See Illegal return",
          "events from AArch32 state on page G1-3845.",
          "RFE is UNDEFINED in Hyp mode and CONSTRAINED UNPREDICTABLE in User mode."
        ]
      },
      "symbols": {
        "lines": [
          "IA              For encoding A1: is an optional suffix to indicate the Increment After variant.",
          "                For encoding T2: is an optional suffix for the Increment After form.",
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "                For encoding T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!               The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "RFEFA, RFEEA, RFEFD, and RFEED are pseudo-instructions for RFEDA, RFEDB, RFEIA, and RFEIB respectively, referring to",
          "their use for popping data from Full Ascending, Empty Ascending, Full Descending, and Empty Descending stacks."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=00000",
              "size": 5,
              "type": 4
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ROR #<imm>"
                    }
                  ],
                  "value": "ROR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 0 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "1 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea4f0030",
          "mnemonics": [
            {
              "constraint": " !(imm3 == 000 && imm2 == 00).",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ROR #<imm>"
                    }
                  ],
                  "value": "ROR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOV, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "156",
      "names": [
        "ROR",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Rotate Right (immediate) provides the value of the contents of a register rotated by a constant value. The bits that",
          "are rotated off the right end are inserted into the vacated bit positions on the left.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                  See Standard assembler syntax fields on page F2-2506.",
          "     <q>                  See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>                 For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                          deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch",
          "                          to the address calculated by the operation. This is an interworking branch, see Pseudocode",
          "                          description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                          For encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "     <Rm>                 For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                          used.",
          "                          For encoding T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>          For encoding A1: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field.",
          "               For encoding T3: is the shift amount, in the range 1 to 31, encoded in the \"imm3:imm2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ROR <Rs>"
                    }
                  ],
                  "value": "ROR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x000041c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when InITBlock().",
                      "target": "MOV<c>{<q>} <Rdm>, <Rdm>, ROR <Rs>"
                    }
                  ],
                  "value": "ROR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>// Inside IT block"
                }
              ],
              "name": "Rotate right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa60f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ROR <Rs>"
                    }
                  ],
                  "value": "ROR<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, ROR <Rs>"
                    }
                  ],
                  "value": "ROR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "157",
      "names": [
        "ROR",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Rotate Right (register) provides the value of the contents of a register rotated by a variable number of bits. The bits",
          "that are rotated off the right end are inserted into the vacated bit positions on the left. The variable number of bits is",
          "read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a rotate amount in its bottom 8 bits, encoded",
          "                   in the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=00000",
              "size": 5,
              "type": 4
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ROR #<imm>"
                    }
                  ],
                  "value": "RORS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 1 1 1 1 1 (0)",
              "size": 17,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "1 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea5f0030",
          "mnemonics": [
            {
              "constraint": " !(imm3 == 000 && imm2 == 00).",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ROR #<imm>"
                    }
                  ],
                  "value": "RORS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
                }
              ],
              "name": "MOVS, shift or rotate by value variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "158",
      "names": [
        "RORS",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Rotate Right, setting flags (immediate) provides the value of the contents of a register rotated by a constant value.",
          "The bits that are rotated off the right end are inserted into the vacated bit positions on the left.",
          "If the destination register is not the PC, this instruction updates the condition flags based on the result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "         The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from AArch32",
          "state on page G1-3845.",
          "         The instruction is UNDEFINED in Hyp mode.",
          "         The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<Rd>           For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "               deprecates using the PC as the destination register, but if the PC is used, the instruction performs an",
          "               exception return, that restores PSTATE from SPSR_<current_mode>.",
          "               For encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>           For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "               used.",
          "               For encoding T3: is the general-purpose source register, encoded in the \"Rm\" field.",
          "<imm>          For encoding A1: is the shift amount, in the range 1 to 31, encoded in the \"imm5\" field.",
          "               For encoding T3: is the shift amount, in the range 1 to 31, encoded in the \"imm3:imm2\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ROR <Rs>"
                    }
                  ],
                  "value": "RORS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdm",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x000041c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when !InITBlock().",
                      "target": "MOVS{<q>} <Rdm>, <Rdm>, ROR <Rs>"
                    }
                  ],
                  "value": "RORS{<q>} {<Rdm>,} <Rdm>, <Rs>// Outside IT block"
                }
              ],
              "name": "Rotate right variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xfa70f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ROR <Rs>"
                    }
                  ],
                  "value": "RORS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rm>, <type>, <Rs> can be represented in T1"
                },
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, ROR <Rs>"
                    }
                  ],
                  "value": "RORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "159",
      "names": [
        "RORS",
        "(register)"
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Rotate Right, setting flags (register) provides the value of the contents of a register rotated by a variable number of",
          "bits, and updates the condition flags based on the result. The bits that are rotated off the right end are inserted into",
          "the vacated bit positions on the left. The variable number of bits is read from the bottom byte of a register.",
          "This instruction is an alias of the MOV, MOVS (register-shifted register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register-shifted",
          "register).",
          "         The description of MOV, MOVS (register-shifted register) gives the operational pseudocode for this",
          "instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rdm>              Is the first general-purpose source register and the destination register, encoded in the \"Rdm\" field.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the first general-purpose source register, encoded in the \"Rm\" field.",
          "<Rs>               Is the second general-purpose source register holding a rotate amount in its bottom 8 bits, encoded",
          "                   in the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01a00060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, RRX"
                    }
                  ],
                  "value": "RRX{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "MOV, rotate right with extend variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 0 1 1 1 1 (0) 0 0 0",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea4f0030",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOV{<c>}{<q>} <Rd>, <Rm>, RRX"
                    }
                  ],
                  "value": "RRX{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "MOV, rotate right with extend variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "160",
      "names": [
        "RRX",
        ""
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Rotate Right with Extend provides the value of the contents of a register shifted right by one place, with the Carry",
          "flag shifted into bit[31].",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rd>                 For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "                     deprecates using the PC as the destination register, but if the PC is used, the instruction is a branch",
          "                     to the address calculated by the operation. This is an interworking branch, see Pseudocode",
          "                     description of operations on the AArch32 general-purpose registers and the PC on page E1-2378.",
          "                     For encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>                 For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "                     used.",
          "                     For encoding T3: is the general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 1 (0) (0) (0) (0)",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0x01b00060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX"
                    }
                  ],
                  "value": "RRXS{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "MOVS, rotate right with extend variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 1 0 1 1 1 1 1 (0) 0 0 0",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [],
          "mask": "0xea5f0030",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is always the preferred disassembly.",
                      "target": "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX"
                    }
                  ],
                  "value": "RRXS{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "MOVS, rotate right with extend variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "161",
      "names": [
        "RRXS",
        ""
      ],
      "operation": {
        "lines": [
          "The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Rotate Right with Extend, setting flags provides the value of the contents of a register shifted right by one place,",
          "with the Carry flag shifted into bit[31].",
          "If the destination register is not the PC, this instruction updates the condition flags based on the result, and bit[0] is",
          "shifted into the Carry flag.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "         The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from AArch32",
          "state on page G1-3845.",
          "         The instruction is UNDEFINED in Hyp mode.",
          "         The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode.",
          "This instruction is an alias of the MOV, MOVS (register) instruction. This means that:",
          "         The encodings in this description are named to match the encodings of MOV, MOVS (register).",
          "         The description of MOV, MOVS (register) gives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<Rd>           For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. ARM",
          "               deprecates using the PC as the destination register, but if the PC is used, the instruction performs an",
          "               exception return, that restores PSTATE from SPSR_<current_mode>.",
          "               For encoding T3: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>           For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field. The PC can be",
          "               used.",
          "               For encoding T3: is the general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       n = UInt(Rn);   setflags = (S == '1');     imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02600000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "RSB variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "RSBS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 0 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       n = UInt(Rn);   setflags = !InITBlock();       imm32 = Zeros(32); // immediate = #0"
          ],
          "mask": "0x00004240",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB<c>{<q>} {<Rd>, }<Rn>, #0// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "RSBS{<q>} {<Rd>, }<Rn>, #0// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf1c00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB<c>.W {<Rd>,} <Rn>, #0// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "RSB variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS.W {<Rd>,} <Rn>, #0// Outside IT block"
                },
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "RSBS variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "162",
      "names": [
        "RSB",
        "RSBS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, '1');",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Subtract (immediate) subtracts a register value from an immediate value, and writes the result to the",
          "destination register.",
          "If the destination register is not the PC, the RSBS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The RSB variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The RSBS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "              PC is used:",
          "                      For the RSB variant, the instruction is a branch to the address calculated by the operation.",
          "                       This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                       general-purpose registers and the PC on page E1-2378.",
          "                      For the RSBS variant, the instruction performs an exception return, that restores PSTATE",
          "                       from SPSR_<current_mode>.",
          "              For encoding T1 and T2: is the general-purpose destination register, encoded in the \"Rd\" field. If",
          "              omitted, this register is the same as <Rn>.",
          "<Rn>          For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For encoding T1 and T2: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>       For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "              page F4-2559 for the range of values.",
          "              For encoding T2: an immediate value. See Modified immediate constants in T32 instructions on",
          "              page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00600000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "RSB, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "RSB, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "RSBS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "RSBS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 1 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xebc00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "RSB, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "RSB, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "RSBS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "RSBS, shift or rotate by value variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "163",
      "names": [
        "RSB",
        "RSBS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Subtract (register) subtracts a register value from an optionally-shifted register value, and writes the result",
          "to the destination register.",
          "If the destination register is not the PC, the RSBS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The RSB variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The RSBS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                     this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                     PC is used:",
          "                            For the RSB variant, the instruction is a branch to the address calculated by the operation.",
          "                             This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                             general-purpose registers and the PC on page E1-2378.",
          "                            For the RSBS variant, the instruction performs an exception return, that restores PSTATE",
          "                             from SPSR_<current_mode>.",
          "                     For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                     this register is the same as <Rn>.",
          "     <Rn>            For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                     be used.",
          "                     For encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>         For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "             can be used.",
          "             For encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>      Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "             the following values:",
          "             LSL         when type = 00",
          "             LSR         when type = 01",
          "             ASR         when type = 10",
          "             ROR         when type = 11",
          "<amount>     Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "             LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00600010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "164",
      "names": [
        "RSB",
        "RSBS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Subtract (register-shifted register) subtracts a register value from a register-shifted register value, and",
          "writes the result to the destination register. It can optionally update the condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);         n = UInt(Rn);   setflags = (S == '1');    imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02e00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "RSC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "RSCS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "165",
      "names": [
        "RSC",
        "RSCS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(NOT(R[n]), imm32, PSTATE.C);",
          "    if d == 15 then",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Subtract with Carry (immediate) subtracts a register value and the value of NOT (Carry flag) from an",
          "immediate value, and writes the result to the destination register.",
          "If the destination register is not the PC, the RSCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The RSC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The RSCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                   See Standard assembler syntax fields on page F2-2506.",
          "     <q>                   See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>                  Is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the",
          "                           same as <Rn>. ARM deprecates using the PC as the destination register, but if the PC is used:",
          "                                  For the RSC variant, the instruction is a branch to the address calculated by the operation.",
          "                                   This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                                   general-purpose registers and the PC on page E1-2378.",
          "                                  For the RSCS variant, the instruction performs an exception return, that restores PSTATE",
          "                                   from SPSR_<current_mode>.",
          "     <Rn>                  Is the general-purpose source register, encoded in the \"Rn\" field. The PC can be used.",
          "<const>      An immediate value. See Modified immediate constants in A32 instructions on page F4-2559 for the",
          "             range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00e00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "RSC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "RSC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "RSCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "RSCS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "166",
      "names": [
        "RSC",
        "RSCS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);",
          "    if d == 15 then",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Subtract with Carry (register) subtracts a register value and the value of NOT (Carry flag) from an",
          "optionally-shifted register value, and writes the result to the destination register.",
          "If the destination register is not the PC, the RSCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The RSC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The RSCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                  See Standard assembler syntax fields on page F2-2506.",
          "     <q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field. If omitted, this register is the",
          "             same as <Rn>. ARM deprecates using the PC as the destination register, but if the PC is used:",
          "                    For the RSC variant, the instruction is a branch to the address calculated by the operation.",
          "                     This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                     general-purpose registers and the PC on page E1-2378.",
          "                    For the RSCS variant, the instruction performs an exception return, that restores PSTATE",
          "                     from SPSR_<current_mode>.",
          "<Rn>         Is the first general-purpose source register, encoded in the \"Rn\" field. The PC can be used.",
          "<Rm>         Is the second general-purpose source register, encoded in the \"Rm\" field. The PC can be used.",
          "<shift>      Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "             the following values:",
          "             LSL          when type = 00",
          "             LSR          when type = 01",
          "             ASR          when type = 10",
          "             ROR          when type = 11",
          "<amount>     Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "             LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00e00010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "167",
      "names": [
        "RSC",
        "RSCS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Reverse Subtract (register-shifted register) subtracts a register value and the value of NOT (Carry flag) from a",
          "register-shifted register value, and writes the result to the destination register. It can optionally update the condition",
          "flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06100f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "168",
      "names": [
        "SADD16",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);",
          "          sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);",
          "          R[d]<15:0> = sum1<15:0>;",
          "R[d]<31:16> = sum2<15:0>;",
          "PSTATE.GE<1:0> = if sum1 >= 0 then '11' else '00';",
          "PSTATE.GE<3:2> = if sum2 >= 0 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Add 16 performs two 16-bit signed integer additions, and writes the results to the destination register. It sets",
          "PSTATE.GE according to the results of the additions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06100f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "169",
      "names": [
        "SADD8",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);",
          "          sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);",
          "          sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);",
          "sum4 = SInt(R[n]<31:24>) +   SInt(R[m]<31:24>);",
          "R[d]<7:0>   = sum1<7:0>;",
          "R[d]<15:8> = sum2<7:0>;",
          "R[d]<23:16> = sum3<7:0>;",
          "R[d]<31:24> = sum4<7:0>;",
          "PSTATE.GE<0> = if sum1 >=    0   then   '1'   else   '0';",
          "PSTATE.GE<1> = if sum2 >=    0   then   '1'   else   '0';",
          "PSTATE.GE<2> = if sum3 >=    0   then   '1'   else   '0';",
          "PSTATE.GE<3> = if sum4 >=    0   then   '1'   else   '0';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Add 8 performs four 8-bit signed integer additions, and writes the results to the destination register. It sets",
          "PSTATE.GE according to the results of the additions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06100f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "170",
      "names": [
        "SASX",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);",
          "          sum = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);",
          "R[d]<15:0> = diff<15:0>;",
          "R[d]<31:16> = sum<15:0>;",
          "PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';",
          "PSTATE.GE<3:2> = if sum >= 0 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one 16-bit",
          "integer addition and one 16-bit subtraction, and writes the results to the destination register. It sets PSTATE.GE",
          "according to the results."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       n = UInt(Rn);   setflags = (S == '1');    imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02c00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SBC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SBCS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 0 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf1600000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SBC variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SBCS variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "171",
      "names": [
        "SBC",
        "SBCS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(imm32), PSTATE.C);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract with Carry (immediate) subtracts an immediate value and the value of NOT (Carry flag) from a register",
          "value, and writes the result to the destination register.",
          "If the destination register is not the PC, the SBCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "          The SBC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The SBCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "              PC is used:",
          "                     For the SBC variant, the instruction is a branch to the address calculated by the operation.",
          "                      This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the SBCS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>.",
          "              For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>.",
          "<Rn>          For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "              used.",
          "              For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>       For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "              page F4-2559 for the range of values.",
          "              For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "              page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00c00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SBC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SBC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SBCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SBCS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 0 1 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rdn); n = UInt(Rdn); m = UInt(Rm);            setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004180",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "SBCS{<q>} {<Rdn>,} <Rdn> <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 0 1 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeb600000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SBC, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SBC, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SBCS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SBCS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "172",
      "names": [
        "SBC",
        "SBCS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract with Carry (register) subtracts an optionally-shifted register value and the value of NOT (Carry flag) from",
          "a register value, and writes the result to the destination register.",
          "If the destination register is not the PC, the SBCS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. ARM",
          "deprecates any use of these encodings. However, when the destination register is the PC:",
          "         The SBC variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The SBCS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>           Is the first general-purpose source register and the destination register, encoded in the \"Rdn\" field.",
          "<Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "                PC is used:",
          "                       For the SBC variant, the instruction is a branch to the address calculated by the operation.",
          "                        This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                        general-purpose registers and the PC on page E1-2378.",
          "                       For the SBCS variant, the instruction performs an exception return, that restores PSTATE",
          "                        from SPSR_<current_mode>.",
          "                For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                this register is the same as <Rn>.",
          "<Rn>            For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                be used.",
          "                For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>            For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                can be used.",
          "                For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>         Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                the following values:",
          "                LSL          when type = 00",
          "                LSR          when type = 01",
          "                ASR          when type = 10",
          "                ROR          when type = 11",
          "<amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00c00010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "173",
      "names": [
        "SBC",
        "SBCS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract with Carry (register-shifted register) subtracts a register-shifted register value and the value of NOT (Carry",
          "flag) from a register value, and writes the result to the destination register. It can optionally update the condition",
          "flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "widthm1",
              "size": 5,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "lsb",
              "size": 5,
              "type": 0
            },
            {
              "name": "1 0 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn);",
            "lsbit = UInt(lsb); widthminus1 = UInt(widthm1);",
            "if d == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07a00050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "widthm1",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn);",
            "lsbit = UInt(imm3:imm2); widthminus1 = UInt(widthm1);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "174",
      "names": [
        "SBFX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    msbit = lsbit + widthminus1;",
          "    if msbit <= 31 then",
          "        R[d] = SignExtend(R[n]<msbit:lsbit>, 32);",
          "    else",
          "        UNPREDICTABLE;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Bit Field Extract extracts any number of adjacent bits at any position from a register, sign-extends them to",
          "32 bits, and writes the result to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the general-purpose source register, encoded in the \"Rn\" field.",
          "<lsb>              For encoding A1: is the bit number of the least significant bit in the field, in the range 0 to 31,",
          "                   encoded in the \"lsb\" field.",
          "                   For encoding T1: is the bit number of the least significant bit in the field, in the range 0 to 31,",
          "                   encoded in the \"imm3:imm2\" field.",
          "<width>            Is the width of the field, in the range 1 to 32-<lsb>, encoded in the \"widthm1\" field as <width>-1."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0710f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb90f0f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "175",
      "names": [
        "SDIV",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if SInt(R[m]) == 0 then",
          "        if IntegerZeroDivideTrappingEnabled() then",
          "            GenerateIntegerZeroDivide();",
          "        else",
          "            result = 0;",
          "    else",
          "        result = RoundTowardsZero(SInt(R[n]) / SInt(R[m]));",
          "    R[d] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Divide divides a 32-bit signed integer register value by a 32-bit signed integer register value, and writes the",
          "result to the destination register. The condition flags are not affected."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register holding the dividend, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register holding the divisor, encoded in the \"Rm\" field.",
          "Overflow",
          "If the signed integer division 0x80000000 / 0xFFFFFFFF is performed, the pseudocode produces the intermediate",
          "integer result +231, that overflows the 32-bit signed integer range. No indication of this overflow case is produced,",
          "and the 32-bit result written to <Rd> must be the bottom 32 bits of the binary representation of +231. So the result of",
          "the division is 0x80000000."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06800fb0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "176",
      "names": [
        "SEL",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    R[d]<7:0>   = if PSTATE.GE<0> == '1' then R[n]<7:0>            else R[m]<7:0>;",
          "          R[d]<15:8> = if PSTATE.GE<1> == '1' then R[n]<15:8> else R[m]<15:8>;",
          "          R[d]<23:16> = if PSTATE.GE<2> == '1' then R[n]<23:16> else R[m]<23:16>;",
          "          R[d]<31:24> = if PSTATE.GE<3> == '1' then R[n]<31:24> else R[m]<31:24>;"
        ]
      },
      "summary": {
        "lines": [
          "Select Bytes selects each byte of its result from either its first operand or its second operand, according to the values",
          "of the PSTATE.GE flags."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 0 1 0 0 0 0 0 0 0 1 (0) (0) (0) (0) (0) (0)",
              "size": 22,
              "type": 5
            },
            {
              "name": "E",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) 0 0 0 0 (0) (0) (0) (0)",
              "size": 9,
              "type": 5
            }
          ],
          "decode": [
            "set_bigend = (E == '1');"
          ],
          "mask": "0xf1010000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SETEND{<q>} <endian_specifier>// Cannot be conditional"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 1 1 0 0 1 0 (1)",
              "size": 12,
              "type": 5
            },
            {
              "name": "E",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0) (0) (0)",
              "size": 3,
              "type": 5
            }
          ],
          "decode": [
            "set_bigend = (E == '1');",
            "if InITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0x0000b650",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SETEND{<q>} <endian_specifier>// Not permitted in IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "177",
      "names": [
        "SETEND",
        ""
      ],
      "operation": {
        "lines": [
          "EncodingSpecificOperations();",
          "AArch32.CheckSETENDEnabled();",
          "PSTATE.E = if set_bigend then '1' else '0';"
        ]
      },
      "summary": {
        "lines": [
          "Set Endianness writes a new value to PSTATE.E."
        ]
      },
      "symbols": {
        "lines": [
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<endian_specifier>",
          "              Is the endianness to be selected, and the value to be set in PSTATE.E, encoded in the \"E\" field. It",
          "              can have the following values:",
          "              LE            when E = 0",
          "              BE            when E = 1"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 1 0 0",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0320f004",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEV{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1 0 1 0 0 0 0 0 0",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0000bf40",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEV{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 1 0 0",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3af8004",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEV{<c>}.W"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "178",
      "names": [
        "SEV",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    SendEvent();"
        ]
      },
      "summary": {
        "lines": [
          "Send Event is a hint instruction. It causes an event to be signaled to all PEs in the multiprocessor system. For more",
          "information, see Wait For Event and Send Event on page G1-3888."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 1 0 1",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0320f005",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEVL{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1 0 1 0 1 0 0 0 0",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0000bf50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEVL{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 1 0 1",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3af8005",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SEVL{<c>}.W"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "179",
      "names": [
        "SEVL",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    EventRegisterSet();"
        ]
      },
      "summary": {
        "lines": [
          "Send Event Local is a hint instruction. It causes an event to be signaled locally without the requirement to affect",
          "other PEs in the multiprocessor system. It can prime a wait-loop which starts with a WFE instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "180",
      "names": [
        "SHADD16",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum1 = SInt(R[n]<15:0>) + SInt(R[m]<15:0>);",
          "sum2 = SInt(R[n]<31:16>) + SInt(R[m]<31:16>);",
          "R[d]<15:0> = sum1<16:1>;",
          "R[d]<31:16> = sum2<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Halving Add 16 performs two signed 16-bit integer additions, halves the results, and writes the results to the",
          "destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "181",
      "names": [
        "SHADD8",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum1 = SInt(R[n]<7:0>) + SInt(R[m]<7:0>);",
          "          sum2 = SInt(R[n]<15:8>) + SInt(R[m]<15:8>);",
          "          sum3 = SInt(R[n]<23:16>) + SInt(R[m]<23:16>);",
          "sum4 = SInt(R[n]<31:24>) + SInt(R[m]<31:24>);",
          "R[d]<7:0>   = sum1<8:1>;",
          "R[d]<15:8> = sum2<8:1>;",
          "R[d]<23:16> = sum3<8:1>;",
          "R[d]<31:24> = sum4<8:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Halving Add 8 performs four signed 8-bit integer additions, halves the results, and writes the results to the",
          "destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "182",
      "names": [
        "SHASX",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff = SInt(R[n]<15:0>) - SInt(R[m]<31:16>);",
          "sum = SInt(R[n]<31:16>) + SInt(R[m]<15:0>);",
          "R[d]<15:0> = diff<16:1>;",
          "R[d]<31:16> = sum<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Halving Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one",
          "signed 16-bit integer addition and one signed 16-bit subtraction, halves the results, and writes the results to the",
          "destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfae0f020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "183",
      "names": [
        "SHSAX",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          sum = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);",
          "diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);",
          "R[d]<15:0> = sum<16:1>;",
          "R[d]<31:16> = diff<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Halving Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one",
          "signed 16-bit integer subtraction and one signed 16-bit addition, halves the results, and writes the results to the",
          "destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300f70",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfad0f020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "184",
      "names": [
        "SHSUB16",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);",
          "diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);",
          "R[d]<15:0> = diff1<16:1>;",
          "R[d]<31:16> = diff2<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Halving Subtract 16 performs two signed 16-bit integer subtractions, halves the results, and writes the results",
          "to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06300ff0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfac0f020",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "185",
      "names": [
        "SHSUB8",
        ""
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);",
          "          diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);",
          "          diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);",
          "diff4 = SInt(R[n]<31:24>) - SInt(R[m]<31:24>);",
          "R[d]<7:0>   = diff1<8:1>;",
          "R[d]<15:8> = diff2<8:1>;",
          "R[d]<23:16> = diff3<8:1>;",
          "R[d]<31:24> = diff4<8:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Halving Subtract 8 performs four signed 8-bit integer subtractions, halves the results, and writes the results",
          "to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 0 (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) 0 1 1 1",
              "size": 24,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "// imm4 is for assembly/disassembly only and is ignored by hardware"
          ],
          "mask": "0x01600070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMC{<c>}{<q>} {#}<imm4>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 1 1 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 0 0 (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// imm4 is for assembly/disassembly only and is ignored by hardware",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf7f08000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMC{<c>}{<q>} {#}<imm4>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "186",
      "names": [
        "SMC",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "      if !HaveEL(EL3) || PSTATE.EL == EL0 then",
          "          UNDEFINED;",
          "      AArch32.CheckForSMCTrap();",
          "      if !ELUsingAArch32(EL3) then",
          "          if SCR_EL3.SMD == '1' then",
          "              // SMC disabled.",
          "              UNDEFINED;",
          "      else",
          "          if SCR.SCD == '1' then",
          "              // SMC disabled",
          "              if IsSecure() then",
          "                  // Executes either as a NOP or UNALLOCATED.",
          "                  c = ConstrainUnpredictable(Unpredictable_SMD);",
          "                  assert c IN {Constraint_NOP, Constraint_UNDEF};",
          "                  if c == Constraint_NOP then EndOfInstruction();",
          "              UNDEFINED;",
          "      if !ELUsingAArch32(EL3) then",
          "          AArch64.CallSecureMonitor(Zeros(16));",
          "      else",
          "          AArch32.TakeSMCException();"
        ]
      },
      "summary": {
        "lines": [
          "Secure Monitor Call causes a Secure Monitor Call exception. For more information see Secure Monitor Call (SMC)",
          "exception on page G1-3866.",
          "SMC is available only for software executing at EL1 or higher. It is UNDEFINED in User mode.",
          "If the values of HCR on page J11-5769.TSC and SCR on page J11-5769.SCD are both 0, execution of an SMC",
          "instruction at EL1 or higher generates a Secure Monitor Call exception that is taken to EL3. When EL3 is using",
          "AArch32 this exception is taken to Monitor mode.",
          "When EL3 is using AArch64, it is the SCR_EL3.SMD bit, rather than the SCR on page J11-5769.SCD bit, that can",
          "change the effect of executing an SMC instruction.",
          "When the value of HCR on page J11-5769.TSC is 1, execution of an SMC instruction in a Non-secure EL1 mode",
          "generates an exception that is taken to EL2, regardless of the value of SCR on page J11-5769.SCD. When EL2 is",
          "using AArch32, this is a Hyp Trap exception that is taken to Hyp mode. For more information see Traps to Hyp",
          "mode of Non-secure PL1 execution of SMC instructions on page G1-3915.",
          "When the value of HCR on page J11-5769.TSC is 0 and the value of SCR on page J11-5769.SCD is 1, the SMC",
          "instruction is:",
          "          UNDEFINED     in Non-secure state.",
          "          CONSTRAINED UNPREDICTABLE        if executed in Secure state at EL1 or higher."
        ]
      },
      "symbols": {
        "lines": [
          "<c>            See Standard assembler syntax fields on page F2-2506.",
          "<q>            See Standard assembler syntax fields on page F2-2506.",
          "<imm4>         Is a 4-bit unsigned immediate value, in the range 0 to 15, encoded in the \"imm4\" field. This is",
          "               ignored by the PE. The Secure Monitor Call exception handler (Secure Monitor code) can use this",
          "               value to determine what service is being requested, but ARM does not recommend this."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "n_high = (N == '1'); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01000080",
          "mnemonics": [
            {
              "constraint": " M = 0 && N = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLABB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLABB variant"
            },
            {
              "constraint": " M = 1 && N = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLABT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLABT variant"
            },
            {
              "constraint": " M = 0 && N = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLATB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLATB variant"
            },
            {
              "constraint": " M = 1 && N = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLATT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLATT variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMULBB, SMULBT, SMULTB, SMULTT;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "n_high = (N == '1'); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb100000",
          "mnemonics": [
            {
              "constraint": " N = 0 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLABB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLABB variant"
            },
            {
              "constraint": " N = 0 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLABT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLABT variant"
            },
            {
              "constraint": " N = 1 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLATB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLATB variant"
            },
            {
              "constraint": " N = 1 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLATT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLATT variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "187",
      "names": [
        "SMLABB",
        "SMLABT SMLATB SMLATT"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;",
          "    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;",
          "    result = SInt(operand1) * SInt(operand2) + SInt(R[a]);",
          "    R[d] = result<31:0>;",
          "    if result != SInt(result<31:0>) then // Signed overflow",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Accumulate (halfwords) performs a signed multiply accumulate operation. The multiply acts on",
          "two signed 16-bit quantities, taken from either the bottom or the top half of their respective source registers. The",
          "other halves of these source registers are ignored. The 32-bit product is added to a 32-bit accumulate value and the",
          "result is written to the destination register.",
          "If overflow occurs during the addition of the accumulate value, the instruction sets PSTATE.Q to 1. It is not possible",
          "for overflow to occur during the multiplication."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>          Is the first general-purpose source register holding the multiplicand in the bottom or top half",
          "              (selected by <x>), encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register holding the multiplier in the bottom or top half",
          "              (selected by <y>), encoded in the \"Rm\" field.",
          "<Ra>          Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMUAD;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07000010",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLAD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLADX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLADX variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMUAD;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb200000",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLAD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLADX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLADX variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "188",
      "names": [
        "SMLAD",
        "SMLADX"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_swap then ROR(R[m],16) else R[m];",
          "    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);",
          "    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);",
          "    result = product1 + product2 + SInt(R[a]);",
          "    R[d] = result<31:0>;",
          "    if result != SInt(result<31:0>) then // Signed overflow",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Accumulate Dual performs two signed 16 x 16-bit multiplications. It adds the products to a 32-bit",
          "accumulate operand.",
          "Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This",
          "produces top x bottom and bottom x top multiplication.",
          "This instruction sets PSTATE.Q to 1 if the accumulate operation overflows. Overflow cannot occur during the",
          "multiplications."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>          Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<Ra>          Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x00e00090",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfbc00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "189",
      "names": [
        "SMLAL",
        "SMLALS"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = SInt(R[n]) * SInt(R[m]) + SInt(R[dHi]:R[dLo]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;",
          "    if setflags then",
          "        PSTATE.N = result<63>;",
          "        PSTATE.Z = IsZeroBit(result<63:0>);",
          "        // PSTATE.C, PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Accumulate Long multiplies two signed 32-bit values to produce a 64-bit value, and accumulates",
          "this with a 64-bit value.",
          "In A32 instructions, the condition flags can optionally be updated based on the result. Use of this option adversely",
          "affects performance on many implementations."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "<RdLo>       Is the general-purpose source register holding the lower 32 bits of the addend, and the destination",
          "             register for the lower 32 bits of the result, encoded in the \"RdLo\" field.",
          "<RdHi>       Is the general-purpose source register holding the upper 32 bits of the addend, and the destination",
          "             register for the upper 32 bits of the result, encoded in the \"RdHi\" field.",
          "<Rn>         Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);",
            "n_high = (N == '1'); m_high = (M == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x01400080",
          "mnemonics": [
            {
              "constraint": " M = 0 && N = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALBB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALBB variant"
            },
            {
              "constraint": " M = 1 && N = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALBT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALBT variant"
            },
            {
              "constraint": " M = 0 && N = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALTB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALTB variant"
            },
            {
              "constraint": " M = 1 && N = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALTT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALTT variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);",
            "n_high = (N == '1'); m_high = (M == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfbc00080",
          "mnemonics": [
            {
              "constraint": " N = 0 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALBB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALBB variant"
            },
            {
              "constraint": " N = 0 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALBT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALBT variant"
            },
            {
              "constraint": " N = 1 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALTB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALTB variant"
            },
            {
              "constraint": " N = 1 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALTT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALTT variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "190",
      "names": [
        "SMLALBB",
        "SMLALBT SMLALTB SMLALTT"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;",
          "    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;",
          "    result = SInt(operand1) * SInt(operand2) + SInt(R[dHi]:R[dLo]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Accumulate Long (halfwords) multiplies two signed 16-bit values to produce a 32-bit value, and",
          "accumulates this with a 64-bit value. The multiply acts on two signed 16-bit quantities, taken from either the bottom",
          "or the top half of their respective source registers. The other halves of these source registers are ignored. The 32-bit",
          "product is sign-extended and accumulated with a 64-bit accumulate value.",
          "Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected",
          "if it occurs. Instead, the result wraps around modulo 264."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<RdLo>        Is the general-purpose source register holding the lower 32 bits of the addend, and the destination",
          "              register for the lower 32 bits of the result, encoded in the \"RdLo\" field.",
          "<RdHi>        Is the general-purpose source register holding the upper 32 bits of the addend, and the destination",
          "              register for the upper 32 bits of the result, encoded in the \"RdHi\" field.",
          "<Rn>          For encoding A1: is the first general-purpose source register holding the multiplicand in the bottom",
          "              or top half (selected by <x>), encoded in the \"Rn\" field.",
          "              For encoding T1: is the first general-purpose source register holding the multiplicand in the bottom",
          "              or top half (selected by <x>), encoded in the \"Rn\" field.",
          "<Rm>          For encoding A1: is the second general-purpose source register holding the multiplier in the bottom",
          "              or top half (selected by <y>), encoded in the \"Rm\" field.",
          "              For encoding T1: is the second general-purpose source register holding the multiplier in the bottom",
          "              or top half (selected by <x>), encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x07400010",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALDX variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfbc000c0",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLALDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLALDX variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "191",
      "names": [
        "SMLALD",
        "SMLALDX"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_swap then ROR(R[m],16) else R[m];",
          "    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);",
          "    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);",
          "    result = product1 + product2 + SInt(R[dHi]:R[dLo]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Accumulate Long Dual performs two signed 16 x 16-bit multiplications. It adds the products to a",
          "64-bit accumulate operand.",
          "Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This",
          "produces top x bottom and bottom x top multiplication.",
          "Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected",
          "if it occurs. Instead, the result wraps around modulo 264."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<RdLo>        Is the general-purpose source register holding the lower 32 bits of the addend, and the destination",
          "              register for the lower 32 bits of the result, encoded in the \"RdLo\" field.",
          "<RdHi>        Is the general-purpose source register holding the upper 32 bits of the addend, and the destination",
          "              register for the upper 32 bits of the result, encoded in the \"RdHi\" field.",
          "<Rn>          Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01200080",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAWB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLAWB variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAWT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLAWT variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMULWB, SMULWT;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb300000",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAWB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLAWB variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLAWT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLAWT variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "192",
      "names": [
        "SMLAWB",
        "SMLAWT"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;",
          "    result = SInt(R[n]) * SInt(operand2) + (SInt(R[a]) << 16);",
          "    R[d] = result<47:16>;",
          "    if (result >> 16) != SInt(R[d]) then // Signed overflow",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Accumulate (word by halfword) performs a signed multiply accumulate operation. The multiply",
          "acts on a signed 32-bit quantity and a signed 16-bit quantity. The signed 16-bit quantity is taken from either the",
          "bottom or the top half of its source register. The other half of the second source register is ignored. The top 32 bits",
          "of the 48-bit product are added to a 32-bit accumulate value and the result is written to the destination register. The",
          "bottom 16 bits of the 48-bit product are ignored.",
          "If overflow occurs during the addition of the accumulate value, the instruction sets PSTATE.Q to 1. No overflow",
          "can occur during the multiplication."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>          Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register holding the multiplier in the bottom or top half",
          "              (selected by <y>), encoded in the \"Rm\" field.",
          "<Ra>          Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMUSD;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);                 m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07000050",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLSD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSDX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLSDX variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMUSD;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb400000",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLSD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSDX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMLSDX variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "193",
      "names": [
        "SMLSD",
        "SMLSDX"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_swap then ROR(R[m],16) else R[m];",
          "    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);",
          "    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);",
          "    result = product1 - product2 + SInt(R[a]);",
          "    R[d] = result<31:0>;",
          "    if result != SInt(result<31:0>) then // Signed overflow",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Subtract Dual performs two signed 16 x 16-bit multiplications. It adds the difference of the",
          "products to a 32-bit accumulate operand.",
          "Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This",
          "produces top x bottom and bottom x top multiplication.",
          "This instruction sets PSTATE.Q to 1 if the accumulate operation overflows. Overflow cannot occur during the",
          "multiplications or subtraction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>          Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<Ra>          Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x07400050",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSLD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLSLD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSLDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLSLDX variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfbd000c0",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSLD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLSLD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMLSLDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "SMLSLDX variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "194",
      "names": [
        "SMLSLD",
        "SMLSLDX"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_swap then ROR(R[m],16) else R[m];",
          "    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);",
          "    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);",
          "    result = product1 - product2 + SInt(R[dHi]:R[dLo]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Subtract Long Dual performs two signed 16 x 16-bit multiplications. It adds the difference of the",
          "products to a 64-bit accumulate operand.",
          "Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This",
          "produces top x bottom and bottom x top multiplication.",
          "Overflow is possible during this instruction, but only as a result of the 64-bit addition. This overflow is not detected",
          "if it occurs. Instead, the result wraps around modulo 264."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<RdLo>        Is the general-purpose source register holding the lower 32 bits of the addend, and the destination",
          "              register for the lower 32 bits of the result, encoded in the \"RdLo\" field.",
          "<RdHi>        Is the general-purpose source register holding the upper 32 bits of the addend, and the destination",
          "              register for the upper 32 bits of the result, encoded in the \"RdHi\" field.",
          "<Rn>          Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMMUL;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);                 round = (R == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07500010",
          "mnemonics": [
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLA variant"
            },
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLAR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLAR variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE SMMUL;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb500000",
          "mnemonics": [
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLA variant"
            },
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLAR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLAR variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "195",
      "names": [
        "SMMLA",
        "SMMLAR"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = (SInt(R[a]) << 32) + SInt(R[n]) * SInt(R[m]);",
          "    if round then result = result + 0x80000000;",
          "    R[d] = result<63:32>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Most Significant Word Multiply Accumulate multiplies two signed 32-bit values, extracts the most",
          "significant 32 bits of the result, and adds an accumulate value.",
          "Optionally, the instruction can specify that the result is rounded instead of being truncated. In this case, the constant",
          "0x80000000 is added to the product before the high word is extracted."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.",
          "<Ra>         Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == '1');",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x075000d0",
          "mnemonics": [
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLS variant"
            },
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLSR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLSR variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Ra",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra); round = (R == '1');",
            "if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb600000",
          "mnemonics": [
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLS variant"
            },
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMLSR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "SMMLSR variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "196",
      "names": [
        "SMMLS",
        "SMMLSR"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = (SInt(R[a]) << 32) - SInt(R[n]) * SInt(R[m]);",
          "    if round then result = result + 0x80000000;",
          "    R[d] = result<63:32>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Most Significant Word Multiply Subtract multiplies two signed 32-bit values, subtracts the result from a",
          "32-bit accumulate value that is shifted left by 32 bits, and extracts the most significant 32 bits of the result of that",
          "subtraction.",
          "Optionally, the instruction can specify that the result of the instruction is rounded instead of being truncated. In this",
          "case, the constant 0x80000000 is added to the result of the subtraction before the high word is extracted."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.",
          "<Ra>         Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); round = (R == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0750f010",
          "mnemonics": [
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMUL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMMUL variant"
            },
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMULR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMMULR variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "R",
              "size": 1,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); round = (R == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb50f000",
          "mnemonics": [
            {
              "constraint": " R = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMUL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMMUL variant"
            },
            {
              "constraint": " R = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMMULR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMMULR variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "197",
      "names": [
        "SMMUL",
        "SMMULR"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = SInt(R[n]) * SInt(R[m]);",
          "    if round then result = result + 0x80000000;",
          "    R[d] = result<63:32>;"
        ]
      },
      "summary": {
        "lines": [
          "Signed Most Significant Word Multiply multiplies two signed 32-bit values, extracts the most significant 32 bits of",
          "the result, and writes those bits to the destination register.",
          "Optionally, the instruction can specify that the result is rounded instead of being truncated. In this case, the constant",
          "0x80000000 is added to the product before the high word is extracted."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0700f010",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUAD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUAD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUADX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUADX variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb20f000",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUAD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUAD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUADX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUADX variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "198",
      "names": [
        "SMUAD",
        "SMUADX"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_swap then ROR(R[m],16) else R[m];",
          "    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);",
          "    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);",
          "    result = product1 + product2;",
          "    R[d] = result<31:0>;",
          "    if result != SInt(result<31:0>) then // Signed overflow",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Dual Multiply Add performs two signed 16 x 16-bit multiplications. It adds the products together, and writes",
          "the result to the destination register.",
          "Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This",
          "produces top x bottom and bottom x top multiplication.",
          "This instruction sets PSTATE.Q to 1 if the addition overflows. The multiplications cannot overflow."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "n_high = (N == '1'); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01600080",
          "mnemonics": [
            {
              "constraint": " M = 0 && N = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULBB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULBB variant"
            },
            {
              "constraint": " M = 1 && N = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULBT variant"
            },
            {
              "constraint": " M = 0 && N = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULTB variant"
            },
            {
              "constraint": " M = 1 && N = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULTT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULTT variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "N",
              "size": 1,
              "type": 3
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "n_high = (N == '1'); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb10f000",
          "mnemonics": [
            {
              "constraint": " N = 0 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULBB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULBB variant"
            },
            {
              "constraint": " N = 0 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULBT variant"
            },
            {
              "constraint": " N = 1 && M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULTB variant"
            },
            {
              "constraint": " N = 1 && M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULTT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULTT variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "199",
      "names": [
        "SMULBB",
        "SMULBT SMULTB SMULTT"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand1 = if n_high then R[n]<31:16> else R[n]<15:0>;",
          "    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;",
          "    result = SInt(operand1) * SInt(operand2);",
          "    R[d] = result<31:0>;",
          "    // Signed overflow cannot occur"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply (halfwords) multiplies two signed 16-bit quantities, taken from either the bottom or the top half of",
          "their respective source registers. The other halves of these source registers are ignored. The 32-bit product is written",
          "to the destination register. No overflow is possible during this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rd>          Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>          Is the first general-purpose source register holding the multiplicand in the bottom or top half",
          "              (selected by <x>), encoded in the \"Rn\" field.",
          "<Rm>          Is the second general-purpose source register holding the multiplier in the bottom or top half",
          "              (selected by <y>), encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x00c00090",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULLS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfb800000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "200",
      "names": [
        "SMULL",
        "SMULLS"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = SInt(R[n]) * SInt(R[m]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;",
          "    if setflags then",
          "        PSTATE.N = result<63>;",
          "        PSTATE.Z = IsZeroBit(result<63:0>);",
          "        // PSTATE.C, PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Long multiplies two 32-bit signed values to produce a 64-bit result.",
          "In A32 instructions, the condition flags can optionally be updated based on the result. Use of this option adversely",
          "affects performance on many implementations."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "<RdLo>       Is the general-purpose destination register for the lower 32 bits of the result, encoded in the \"RdLo\"",
          "             field.",
          "<RdHi>       Is the general-purpose destination register for the upper 32 bits of the result, encoded in the \"RdHi\"",
          "             field.",
          "<Rn>         Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 0",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x012000a0",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULWB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULWB variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULWT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULWT variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_high = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb30f000",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULWB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULWB variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMULWT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMULWT variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "201",
      "names": [
        "SMULWB",
        "SMULWT"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_high then R[m]<31:16> else R[m]<15:0>;",
          "    product = SInt(R[n]) * SInt(operand2);",
          "    R[d] = product<47:16>;",
          "    // Signed overflow cannot occur"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply (word by halfword) multiplies a signed 32-bit quantity and a signed 16-bit quantity. The signed",
          "16-bit quantity is taken from either the bottom or the top half of its source register. The other half of the second",
          "source register is ignored. The top 32 bits of the 48-bit product are written to the destination register. The bottom",
          "16 bits of the 48-bit product are ignored. No overflow is possible during this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register holding the multiplier in the bottom or top half",
          "             (selected by <y>), encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0700f050",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUSD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUSD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUSDX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUSDX variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); m_swap = (M == '1');",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb40f000",
          "mnemonics": [
            {
              "constraint": " M = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUSD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUSD variant"
            },
            {
              "constraint": " M = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SMUSDX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "SMUSDX variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "202",
      "names": [
        "SMUSD",
        "SMUSDX"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand2 = if m_swap then ROR(R[m],16) else R[m];",
          "    product1 = SInt(R[n]<15:0>) * SInt(operand2<15:0>);",
          "    product2 = SInt(R[n]<31:16>) * SInt(operand2<31:16>);",
          "    result = product1 - product2;",
          "    R[d] = result<31:0>;",
          "    // Signed overflow cannot occur"
        ]
      },
      "summary": {
        "lines": [
          "Signed Multiply Subtract Dual performs two signed 16 x 16-bit multiplications. It subtracts one of the products from",
          "the other, and writes the result to the destination register.",
          "Optionally, the instruction can exchange the halfwords of the second operand before performing the arithmetic. This",
          "produces top x bottom and bottom x top multiplication.",
          "Overflow cannot occur."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>         Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>         Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 (1) (1) (0) (1) (0) (0) (0) (0) (0) (1) (0) (1) (0) (0) (0)",
              "size": 16,
              "type": 5
            },
            {
              "name": "mode",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "wback = (W == '1');   increment = (U == '1');     wordhigher = (P == U);"
          ],
          "mask": "0xf84d0500",
          "mnemonics": [
            {
              "constraint": " P = 0 && U = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SRSDA{<c>}{<q>} SP{!}, #<mode>"
                }
              ],
              "name": "Decrement After variant"
            },
            {
              "constraint": " P = 1 && U = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SRSDB{<c>}{<q>} SP{!}, #<mode>"
                }
              ],
              "name": "Decrement Before variant"
            },
            {
              "constraint": " P = 0 && U = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SRS{IA}{<c>}{<q>} SP{!}, #<mode>"
                }
              ],
              "name": "Increment After variant"
            },
            {
              "constraint": " P = 1 && U = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SRSIB{<c>}{<q>} SP{!}, #<mode>"
                }
              ],
              "name": "Increment Before variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 (1) (1) (0) (1) (1) (1) (0) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            },
            {
              "name": "mode",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "wback = (W == '1');     increment = FALSE;     wordhigher = FALSE;"
          ],
          "mask": "0xe80dc000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SRSDB{<c>}{<q>} SP{!}, #<mode>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 1 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 (1) (1) (0) (1) (1) (1) (0) (0) (0) (0) (0) (0) (0) (0) (0)",
              "size": 16,
              "type": 5
            },
            {
              "name": "mode",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "wback = (W == '1');     increment = TRUE;     wordhigher = FALSE;"
          ],
          "mask": "0xe98dc000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SRS{IA}{<c>}{<q>} SP{!}, #<mode>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "203",
      "names": [
        "SRS",
        "SRSDA SRSDB SRSIA SRSIB"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        if PSTATE.EL == EL2 then          // UNDEFINED at EL2",
          "            UNDEFINED;",
          "         // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these",
          "         // to be security holes",
          "         if PSTATE.M IN {M32_User,M32_System} then",
          "             UNPREDICTABLE;",
          "         elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP",
          "             UNPREDICTABLE;",
          "         elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP",
          "             if !HaveEL(EL3) || !IsSecure() then",
          "                 UNPREDICTABLE;",
          "             elsif !ELUsingAArch32(EL3) then",
          "                 AArch64.MonitorModeTrap();",
          "         base = Rmode[13,mode];",
          "         address = if increment then base else base-8;",
          "         if wordhigher then address = address+4;",
          "         MemA[address,4]   = LR;",
          "         MemA[address+4,4] = SPSR[];",
          "         if wback then Rmode[13,mode] = if increment then base+8 else base-8;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        if PSTATE.EL == EL2 then                  // UNDEFINED at EL2",
          "            UNDEFINED;",
          "         // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these",
          "         // to be security holes",
          "         if PSTATE.M IN {M32_User,M32_System} then",
          "             UNPREDICTABLE;",
          "         elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP",
          "             UNPREDICTABLE;",
          "         elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP",
          "             if !HaveEL(EL3) || !IsSecure() then",
          "                 UNPREDICTABLE;",
          "             elsif !ELUsingAArch32(EL3) then",
          "                 AArch64.MonitorModeTrap();",
          "         base = Rmode[13,mode];",
          "         address = if increment then base else base-8;",
          "         if wordhigher then address = address+4;",
          "         MemA[address,4]   = LR;",
          "         MemA[address+4,4] = SPSR[];",
          "         if wback then Rmode[13,mode] = if increment then base+8 else base-8;"
        ]
      },
      "summary": {
        "lines": [
          "Store Return State stores the LR_<current_mode> and SPSR_<current_mode> to the stack of a specified mode. For",
          "information about memory accesses see Memory accesses on page F2-2513.",
          "SRS is UNDEFINED in Hyp mode.",
          "SRS is UNPREDICTABLE if it is executed in User or System mode, or if the specified mode is any of the following:",
          "        Not implemented.",
          "        A mode that Table G1-2 on page G1-3806 does not show.",
          "        Not accessible from the context that the SRS instruction is executed in, as follows:",
          "     A mode that is at a higher Exception level.",
          "     When executing in Non-secure state, Monitor mode.",
          "SRS is trapped to EL3 if all of the following are true:",
          "        It is executed at Secure PL1.",
          "        The specified mode is monitor mode.",
          "        EL3 is using AArch64.",
          "See Traps to EL3 of Secure monitor functionality from Secure EL1 using AArch32 on page D1-1586."
        ]
      },
      "symbols": {
        "lines": [
          "IA               For encoding A1: is an optional suffix to indicate the Increment After variant.",
          "                 For encoding T2: is an optional suffix for the Increment After form.",
          "<c>              For encoding A1: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "                 For encoding T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "<q>              See Standard assembler syntax fields on page F2-2506.",
          "!                The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                 it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<mode>           Is the number of the mode whose Banked SP is used as the base register, encoded in the \"mode\"",
          "                 field. For details of PE modes and their numbers see AArch32 PE mode descriptions on",
          "                 page G1-3806.",
          "SRSFA, SRSEA, SRSFD, and SRSED are pseudo-instructions for SRSIB, SRSIA, SRSDB, and SRSDA respectively, referring to",
          "their use for pushing data onto Full Ascending, Empty Ascending, Full Descending, and Empty Descending stacks."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 5,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "sh",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;",
            "(shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);",
            "if d == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06a00010",
          "mnemonics": [
            {
              "constraint": " sh = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>"
                }
              ],
              "name": "Arithmetic shift right variant"
            },
            {
              "constraint": " sh = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
                }
              ],
              "name": "Logical shift left variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "sh",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "if sh == '1' && (imm3:imm2) == '00000' then SEE SSAT16;",
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;",
            "(shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3000000",
          "mnemonics": [
            {
              "constraint": " sh = 1 && !(imm3 == 000 && imm2 == 00).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>"
                }
              ],
              "name": "Arithmetic shift right variant"
            },
            {
              "constraint": " sh = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
                }
              ],
              "name": "Logical shift left variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "204",
      "names": [
        "SSAT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand = Shift(R[n], shift_t, shift_n, PSTATE.C); // PSTATE.C ignored",
          "    (result, sat) = SignedSatQ(SInt(operand), saturate_to);",
          "    R[d] = SignExtend(result, 32);",
          "    if sat then",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Saturate saturates an optionally-shifted signed value to a selectable signed range.",
          "This instruction sets PSTATE.Q to 1 if the operation saturates."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<imm>           Is the bit position for saturation, in the range 1 to 32, encoded in the \"sat_imm\" field as <imm>-1.",
          "<Rn>            Is the general-purpose source register, encoded in the \"Rn\" field.",
          "<amount>        For encoding A1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in",
          "                the \"imm5\" field.",
          "                For encoding A1: is the shift amount, in the range 1 to 32 encoded in the \"imm5\" field as <amount>",
          "                modulo 32.",
          "                For encoding T1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in",
          "                the \"imm3:imm2\" field.",
          "                For encoding T1: is the shift amount, in the range 1 to 31 encoded in the \"imm3:imm2\" field as",
          "                <amount>."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;",
            "if d == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06a00f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm)+1;",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3200000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "205",
      "names": [
        "SSAT16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result1, sat1) = SignedSatQ(SInt(R[n]<15:0>), saturate_to);",
          "    (result2, sat2) = SignedSatQ(SInt(R[n]<31:16>), saturate_to);",
          "          R[d]<15:0> = SignExtend(result1, 16);",
          "          R[d]<31:16> = SignExtend(result2, 16);",
          "          if sat1 || sat2 then",
          "              PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Saturate 16 saturates two signed 16-bit values to a selected signed range.",
          "This instruction sets PSTATE.Q to 1 if the operation saturates."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<imm>              Is the bit position for saturation, in the range 1 to 16, encoded in the \"sat_imm\" field as <imm>-1.",
          "<Rn>               Is the general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06100f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfae0f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "206",
      "names": [
        "SSAX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum = SInt(R[n]<15:0>) + SInt(R[m]<31:16>);",
          "    diff = SInt(R[n]<31:16>) - SInt(R[m]<15:0>);",
          "          R[d]<15:0> = sum<15:0>;",
          "          R[d]<31:16> = diff<15:0>;",
          "          PSTATE.GE<1:0> = if sum >= 0 then '11' else '00';",
          "          PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one 16-bit",
          "integer subtraction and one 16-bit addition, and writes the results to the destination register. It sets PSTATE.GE",
          "according to the results."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06100f70",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfad0f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "207",
      "names": [
        "SSUB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = SInt(R[n]<15:0>) - SInt(R[m]<15:0>);",
          "    diff2 = SInt(R[n]<31:16>) - SInt(R[m]<31:16>);",
          "    R[d]<15:0> = diff1<15:0>;",
          "          R[d]<31:16> = diff2<15:0>;",
          "          PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';",
          "          PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Subtract 16 performs two 16-bit signed integer subtractions, and writes the results to the destination register.",
          "It sets PSTATE.GE according to the results of the subtractions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06100ff0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfac0f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "208",
      "names": [
        "SSUB8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = SInt(R[n]<7:0>) - SInt(R[m]<7:0>);",
          "    diff2 = SInt(R[n]<15:8>) - SInt(R[m]<15:8>);",
          "    diff3 = SInt(R[n]<23:16>) - SInt(R[m]<23:16>);",
          "          diff4 = SInt(R[n]<31:24>) -    SInt(R[m]<31:24>);",
          "          R[d]<7:0>   = diff1<7:0>;",
          "          R[d]<15:8> = diff2<7:0>;",
          "          R[d]<23:16> = diff3<7:0>;",
          "          R[d]<31:24> = diff4<7:0>;",
          "          PSTATE.GE<0> = if diff1 >=     0   then   '1'   else   '0';",
          "          PSTATE.GE<1> = if diff2 >=     0   then   '1'   else   '0';",
          "          PSTATE.GE<2> = if diff3 >=     0   then   '1'   else   '0';",
          "          PSTATE.GE<3> = if diff4 >=     0   then   '1'   else   '0';"
        ]
      },
      "summary": {
        "lines": [
          "Signed Subtract 8 performs four 8-bit signed integer subtractions, and writes the results to the destination register.",
          "It sets PSTATE.GE according to the results of the subtractions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MCRR, MCRR2;",
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0x0c000000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "==1111",
              "size": 4,
              "type": 0
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MCRR, MCRR2;",
            "if coproc == '101x' then UNDEFINED;",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0x0c000000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MCRR, MCRR2;",
            "if coproc == '101x' then SEE \"Advanced SIMD and Floating-point\";",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0xec000000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "D",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "CRd",
              "size": 4,
              "type": 0
            },
            {
              "name": "!=101x",
              "size": 4,
              "type": 4
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && U == '0' && D == '0' && W == '0' then UNDEFINED;",
            "if P == '0' && U == '0' && D == '1' && W == '0' then SEE MCRR, MCRR2;",
            "if coproc == '101x' then UNDEFINED;",
            "n = UInt(Rn); cp = UInt(coproc);",
            "imm32 = ZeroExtend(imm8:'00', 32); index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;"
          ],
          "mask": "0xfc000000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>{, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            },
            {
              "constraint": " P = 0 && U = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STC2{L}{<c>}{<q>} <coproc>, <CRd>, [<Rn>], <option>"
                }
              ],
              "name": "Unindexed variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "209",
      "names": [
        "STC",
        "STC2"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    Coproc_CheckInstr(cp, ThisInstr());",
          "    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "    address = if index then offset_addr else R[n];",
          "    repeat",
          "        MemA[address,4] = Coproc_GetWordToStore(cp, ThisInstr());",
          "        address = address + 4;",
          "    until Coproc_DoneStoring(cp, ThisInstr());",
          "    if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Coprocessor stores data from a conceptual coprocessor to a sequence of consecutive memory addresses.",
          "This is a generic coprocessor instruction. The coproc field identifies the target conceptual coprocessor. This must be",
          "one of CP10, CP11, CP14, or CP15, and for these CP values, this manual defines the imm8, CRd, and D field values",
          "that are valid STC and STC2 instructions. Other encodings are UNDEFINED. For more information see Conceptual",
          "coprocessor support on page E1-2414 and General behavior of System registers on page G4-4172.",
          "In an implementation that includes EL2, the permitted STC access to a system control register can be trapped to Hyp",
          "mode, meaning that an attempt to execute an STC instruction in a Non-secure mode other than Hyp mode, that would",
          "be permitted in the absence of the Hyp trap controls, generates a Hyp Trap exception. For more information, see",
          "Trapping general CP14 accesses to debug registers on page G1-3923.",
          "For simplicity, the STC pseudocode does not show this possible trap to Hyp mode."
        ]
      },
      "symbols": {
        "lines": [
          "L              If specified, selects the D == 1 form of the encoding. If omitted, selects the D == 0 form.",
          "<c>            For encoding A1, T1 and T2: see Standard assembler syntax fields on page F2-2506.",
          "               For encoding A2: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <coproc>        Is the name of the coprocessor, encoded in the \"coproc\" field. The valid coprocessor names are p10,",
          "                     p11, p14, and p15.",
          "     <CRd>           Is the coprocessor register to be transferred, encoded in the \"CRd\" field.",
          "     <Rn>            For encoding A1, A2: is the general-purpose base register, encoded in the \"Rn\" field. The PC can",
          "                     be used, but this is deprecated.",
          "                     For encoding A1, A2, T1, T2: is the general-purpose base register, encoded in the \"Rn\" field.",
          "     <option>        Is a coprocessor option, in the range 0 to 255 enclosed in { }, encoded in the \"imm8\" field.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     <imm>           Is the immediate offset used for forming the address, a multiple of 4 in the range 0-1020, defaulting",
          "                     to 0 and encoded in the \"imm8\" field, as <imm>/4."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) (1) (1) 0 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0180fc90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STL{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 1 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00faf",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STL{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "210",
      "names": [
        "STL",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    MemO[address, 4] = R[t];"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Word stores a word from a register to memory. The instruction also has memory ordering semantics",
          "as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) (1) (1) 0 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01c0fc90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 0 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00f8f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLB{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "211",
      "names": [
        "STLB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    MemO[address, 1] = R[t]<7:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Byte stores a byte from a register to memory. The instruction also has memory ordering semantics as",
          "described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0x01800e90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEX{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00fe0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEX{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "212",
      "names": [
        "STLEX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    if AArch32.ExclusiveMonitorsPass(address,4) then",
          "        MemO[address, 4] = R[t];",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Exclusive Word stores a word from a register to memory if the executing PE has exclusive access to",
          "the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was",
          "performed.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                   written, encoded in the \"Rd\" field. The value returned is:",
          "                   0            If the operation updates memory.",
          "                   1            If the operation fails to update memory.",
          "     <Rt>              Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     Aborts and alignment",
          "     If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "             Memory is not updated.",
          "             <Rd> is not updated.",
          "     A non word-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to",
          "     the following rules:",
          "             If AArch32.ExclusiveMonitorsPass() returns TRUE, the exception is generated.",
          "             Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.",
          "     If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "     synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0x01c00e90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00fc0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "213",
      "names": [
        "STLEXB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    if AArch32.ExclusiveMonitorsPass(address,1) then",
          "        MemO[address, 1] = R[t]<7:0>;",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Exclusive Byte stores a byte from a register to memory if the executing PE has exclusive access to",
          "the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store was",
          "performed.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                   written, encoded in the \"Rd\" field. The value returned is:",
          "                   0            If the operation updates memory.",
          "                   1            If the operation fails to update memory.",
          "     <Rt>              Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     Aborts",
          "     If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "             Memory is not updated.",
          "             <Rd> is not updated.",
          "     If ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a synchronous Data",
          "     Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); t2 = t+1; n = UInt(Rn);",
            "if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t || d == t2 then UNPREDICTABLE;"
          ],
          "mask": "0x01a00e90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn);",
            "if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t || d == t2 then UNPREDICTABLE;"
          ],
          "mask": "0xe8c000f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "214",
      "names": [
        "STLEXD",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.",
          "    value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];",
          "    if AArch32.ExclusiveMonitorsPass(address, 8) then",
          "        MemO[address, 8] = value;",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Exclusive Doubleword stores a doubleword from two registers to memory if the executing PE has",
          "exclusive access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if",
          "no store was performed.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                   written, encoded in the \"Rd\" field. The value returned is:",
          "                   0            If the operation updates memory.",
          "                   1            If the operation fails to update memory.",
          "     <Rt>              For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                       <Rt> must be even-numbered and not R14.",
          "                       For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rt2>             For encoding A1: is the second general-purpose register to be transferred. <Rt2> must be <R(t+1)>.",
          "                       For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "     <Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     Aborts and alignment",
          "     If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "             Memory is not updated.",
          "             <Rd> is not updated.",
          "     A non word-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to",
          "     the following rules:",
          "             If AArch32.ExclusiveMonitorsPass() returns TRUE, the exception is generated.",
          "             Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.",
          "     If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "     synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 0 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0x01e00e90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00fd0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLEXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "215",
      "names": [
        "STLEXH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    if AArch32.ExclusiveMonitorsPass(address,2) then",
          "        MemO[address, 2] = R[t]<15:0>;",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Exclusive Halfword stores a halfword from a register to memory if the executing PE has exclusive",
          "access to the memory at that address, and returns a status value of 0 if the store was successful, or of 1 if no store",
          "was performed.",
          "The instruction also has memory ordering semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                   written, encoded in the \"Rd\" field. The value returned is:",
          "                   0            If the operation updates memory.",
          "                   1            If the operation fails to update memory.",
          "     <Rt>              Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "     Aborts and alignment",
          "     If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "             Memory is not updated",
          "             <Rd> is not updated.",
          "     A non word-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to",
          "     the following rules:",
          "             If AArch32.ExclusiveMonitorsPass() returns TRUE, the exception is generated.",
          "             Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.",
          "     If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "     synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) (1) (1) 0 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01e0fc90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1 (1) (1) (1) (1)",
              "size": 12,
              "type": 5
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn);",
            "if t == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00f9f",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STLH{<c>}{<q>} <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "216",
      "names": [
        "STLH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    MemO[address, 2] = R[t]<15:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Store-Release Halfword stores a halfword from a register to memory. The instruction also has memory ordering",
          "semantics as described in Load-Acquire, Store-Release on page B2-88.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>               Is the general-purpose base register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 0 1 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x08800000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STM{IA}{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMEA{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Empty Ascending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 8,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = '00000000':register_list;            wback = TRUE;",
            "if BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x0000c000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STM{IA}{<c>}{<q>} <Rn>!, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMEA{<c>}{<q>} <Rn>!, <registers>// Alternate syntax, Empty Ascending stack"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 13,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = '0':M:'0':register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0xe8800000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STM{IA}{<c>}.W <Rn>{!}, <registers>// Preferred syntax, if <Rn>, '!' and <registers> can be represented"
                },
                {
                  "aliases": [],
                  "value": "in T1"
                },
                {
                  "aliases": [],
                  "value": "STMEA{<c>}.W <Rn>{!}, <registers>// Alternate syntax, Empty Ascending stack, if <Rn>, '!' and <registers>"
                },
                {
                  "aliases": [],
                  "value": "can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "STM{IA}{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMEA{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Empty Ascending stack"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "217",
      "names": [
        "STM",
        "STMIA STMEA"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            if i == n && wback && i != LowestSetBit(registers) then",
          "                MemA[address,4] = bits(32) UNKNOWN; // Only possible for encodings T1 and A1",
          "            else",
          "                MemA[address,4] = R[i];",
          "            address = address + 4;",
          "    if registers<15> == '1' then // Only possible for encoding A1",
          "        MemA[address,4] = PCStoreValue();",
          "    if wback then R[n] = R[n] + 4*BitCount(registers);"
        ]
      },
      "summary": {
        "lines": [
          "Store Multiple (Increment After, Empty Ascending) stores multiple registers to consecutive memory locations using",
          "an address from a base register. The consecutive memory locations start at this address, and the address just above",
          "the last of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "For details of related system instructions see STM (User registers)."
        ]
      },
      "symbols": {
        "lines": [
          "IA            Is an optional suffix for the Increment After form.",
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!             The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "              it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<registers>   For encoding A1: is a list of one or more registers to be stored, separated by commas and surrounded",
          "              by { and }. The PC can be in the list. However, ARM deprecates the use of instructions that include",
          "              the PC in the list. If base register writeback is specified, and the base register is not the",
          "              lowest-numbered register in the list, such an instruction stores an UNKNOWN value for the base",
          "              register.",
          "              For encoding T1: is a list of one or more registers to be stored, separated by commas and surrounded",
          "              by { and }. The registers in the list must be in the range R0-R7, encoded in the \"register_list\" field.",
          "              If the base register is not the lowest-numbered register in the list, such an instruction stores an",
          "              UNKNOWN value for the base register.",
          "              For encoding T2: is a list of one or more registers to be stored, separated by commas and surrounded",
          "              by { and }. The registers in the list must be in the range R0-R12, encoded in the \"register_list\" field,",
          "              and can optionally contain the LR. If the LR is in the list, the \"M\" field is set to 1, otherwise it",
          "              defaults to 0."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 (0) 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; increment = (U == '1');               wordhigher = (P == U);",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x08400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STM{<amode>}{<c>}{<q>} <Rn>, <registers>^"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "218",
      "names": [
        "STM",
        "(User registers)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if PSTATE.EL == EL2 then",
          "        UNDEFINED;",
          "    elsif PSTATE.M IN {M32_User,M32_System} then",
          "        UNPREDICTABLE;",
          "    else",
          "        length = 4*BitCount(registers);",
          "        address = if increment then R[n] else R[n]-length;",
          "        if wordhigher then address = address+4;",
          "        for i = 0 to 14",
          "            if registers<i> == '1' then // Store User mode register",
          "                MemA[address,4] = Rmode[i, M32_User];",
          "                address = address + 4;",
          "        if registers<15> == '1' then",
          "            MemA[address,4] = PCStoreValue();"
        ]
      },
      "summary": {
        "lines": [
          "In an EL1 mode other than System mode, Store Multiple (User registers) stores multiple User mode registers to",
          "consecutive memory locations using an address from a base register. The PE reads the base register value normally,",
          "using the current mode to determine the correct Banked version of the register. This instruction cannot writeback to",
          "the base register.",
          "Store Multiple (User registers) is UNDEFINED in Hyp mode, and CONSTRAINED UNPREDICTABLE in User or System",
          "modes."
        ]
      },
      "symbols": {
        "lines": [
          "     <amode>            is one of:",
          "                        DA           Decrement After. The consecutive memory addresses end at the address in the base",
          "                                     register. Encoded as P = 0, U = 0.",
          "                        ED           Empty Descending. For this instruction, a synonym for DA.",
          "                        DB           Decrement Before. The consecutive memory addresses end one word below the address",
          "                                     in the base register. Encoded as P = 1, U = 0.",
          "                        FD           Full Descending. For this instruction, a synonym for DB.",
          "                        IA           Increment After. The consecutive memory addresses start at the address in the base",
          "                                     register. This is the default. Encoded as P = 0, U = 1.",
          "                        EA           Empty Ascending. For this instruction, a synonym for IA.",
          "                        IB           Increment Before. The consecutive memory addresses start one word above the address",
          "                                     in the base register. Encoded as P = 1, U = 1.",
          "                        FA           Full Ascending. For this instruction, a synonym for IB.",
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rn>               Is the general-purpose base register, encoded in the \"Rn\" field.",
          "<registers>   Is a list of one or more registers, separated by commas and surrounded by { and }. It specifies the",
          "              set of registers to be stored by the STM instruction. The registers are stored with the lowest-numbered",
          "              register to the lowest memory address, through to the highest-numbered register to the highest",
          "              memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "              page F2-2514."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x08000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STMDA{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMED{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Empty Descending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "219",
      "names": [
        "STMDA",
        "STMED"
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          address = R[n] - 4*BitCount(registers) + 4;",
          "          for i = 0 to 14",
          "              if registers<i> == '1' then",
          "                  if i == n && wback && i != LowestSetBit(registers) then",
          "                      MemA[address,4] = bits(32) UNKNOWN;",
          "                  else",
          "                      MemA[address,4] = R[i];",
          "                  address = address + 4;",
          "if registers<15> == '1' then",
          "    MemA[address,4] = PCStoreValue();",
          "if wback then R[n] = R[n] - 4*BitCount(registers);"
        ]
      },
      "summary": {
        "lines": [
          "Store Multiple Decrement After (Empty Descending) stores multiple registers to consecutive memory locations",
          "using an address from a base register. The consecutive memory locations end at this address, and the address just",
          "below the lowest of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "For details of related system instructions see STM (User registers)."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rn>                 Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!                    The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                     it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<registers>          Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The",
          "                     PC can be in the list. However, ARM deprecates the use of instructions that include the PC in the",
          "                     list. If base register writeback is specified, and the base register is not the lowest-numbered register",
          "                     in the list, such an instruction stores an UNKNOWN value for the base register."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 1 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x09000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STMDB{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMFD{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Descending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 1 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "M",
              "size": 1,
              "type": 3
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "register_list",
              "size": 13,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = '0':M:'0':register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;",
            "if wback && registers<n> == '1' then UNPREDICTABLE;"
          ],
          "mask": "0xe9000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STMDB{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMFD{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Descending stack"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "220",
      "names": [
        "STMDB",
        "STMFD"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n] - 4*BitCount(registers);",
          "    for i = 0 to 14",
          "        if registers<i> == '1' then",
          "            if i == n && wback && i != LowestSetBit(registers) then",
          "                MemA[address,4] = bits(32) UNKNOWN; // Only possible for encoding A1",
          "            else",
          "                MemA[address,4] = R[i];",
          "            address = address + 4;",
          "    if registers<15> == '1' then // Only possible for encoding A1",
          "        MemA[address,4] = PCStoreValue();",
          "    if wback then R[n] = R[n] - 4*BitCount(registers);"
        ]
      },
      "summary": {
        "lines": [
          "Store Multiple Decrement Before (Full Descending) stores multiple registers to consecutive memory locations",
          "using an address from a base register. The consecutive memory locations end just below this address, and the",
          "address of the first of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "For details of related system instructions see STM (User registers).",
          "This instruction is used by the alias PUSH (multiple registers). See the Alias conditions on page F7-3099 table for",
          "details of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!             The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "              it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<registers>   For encoding A1: is a list of one or more registers to be stored, separated by commas and surrounded",
          "              by { and }. The PC can be in the list. However, ARM deprecates the use of instructions that include",
          "              the PC in the list. If base register writeback is specified, and the base register is not the",
          "              lowest-numbered register in the list, such an instruction stores an UNKNOWN value for the base",
          "              register.",
          "              For encoding T1: is a list of one or more registers to be stored, separated by commas and surrounded",
          "              by { and }. The registers in the list must be in the range R0-R12, encoded in the \"register_list\" field,",
          "              and can optionally contain the LR. If the LR is in the list, the \"M\" field is set to 1, otherwise it",
          "              defaults to 0."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 0 0 1 1 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "register_list",
              "size": 16,
              "type": 0
            }
          ],
          "decode": [
            "n = UInt(Rn); registers = register_list; wback = (W == '1');",
            "if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;"
          ],
          "mask": "0x09800000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STMIB{<c>}{<q>} <Rn>{!}, <registers>// Preferred syntax"
                },
                {
                  "aliases": [],
                  "value": "STMFA{<c>}{<q>} <Rn>{!}, <registers>// Alternate syntax, Full Ascending stack"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "221",
      "names": [
        "STMIB",
        "STMFA"
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          address = R[n] + 4;",
          "          for i = 0 to 14",
          "              if registers<i> == '1' then",
          "                  if i == n && wback && i != LowestSetBit(registers) then",
          "                      MemA[address,4] = bits(32) UNKNOWN;",
          "                  else",
          "                      MemA[address,4] = R[i];",
          "                  address = address + 4;",
          "if registers<15> == '1' then",
          "    MemA[address,4] = PCStoreValue();",
          "if wback then R[n] = R[n] + 4*BitCount(registers);"
        ]
      },
      "summary": {
        "lines": [
          "Store Multiple Increment Before (Full Ascending) stores multiple registers to consecutive memory locations using",
          "an address from a base register. The consecutive memory locations start just above this address, and the address of",
          "the last of those locations can optionally be written back to the base register.",
          "The lowest-numbered register is loaded from the lowest memory address, through to the highest-numbered register",
          "from the highest memory address. See also Encoding of lists of general-purpose registers and the PC on",
          "page F2-2514.",
          "For details of related system instructions see STM (User registers)."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rn>                 Is the general-purpose base register, encoded in the \"Rn\" field.",
          "!                    The address adjusted by the size of the data loaded is written back to the base register. If specified,",
          "                     it is encoded in the \"W\" field as 1, otherwise this field defaults to 0.",
          "<registers>          Is a list of one or more registers to be stored, separated by commas and surrounded by { and }. The",
          "                     PC can be in the list. However, ARM deprecates the use of instructions that include the PC in the",
          "                     list. If base register writeback is specified, and the base register is not the lowest-numbered register",
          "                     in the list, such an instruction stores an UNKNOWN value for the base register."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE STRT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x04000000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 1 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rb",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt);       n = UInt(Rn); imm32 = ZeroExtend(imm5:'00', 32);",
            "index = TRUE;       add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00006000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 0 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt);    n = 13; imm32 = ZeroExtend(imm8:'00', 32);",
            "index = TRUE;    add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00009000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [SP{, #{+}<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "if t == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf8c00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]// <Rt>, <Rn>, <imm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '1' && U == '1' && W == '0' then SEE STRT;",
            "if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE;"
          ],
          "mask": "0xf8400800",
          "mnemonics": [
            {
              "constraint": " P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "222",
      "names": [
        "STR",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "        address = if index then offset_addr else R[n];",
          "        MemU[address,4] = if t == 15 then PCStoreValue() else R[t];",
          "        if wback then R[n] = offset_addr;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "        address = if index then offset_addr else R[n];",
          "        MemU[address,4] = R[t];",
          "        if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register (immediate) calculates an address from a base register value and an immediate offset, and stores a",
          "word from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about",
          "memory accesses see Memory accesses on page F2-2513.",
          "This instruction is used by the alias PUSH (single register). See the Alias conditions on page F7-3104 table for",
          "details of when each alias is preferred."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rt>               For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                   can be used, but this is deprecated.",
          "                   For encoding T1, T2, T3 and T4: is the general-purpose register to be transferred, encoded in the",
          "                   \"Rt\" field.",
          "<Rn>               For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "                   used. The PC can be used, but this is deprecated.",
          "                   For the post-indexed or pre-indexed variant: is the general-purpose base register, encoded in the",
          "                   \"Rn\" field. The SP can be used.",
          "                   For encoding T1, T3 or T4: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-                Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                   encoded in the \"U\" field. It can have the following values:",
          "                   -            when U = 0",
          "                   +            when U = 1",
          "+                  Specifies the offset is added to the base register.",
          "<imm>              For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                   defaulting to 0 and encoded in the \"imm12\" field.",
          "                   For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "                   0 to 255, encoded in the \"imm8\" field.",
          "                   For the post-indexed or pre-indexed variant: is the 12-bit unsigned immediate byte offset, in the",
          "                   range 0 to 4095, encoded in the \"imm12\" field.",
          "                   For encoding T1 or T2: is the optional positive unsigned immediate byte offset, a multiple of 4, in",
          "                   the same 0 to 124, defaulting to 0 and encoded in the \"imm5\" field as <imm>/4.",
          "        For encoding T3: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "        defaulting to 0 and encoded in the \"imm12\" field.",
          "        For encoding T4: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "        defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE STRT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x06000000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 0 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if t == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STR{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "STR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "223",
      "names": [
        "STR",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "          address = if index then offset_addr else R[n];",
          "          if t == 15 then // Only possible for encoding A1",
          "              data = PCStoreValue();",
          "          else",
          "              data = R[t];",
          "          MemU[address,4] = data;",
          "          if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register (register) calculates an address from a base register value and an offset register value, stores a word",
          "from a register to memory. The offset register value can optionally be shifted. For information about memory",
          "accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "              can be used, but this is deprecated.",
          "              For encoding T1 and T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "              used, but this is deprecated.",
          "              For the offset, post-indexed, pre-indexed or register-offset variant: is the general-purpose base",
          "              register, encoded in the \"Rn\" field.",
          "+/-           Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "              and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "+             Specifies the index register is added to the base register.",
          "<Rm>          Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>       The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "              applied to a register on page F2-2510.",
          "<imm>         If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "              in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE STRBT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x04400000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rb",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt);       n = UInt(Rn); imm32 = ZeroExtend(imm5, 32);",
            "index = TRUE;       add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00007000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8800000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]// <Rt>, <Rn>, <imm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '1' && U == '1' && W == '0' then SEE STRBT;",
            "if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8000800",
          "mnemonics": [
            {
              "constraint": " P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "224",
      "names": [
        "STRB",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)     else (R[n] - imm32);",
          "        address = if index then offset_addr else     R[n];",
          "        MemU[address,1] = R[t]<7:0>;",
          "        if wback then R[n] = offset_addr;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)     else (R[n] - imm32);",
          "        address = if index then offset_addr else     R[n];",
          "        MemU[address,1] = R[t]<7:0>;",
          "        if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Byte (immediate) calculates an address from a base register value and an immediate offset, and stores",
          "a byte from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For information about",
          "memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "     <Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "                     used. The PC can be used, but this is deprecated.",
          "                     For the post-indexed or pre-indexed variant: is the general-purpose base register, encoded in the",
          "                     \"Rn\" field. The SP can be used.",
          "             For encoding T1, T2 or T3: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-          Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "             encoded in the \"U\" field. It can have the following values:",
          "             -            when U = 0",
          "             +            when U = 1",
          "+            Specifies the offset is added to the base register.",
          "<imm>        For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "             defaulting to 0 and encoded in the \"imm12\" field.",
          "             For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "             0 to 255, encoded in the \"imm8\" field.",
          "             For the post-indexed or pre-indexed variant: is the 12-bit unsigned immediate byte offset, in the",
          "             range 0 to 4095, encoded in the \"imm12\" field.",
          "             For encoding T1: is an optional 5-bit unsigned immediate byte offset, in the same 0 to 31, defaulting",
          "             to 0 and encoded in the \"imm5\" field.",
          "             For encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "             defaulting to 0 and encoded in the \"imm12\" field.",
          "             For encoding T3: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "             defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE STRBT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if t == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x06400000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005400",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if t == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "STRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "225",
      "names": [
        "STRB",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "           address = if index then offset_addr else R[n];",
          "           MemU[address,1] = R[t]<7:0>;",
          "           if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Byte (register) calculates an address from a base register value and an offset register value, and stores",
          "a byte from a register to memory. The offset register value can optionally be shifted. For information about memory",
          "accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "              can be used, but this is deprecated.",
          "              For encoding A1, T1, T2: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "              used, but this is deprecated.",
          "              For the offset, post-indexed, pre-indexed or register-offset variant: is the general-purpose base",
          "              register, encoded in the \"Rn\" field.",
          "+/-           Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "              and encoded in the \"U\" field. It can have the following values:",
          "              -            when U = 0",
          "              +            when U = 1",
          "+             Specifies the index register is added to the base register.",
          "<Rm>          Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>       The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "              applied to a register on page F2-2510.",
          "<imm>         If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "              in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm12, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x04600000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == '1');",
            "register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8000e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "226",
      "names": [
        "STRBT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    MemU_unpriv[address,1] = R[t]<7:0>;",
          "    if postindex then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Byte Unprivileged stores a byte from a register to memory. For information about memory accesses",
          "see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "STRBT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or an optionally-shifted register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            For encoding A1: is the general-purpose register to be transferred, encoded in the \"Rt\" field. The PC",
          "                can be used, but this is deprecated.",
          "                For encoding A2 and T1: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "                used.",
          "                For encoding A2 and T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "                + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "                For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "                defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>         The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "                applied to a register on page F2-2510.",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                defaulting to 0 and encoded in the \"imm12\" field.",
          "                For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if Rt<0> == '1' then UNPREDICTABLE;",
            "t = UInt(Rt); t2 = t+1; n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if P == '0' && W == '1' then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;",
            "if t2 == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x004000f0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '0' then SEE \"Related encodings\";",
            "t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn); imm32 = ZeroExtend(imm8:'00', 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if wback && (n == t || n == t2) then UNPREDICTABLE;",
            "if n == 15 || t == 15 || t2 == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xe8400000",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "227",
      "names": [
        "STRD",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "      if ConditionPassed() then",
          "          EncodingSpecificOperations();",
          "          offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);",
          "          address = if index then offset_addr else R[n];",
          "          if address == Align(address, 8) then",
          "              bits(64) data;",
          "              if BigEndian() then",
          "                  data<63:32> = R[t];",
          "                  data<31:0> = R[t2];",
          "    else",
          "        data<31:0> = R[t];",
          "        data<63:32> = R[t2];",
          "    MemA[address,8] = data;",
          "else",
          "    MemA[address,4] = R[t];",
          "    MemA[address+4,4] = R[t2];",
          "if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Dual (immediate) calculates an address from a base register value and an immediate offset, and stores",
          "two words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. For information",
          "about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                This register must be even-numbered and not R14.",
          "                For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rt2>           For encoding A1: is the second general-purpose register to be transferred. This register must be",
          "                <R(t+1)>.",
          "                For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "<Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "                used, but this is deprecated.",
          "                For the offset, post-indexed or pre-indexed variant: is the general-purpose base register, encoded in",
          "                the \"Rn\" field.",
          "+/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                For the post-indexed or pre-indexed variant: is the unsigned immediate byte offset, a multiple of 4,",
          "                in the range 0 to 1020, encoded in the \"imm8\" field as <imm>/4.",
          "                For the post-indexed or pre-indexed variant: is the 8-bit unsigned immediate byte offset, in the range",
          "                0 to 255, encoded in the \"imm4H:imm4L\" field.",
          "                For encoding T1: is the optional unsigned immediate byte offset, a multiple of 4, in the range 0 to",
          "                1020, defaulting to 0 and encoded in the \"imm8\" field as <imm>/4."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rt<0> == '1' then UNPREDICTABLE;",
            "t = UInt(Rt); t2 = t+1; n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if P == '0' && W == '1' then UNPREDICTABLE;",
            "if t2 == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;"
          ],
          "mask": "0x000000f0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "228",
      "names": [
        "STRD",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);",
          "    address = if index then offset_addr else R[n];",
          "    if address == Align(address, 8) then",
          "        bits(64) data;",
          "        if BigEndian() then",
          "            data<63:32> = R[t];",
          "            data<31:0> = R[t2];",
          "        else",
          "            data<31:0> = R[t];",
          "            data<63:32> = R[t2];",
          "        MemA[address,8] = data;",
          "    else",
          "        MemA[address,4] = R[t];",
          "        MemA[address+4,4] = R[t2];",
          "    if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Dual (register) calculates an address from a base register value and a register offset, and stores two",
          "words from two registers to memory. It can use offset, post-indexed, or pre-indexed addressing. For information",
          "about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rt>               Is the first general-purpose register to be transferred, encoded in the \"Rt\" field. This register must",
          "                        be even-numbered and not R14.",
          "     <Rt2>              Is the second general-purpose register to be transferred. This register must be <R(t+1)>.",
          "     <Rn>               For the offset variant: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "                        used, but this is deprecated.",
          "                        For the post-indexed and pre-indexed variant: is the general-purpose base register, encoded in the",
          "                        \"Rn\" field.",
          "+/-          Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "             and encoded in the \"U\" field. It can have the following values:",
          "             -            when U = 0",
          "             +            when U = 1",
          "<Rm>         Is the general-purpose index register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn); imm32 = Zeros(32); // Zero offset",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0x01800f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, {#}<imm>}]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8:'00', 32);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0xe8400000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, #<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "229",
      "names": [
        "STREX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n] + imm32;",
          "    if AArch32.ExclusiveMonitorsPass(address,4) then",
          "        MemA[address,4] = R[t];",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Exclusive calculates an address from a base register value and an immediate offset, stores a word",
          "from a register to the calculated address if the PE has exclusive access to the memory at that address, and returns a",
          "status value of 0 if the store was successful, or of 1 if no store was performed.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                        written, encoded in the \"Rd\" field. The value returned is:",
          "                        0            If the operation updates memory.",
          "                        1            If the operation fails to update memory.",
          "     <Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "<imm>             For encoding A1: the immediate offset added to the value of <Rn> to calculate the address. <imm> can",
          "                  only be 0 or omitted.",
          "                  For encoding T1: the immediate offset added to the value of <Rn> to calculate the address. <imm> can",
          "                  be omitted, meaning an offset of 0. Values are multiples of 4 in the range 0-1020.",
          "Aborts and alignment",
          "If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "        Memory is not updated.",
          "        <Rd> is not updated.",
          "A non word-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject to",
          "the following rules:",
          "        If AArch32.ExclusiveMonitorsPass() returns TRUE, the exception is generated.",
          "        Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.",
          "If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0x01c00f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00f40",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "230",
      "names": [
        "STREXB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    if AArch32.ExclusiveMonitorsPass(address,1) then",
          "        MemA[address,1] = R[t]<7:0>;",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Exclusive Byte derives an address from a base register value, stores a byte from a register to the",
          "derived address if the executing PE has exclusive access to the memory at that address, and returns a status value",
          "of 0 if the store was successful, or of 1 if no store was performed.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                        written, encoded in the \"Rd\" field. The value returned is:",
          "                        0            If the operation updates memory.",
          "                        1            If the operation fails to update memory.",
          "     <Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "Aborts",
          "If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "        Memory is not updated.",
          "        <Rd> is not updated.",
          "If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 0 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); t2 = t+1; n = UInt(Rn);",
            "if d == 15 || Rt<0> == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t || d == t2 then UNPREDICTABLE;"
          ],
          "mask": "0x01a00f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt2",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); t2 = UInt(Rt2); n = UInt(Rn);",
            "if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if d == n || d == t || d == t2 then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "231",
      "names": [
        "STREXD",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    // Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.",
          "    value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];",
          "    if AArch32.ExclusiveMonitorsPass(address,8) then",
          "        MemA[address,8] = value; R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Exclusive Doubleword derives an address from a base register value, stores a 64-bit doubleword from",
          "two registers to the derived address if the executing PE has exclusive access to the memory at that address, and",
          "returns a status value of 0 if the store was successful, or of 1 if no store was performed.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                        written, encoded in the \"Rd\" field. The value returned is:",
          "                        0            If the operation updates memory.",
          "                        1            If the operation fails to update memory.",
          "                         <Rd> must not be the same as <Rn>, <Rt>, or <Rt2>.",
          "<Rt>              For encoding A1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                  <Rt> must be even-numbered and not R14.",
          "                  For encoding T1: is the first general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rt2>             For encoding A1: is the second general-purpose register to be transferred. <Rt2> must be <R(t+1)>.",
          "                  For encoding T1: is the second general-purpose register to be transferred, encoded in the \"Rt2\" field.",
          "<Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "Aborts and alignment",
          "If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "        Memory is not updated.",
          "        <Rd> is not updated.",
          "A non doubleword-aligned memory address causes an Alignment fault Data Abort exception to be generated,",
          "subject to the following rules:",
          "        If AArch32.ExclusiveMonitorsPass() returns TRUE, the exception is generated.",
          "        Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.",
          "If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) 1 1 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0x01e00f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); t = UInt(Rt); n = UInt(Rn);",
            "if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if d == n || d == t then UNPREDICTABLE;"
          ],
          "mask": "0xe8c00f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "232",
      "names": [
        "STREXH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    address = R[n];",
          "    if AArch32.ExclusiveMonitorsPass(address,2) then",
          "        MemA[address,2] = R[t]<15:0>;",
          "        R[d] = ZeroExtend('0');",
          "    else",
          "        R[d] = ZeroExtend('1');"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Exclusive Halfword derives an address from a base register value, stores a halfword from a register",
          "to the derived address if the executing PE has exclusive access to the memory at that address, and returns a status",
          "value of 0 if the store was successful, or of 1 if no store was performed.",
          "For more information about support for shared memory see Synchronization and semaphores on page E2-2456. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>                See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>               Is the destination general-purpose register into which the status result of the store exclusive is",
          "                        written, encoded in the \"Rd\" field. The value returned is:",
          "                        0            If the operation updates memory.",
          "                        1            If the operation fails to update memory.",
          "     <Rt>               Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>              Is the general-purpose base register, encoded in the \"Rn\" field.",
          "Aborts and alignment",
          "If a synchronous Data Abort exception is generated by the execution of this instruction:",
          "        Memory is not updated.",
          "        <Rd> is not updated.",
          "A non halfword-aligned memory address causes an Alignment fault Data Abort exception to be generated, subject",
          "to the following rules:",
          "        If AArch32.ExclusiveMonitorsPass() returns TRUE, the exception is generated.",
          "        Otherwise, it is IMPLEMENTATION DEFINED whether the exception is generated.",
          "If AArch32.ExclusiveMonitorsPass() returns FALSE and the memory address, if accessed, would generate a",
          "synchronous Data Abort exception, it is IMPLEMENTATION DEFINED whether the exception is generated."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE STRHT;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "if t == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x004000b0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 0 0 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "Rb",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt);       n = UInt(Rn); imm32 = ZeroExtend(imm5:'0', 32);",
            "index = TRUE;       add = TRUE; wback = FALSE;"
          ],
          "mask": "0x00008000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm12, 32);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8a00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]// <Rt>, <Rn>, <imm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if P == '1' && U == '1' && W == '0' then SEE STRHT;",
            "if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); imm32 = ZeroExtend(imm8, 32);",
            "index = (P == '1'); add = (U == '1'); wback = (W == '1');",
            "if t == 15 || (wback && n == t) then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8200800",
          "mnemonics": [
            {
              "constraint": " P = 1 && U = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "233",
      "names": [
        "STRH",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if CurrentInstrSet() == InstrSet_A32 then",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)       else (R[n] - imm32);",
          "        address = if index then offset_addr else       R[n];",
          "        MemU[address,2] = R[t]<15:0>;",
          "        if wback then R[n] = offset_addr;",
          "else",
          "    if ConditionPassed() then",
          "        EncodingSpecificOperations();",
          "        offset_addr = if add then (R[n] + imm32)       else (R[n] - imm32);",
          "        address = if index then offset_addr else       R[n];",
          "        MemU[address,2] = R[t]<15:0>;",
          "        if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Halfword (immediate) calculates an address from a base register value and an immediate offset, and",
          "stores a halfword from a register to memory. It can use offset, post-indexed, or pre-indexed addressing. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rt>          Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>          For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "              used, but this is deprecated.",
          "              For encoding A1, T1, T2, T3: is the general-purpose base register, encoded in the \"Rn\" field.",
          "     +/-             Specifies the offset is added to or subtracted from the base register, defaulting to + if omitted and",
          "                     encoded in the \"U\" field. It can have the following values:",
          "                     -            when U = 0",
          "                     +            when U = 1",
          "     +               Specifies the offset is added to the base register.",
          "     <imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                     For the post-indexed or pre-indexed variant: is a 8-bit unsigned immediate byte offset, in the range",
          "                     0 to 255, encoded in the \"imm8\" field.",
          "                     For the post-indexed or pre-indexed variant: is the 8-bit unsigned immediate byte offset, in the range",
          "                     0 to 255, encoded in the \"imm4H:imm4L\" field.",
          "                     For encoding T1: is the optional positive unsigned immediate byte offset, a multiple of 2, in the",
          "                     same 0 to 62 defaulting to 0 and encoded in the \"imm5\" field as <imm>/2.",
          "                     For encoding T2: is an optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                     defaulting to 0 and encoded in the \"imm12\" field.",
          "                     For encoding T3: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                     defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "P",
              "size": 1,
              "type": 3
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "W",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if P == '0' && W == '1' then SEE STRHT;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = (P == '1'); add = (U == '1'); wback = (P == '0') || (W == '1');",
            "(shift_t, shift_n) = (SRType_LSL, 0);",
            "if t == 15 || m == 15 then UNPREDICTABLE;",
            "if wback && (n == 15 || n == t) then UNPREDICTABLE;"
          ],
          "mask": "0x000000b0",
          "mnemonics": [
            {
              "constraint": " P = 1 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]"
                }
              ],
              "name": "Offset variant"
            },
            {
              "constraint": " P = 0 && W = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "Post-indexed variant"
            },
            {
              "constraint": " P = 1 && W = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
                }
              ],
              "name": "Pre-indexed variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 1 0 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00005200",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0 0 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm);",
            "index = TRUE; add = TRUE; wback = FALSE;",
            "(shift_t, shift_n) = (SRType_LSL, UInt(imm2));",
            "if t == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8200000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]// <Rt>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "STRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "234",
      "names": [
        "STRH",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if index then offset_addr else R[n];",
          "    MemU[address,2] = R[t]<15:0>;",
          "    if wback then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Halfword (register) calculates an address from a base register value and an offset register value, and",
          "stores a halfword from a register to memory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For",
          "information about memory accesses see Memory accesses on page F2-2513."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The PC can be",
          "                used, but this is deprecated.",
          "                For the offset, post-indexed, pre-indexed or register-offset variant: is the general-purpose base",
          "                register, encoded in the \"Rn\" field.",
          "+/-             Specifies the index register is added to or subtracted from the base register, defaulting to + if omitted",
          "                and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "+               Specifies the index register is added to the base register.",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<imm>           If present, the size of the left shift to apply to the value from <Rm>, in the range 1-3. <imm> is encoded",
          "                in imm2. If absent, no shift is specified and imm2 is encoded as 0b00."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm4H",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4L",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm4H:imm4L, 32);",
            "if t == 15 || n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x006000b0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0) 1 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE;                   add = (U == '1');",
            "register_form = TRUE;",
            "if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x002000b0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8200e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "235",
      "names": [
        "STRHT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then R[m] else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    MemU_unpriv[address,2] = R[t]<15:0>;",
          "    if postindex then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Halfword Unprivileged stores a halfword from a register to memory. For information about memory",
          "accesses see Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "STRHT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or a register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            Is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "<Rn>            Is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "                + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "                For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "                defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -            when U = 0",
          "                +            when U = 1",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm4H:imm4L\" field.",
          "                For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); postindex = TRUE; add = (U == '1');",
            "register_form = FALSE; imm32 = ZeroExtend(imm12, 32);",
            "if n == 15 || n == t then UNPREDICTABLE;"
          ],
          "mask": "0x04200000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "U",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1 0",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "t = UInt(Rt); n = UInt(Rn); m = UInt(Rm); postindex = TRUE; add = (U == '1');",
            "register_form = TRUE; (shift_t, shift_n) = DecodeImmShift(type, imm5);",
            "if n == 15 || n == t || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06200000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 0 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rt",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then UNDEFINED;",
            "t = UInt(Rt); n = UInt(Rn); postindex = FALSE; add = TRUE;",
            "register_form = FALSE; imm32 = ZeroExtend(imm8, 32);",
            "if t == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf8400e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "STRT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "236",
      "names": [
        "STRT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode",
          "    EncodingSpecificOperations();",
          "    offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;",
          "    offset_addr = if add then (R[n] + offset) else (R[n] - offset);",
          "    address = if postindex then R[n] else offset_addr;",
          "    if t == 15 then // Only possible for encodings A1 and A2",
          "        data = PCStoreValue();",
          "    else",
          "        data = R[t];",
          "    MemU_unpriv[address,4] = data;",
          "    if postindex then R[n] = offset_addr;"
        ]
      },
      "summary": {
        "lines": [
          "Store Register Unprivileged stores a word from a register to memory. For information about memory accesses see",
          "Memory accesses on page F2-2513.",
          "The memory access is restricted as if the PE were running in User mode. This makes no difference if the PE is",
          "actually running in User mode.",
          "STRT is UNPREDICTABLE in Hyp mode.",
          "The T32 instruction uses an offset addressing mode, that calculates the address used for the memory access from a",
          "base register value and an immediate offset, and leaves the base register unchanged.",
          "The A32 instruction uses a post-indexed addressing mode, that uses a base register value as the address for the",
          "memory access, and calculates a new address from a base register value and an offset and writes it back to the base",
          "register. The offset can be an immediate value or an optionally-shifted register value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rt>            For the offset variant: is the general-purpose register to be transferred, encoded in the \"Rt\" field.",
          "                For the post-indexed variant: is the general-purpose register to be transferred, encoded in the \"Rt\"",
          "                field. The PC can be used, but this is deprecated.",
          "<Rn>            For encoding A1: is the general-purpose base register, encoded in the \"Rn\" field. The SP can be",
          "                used.",
          "                For encoding A2 and T1: is the general-purpose base register, encoded in the \"Rn\" field.",
          "+/-             For encoding A1: specifies the offset is added to or subtracted from the base register, defaulting to",
          "                + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -           when U = 0",
          "                +           when U = 1",
          "                For encoding A2: specifies the index register is added to or subtracted from the base register,",
          "                defaulting to + if omitted and encoded in the \"U\" field. It can have the following values:",
          "                -           when U = 0",
          "                +           when U = 1",
          "<Rm>            Is the general-purpose index register, encoded in the \"Rm\" field.",
          "<shift>         The shift to apply to the value read from <Rm>. If absent, no shift is applied. Otherwise, see Shifts",
          "                applied to a register on page F2-2510.",
          "+               Specifies the offset is added to the base register.",
          "<imm>           For encoding A1: is the optional 12-bit unsigned immediate byte offset, in the range 0 to 4095,",
          "                defaulting to 0 and encoded in the \"imm12\" field.",
          "                For encoding T1: is an optional 8-bit unsigned immediate byte offset, in the range 0 to 255,",
          "                defaulting to 0 and encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 1 0 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [],
          "mask": "0x024f0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when imm12==000000000000.",
                      "target": "ADR{<c>}{<q>} <Rd>, <label>"
                    }
                  ],
                  "value": "SUB{<c>}{<q>} <Rd>, PC, #<const>"
                }
              ],
              "name": "A2 variant"
            }
          ],
          "name": "A2",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 1 0 1 0 1 1 1 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [],
          "mask": "0xf2af0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [
                    {
                      "constraint": "and is the preferred disassembly when i:imm3:imm8 = '000000000000'.",
                      "target": "ADR{<c>}{<q>} <Rd>, <label>"
                    }
                  ],
                  "value": "SUB{<c>}{<q>} <Rd>, PC, #<imm12>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "237",
      "names": [
        "SUB",
        "(immediate from PC)"
      ],
      "operation": {
        "lines": [
          "The description of ADR gives the operational pseudocode for this instruction."
        ]
      },
      "summary": {
        "lines": [
          "Subtract from PC subtracts an immediate value from the Align(PC, 4) value to form a PC-relative address, and",
          "writes the result to the destination register. ARM recommends that, where possible, software avoids using this alias",
          "This instruction is an alias of the ADR instruction. This means that:",
          "         The encodings in this description are named to match the encodings of ADR.",
          "         The description of ADRgives the operational pseudocode for this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                  See Standard assembler syntax fields on page F2-2506.",
          "<q>                  See Standard assembler syntax fields on page F2-2506.",
          "<Rd>                 For encoding A2: is the general-purpose destination register, encoded in the \"Rd\" field. If the PC is",
          "                     used, the instruction is a branch to the address calculated by the operation. This is an interworking",
          "                     branch, see Pseudocode description of operations on the AArch32 general-purpose registers and the",
          "                     PC on page E1-2378.",
          "                     For encoding T2: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<label>              For encoding A1 and A2: the label of an instruction or literal data item whose address is to be loaded",
          "                     into <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of",
          "                     the ADR instruction to this label. If the offset is zero or positive, encoding A1 is used, with imm32 equal",
          "                     to the offset. If the offset is negative, encoding A2 is used, with imm32 equal to the size of the offset.",
          "                     That is, the use of encoding A2 indicates that the required offset is minus the value of imm32.",
          "                     Permitted values of the size of the offset are any of the constants described in Modified immediate",
          "                     constants in A32 instructions on page F4-2559.",
          "                     For encoding T1: the label of an instruction or literal data item whose address is to be loaded into",
          "                     <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of the",
          "                     ADR instruction to this label. Permitted values of the size of the offset are multiples of 4 in the range",
          "                     0 to 1020.",
          "                     For encoding T2 and T3: the label of an instruction or literal data item whose address is to be loaded",
          "                     into <Rd>. The assembler calculates the required value of the offset from the Align(PC, 4) value of",
          "                     the ADR instruction to this label. If the offset is zero or positive, encoding T3 is used, with imm32 equal",
          "                     to the offset. If the offset is negative, encoding T2 is used, with imm32 equal to the size of the offset.",
          "                     That is, the use of encoding T2 indicates that the required offset is minus the value of imm32.",
          "                     Permitted values of the size of the offset are 0-4095.",
          "     <imm12>         Is a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.",
          "     <const>         An immediate value. See Modified immediate constants in A32 instructions on page F4-2559 for the",
          "                     range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' && S == '0' then SEE ADR;",
            "if Rn == '1101' then SEE SUB (SP minus immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1');              imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x02400000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SUB variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SUBS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);    n = UInt(Rn);     setflags = !InITBlock();      imm32 = ZeroExtend(imm3, 32);"
          ],
          "mask": "0x00001e00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB<c>{<q>} <Rd>, <Rn>, #<imm3>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "SUBS{<q>} <Rd>, <Rn>, #<imm3>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "0 0 1 1 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "Rdn",
              "size": 3,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rdn);    n = UInt(Rdn);     setflags = !InITBlock();        imm32 = ZeroExtend(imm8, 32);"
          ],
          "mask": "0x00003800",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB<c>{<q>} <Rdn>, #<imm8>// Inside IT block, and <Rdn>, <imm8> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SUB<c>{<q>} {<Rdn>,} <Rdn>, #<imm8>// Inside IT block, and <Rdn>, <imm8> cannot be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SUBS{<q>} <Rdn>, #<imm8>// Outside IT block, and <Rdn>, <imm8> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SUBS{<q>} {<Rdn>,} <Rdn>, #<imm8>// Outside IT block, and <Rdn>, <imm8> cannot be represented in T1"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 1 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMP (immediate);",
            "if Rn == '1101' then SEE SUB (SP minus immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf1a00000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB<c>.W {<Rd>,} <Rn>, #<const>// Inside IT block, and <Rd>, <Rn>, <const> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SUB variant"
            },
            {
              "constraint": " S = 1 && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS.W {<Rd>,} <Rn>, #<const>// Outside IT block, and <Rd>, <Rn>, <const> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
                }
              ],
              "name": "SUBS variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 1 0 1 0",
              "size": 6,
              "type": 5
            },
            {
              "name": "!=11x1",
              "size": 4,
              "type": 4
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE ADR;",
            "if Rn == '1101' then SEE SUB (SP minus immediate);",
            "d = UInt(Rd); n = UInt(Rn); setflags = FALSE; imm32 = ZeroExtend(i:imm3:imm8, 32);",
            "if d == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf2a00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>// <imm12> cannot be represented in T1, T2, or T3"
                },
                {
                  "aliases": [],
                  "value": "SUBW{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>// <imm12> can be represented in T1, T2, or T3"
                }
              ],
              "name": "T4 variant"
            }
          ],
          "name": "T4",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 1 0 1 (1) (1) (1) (0) 1 0 (0) 0 (1) (1) (1) (1)",
              "size": 24,
              "type": 5
            },
            {
              "name": "!=00000000",
              "size": 8,
              "type": 4
            }
          ],
          "decode": [
            "if Rn == '1110' && IsZero(imm8) then SEE ERET;",
            "d = 15; n = UInt(Rn); setflags = TRUE; imm32 = ZeroExtend(imm8, 32);",
            "if n != 14 then UNPREDICTABLE;",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xf3de8f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} PC, LR, #<imm8>"
                }
              ],
              "name": "T5 variant"
            }
          ],
          "name": "T5",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "238",
      "names": [
        "SUB",
        "SUBS (immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');",
          "    if d == 15 then",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract (immediate) subtracts an immediate value from a register value, and writes the result to the destination",
          "register.",
          "If the destination register is not the PC, the SUBS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. If the",
          "destination register is the PC:",
          "          The SUB variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The SUBS variant of the instruction performs an exception return without the use of the stack. In this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode, except for encoding T5 with <imm8> set to zero, which is",
          "the encoding for the ERET instruction, see ERET.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rdn>         Is the general-purpose source and destination register, encoded in the \"Rdn\" field.",
          "<imm8>        For encoding T2: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "              For encoding T5: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "              If <Rn> is the LR, and zero is used, see ERET.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the same as <Rn>. If the PC is used:",
          "                     For the SUB variant, the instruction is a branch to the address calculated by the operation.",
          "                      This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                      general-purpose registers and the PC on page E1-2378.",
          "                     For the SUBS variant, the instruction performs an exception return, that restores PSTATE",
          "                      from SPSR_<current_mode>. ARM deprecates use of this instruction unless <Rn> is the LR.",
          "              For encoding T1, T3 and T4: is the general-purpose destination register, encoded in the \"Rd\" field.",
          "              If omitted, this register is the same as <Rn>.",
          "<Rn>          For encoding A1 and T4: is the general-purpose source register, encoded in the \"Rn\" field. If the SP",
          "              is used, see SUB, SUBS (SP minus immediate). If the PC is used, see ADR.",
          "              For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "              For encoding T3: is the general-purpose source register, encoded in the \"Rn\" field. If the SP is used,",
          "              see SUB, SUBS (SP minus immediate).",
          "<imm3>        Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"imm3\" field.",
          "     <imm12>         Is a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.",
          "     <const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                     page F4-2559 for the range of values.",
          "                     For encoding T3: an immediate value. See Modified immediate constants in T32 instructions on",
          "                     page F3-2530 for the range of values.",
          "     In the T32 instruction set, MOVS{<c>}{<q>} PC, LR is a pseudo-instruction for SUBS{<c>}{<q>} PC, LR, #0."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1101' then SEE SUB (SP minus register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x00400000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SUB, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUB, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SUBS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUBS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 0 0 1 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);              setflags = !InITBlock();",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00001a00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB<c>{<q>} <Rd>, <Rn>, <Rm>// Inside IT block"
                },
                {
                  "aliases": [],
                  "value": "SUBS{<q>} {<Rd>,} <Rn>, <Rm>// Outside IT block"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 1 0 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "!=1101",
              "size": 4,
              "type": 4
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMP (register);",
            "if Rn == '1101' then SEE SUB (SP minus register);",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xeba00000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SUB, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB<c>.W {<Rd>,} <Rn>, <Rm>// Inside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUB, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && Rd != 1111 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "SUBS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11) && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS.W {<Rd>,} <Rn>, <Rm>// Outside IT block, and <Rd>, <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUBS, shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "239",
      "names": [
        "SUB",
        "SUBS (register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract (register) subtracts an optionally-shifted register value from a register value, and writes the result to the",
          "destination register.",
          "If the destination register is not the PC, the SUBS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. However,",
          "when the destination register is the PC:",
          "         The SUB variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "         The SUBS variant of the instruction performs an exception return without the use of the stack. ARM",
          "deprecates use of this instruction. However, in this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "             this register is the same as <Rn>. ARM deprecates using the PC as the destination register, but if the",
          "             PC is used:",
          "                    For the SUB variant, the instruction is a branch to the address calculated by the operation.",
          "                     This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                     general-purpose registers and the PC on page E1-2378.",
          "                    For the SUBS variant, the instruction performs an exception return, that restores PSTATE",
          "                     from SPSR_<current_mode>.",
          "             For encoding T1 and T2: is the general-purpose destination register, encoded in the \"Rd\" field. If",
          "             omitted, this register is the same as <Rn>.",
          "<Rn>         For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "             be used. If the SP is used, see SUB, SUBS (SP minus register).",
          "             For encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "             For encoding T2: is the first general-purpose source register, encoded in the \"Rn\" field. If the SP is",
          "             used, see SUB, SUBS (SP minus register).",
          "<Rm>         For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "             can be used.",
          "             For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>      Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "             the following values:",
          "             LSL          when type = 00",
          "             LSR          when type = 01",
          "             ASR          when type = 10",
          "             ROR          when type = 11",
          "<amount>     Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "             LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "setflags = (S == '1'); shift_t = DecodeRegShift(type);",
            "if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00400010",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "240",
      "names": [
        "SUB",
        "SUBS (register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');",
          "    R[d] = result;",
          "    if setflags then",
          "        PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract (register-shifted register) subtracts a register-shifted register value from a register value, and writes the",
          "result to the destination register. It can optionally update the condition flags based on the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 0 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd);       setflags = (S == '1');   imm32 = A32ExpandImm(imm12);"
          ],
          "mask": "0x024d0000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "SUB variant"
            },
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "SUBS variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 0 0 0 1",
              "size": 9,
              "type": 5
            },
            {
              "name": "imm7",
              "size": 7,
              "type": 2
            }
          ],
          "decode": [
            "d = 13;    setflags = FALSE;     imm32 = ZeroExtend(imm7:'00', 32);"
          ],
          "mask": "0x0000b080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {SP,} SP, #<imm7>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 1 1 0 1",
              "size": 5,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMP (immediate);",
            "d = UInt(Rd); setflags = (S == '1'); imm32 = T32ExpandImm(i:imm3:imm8);",
            "if d == 15 && !setflags then UNPREDICTABLE;"
          ],
          "mask": "0xf1ad0000",
          "mnemonics": [
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}.W {<Rd>,} SP, #<const>// <Rd>, <const> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "SUB variant"
            },
            {
              "constraint": " S = 1 && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} SP, #<const>"
                }
              ],
              "name": "SUBS variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "1 0 1 0 1 0 1 1 0 1 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "d = UInt(Rd); setflags = FALSE;      imm32 = ZeroExtend(i:imm3:imm8, 32);",
            "if d == 15 then UNPREDICTABLE;"
          ],
          "mask": "0xf2ad0000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, #<imm12>// <imm12> cannot be represented in T1, T2, or T3"
                },
                {
                  "aliases": [],
                  "value": "SUBW{<c>}{<q>} {<Rd>,} SP, #<imm12>// <imm12> can be represented in T1, T2, or T3"
                }
              ],
              "name": "T3 variant"
            }
          ],
          "name": "T3",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "241",
      "names": [
        "SUB",
        "SUBS (SP minus immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result, nzcv) = AddWithCarry(SP, NOT(imm32), '1');",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract from SP (immediate) subtracts an immediate value from the SP value, and writes the result to the",
          "destination register.",
          "If the destination register is not the PC, the SUBS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. If the",
          "destination register is the PC:",
          "          The SUB variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The SUBS variant of the instruction performs an exception return without the use of the stack. ARM",
          "deprecates use of this instruction. However, in this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<imm7>        Is the unsigned immediate, a multiple of 4, in the range 0 to 508, encoded in the \"imm7\" field as",
          "              <imm7>/4.",
          "<Rd>          For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "              this register is the SP. If the PC is used:",
          "                      For the SUB variant, the instruction is a branch to the address calculated by the operation.",
          "                       This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                       general-purpose registers and the PC on page E1-2378.",
          "                            For the SUBS variant, the instruction performs an exception return, that restores PSTATE",
          "                             from SPSR_<current_mode>. ARM deprecates use of this instruction unless <Rn> is the LR.",
          "                     For encoding T2 and T3: is the general-purpose destination register, encoded in the \"Rd\" field. If",
          "                     omitted, this register is the SP.",
          "     <imm12>         Is a 12-bit unsigned immediate, in the range 0 to 4095, encoded in the \"i:imm3:imm8\" field.",
          "     <const>         For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                     page F4-2559 for the range of values.",
          "                     For encoding T2: an immediate value. See Modified immediate constants in T32 instructions on",
          "                     page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x004d0000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX"
                }
              ],
              "name": "SUB, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUB, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX"
                }
              ],
              "name": "SUBS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUBS, shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 1 1 0 1",
              "size": 11,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "1 1 0 1 (0)",
              "size": 5,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rd == '1111' && S == '1' then SEE CMP (register);",
            "d = UInt(Rd); m = UInt(Rm); setflags = (S == '1');",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xebad0000",
          "mnemonics": [
            {
              "constraint": " S = 0 && imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX"
                }
              ],
              "name": "SUB, rotate right with extend variant"
            },
            {
              "constraint": " S = 0 && !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUB{<c>}.W {<Rd>,} SP, <Rm>// <Rd>, <Rm> can be represented in T1 or T2"
                },
                {
                  "aliases": [],
                  "value": "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUB, shift or rotate by value variant"
            },
            {
              "constraint": " S = 1 && imm3 = 000 && Rd != 1111 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX"
                }
              ],
              "name": "SUBS, rotate right with extend variant"
            },
            {
              "constraint": " S = 1 && !(imm3 == 000 && imm2 == 00 && type == 11) && Rd != 1111.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "SUBS, shift or rotate by value variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "242",
      "names": [
        "SUB",
        "SUBS (SP minus register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);",
          "    (result, nzcv) = AddWithCarry(SP, NOT(shifted), '1');",
          "    if d == 15 then          // Can only occur for A32 encoding",
          "        if setflags then",
          "            ALUExceptionReturn(result);",
          "        else",
          "            ALUWritePC(result);",
          "    else",
          "        R[d] = result;",
          "        if setflags then",
          "            PSTATE.<N,Z,C,V> = nzcv;"
        ]
      },
      "summary": {
        "lines": [
          "Subtract from SP (register) subtracts an optionally-shifted register value from the SP value, and writes the result to",
          "the destination register.",
          "If the destination register is not the PC, the SUBS variant of the instruction updates the condition flags based on the",
          "result.",
          "The field descriptions for <Rd> identify the encodings where the PC is permitted as the destination register. If the",
          "destination register is the PC:",
          "          The SUB variant of the instruction is an interworking branch, see Pseudocode description of operations on",
          "the AArch32 general-purpose registers and the PC on page E1-2378.",
          "          The SUBS variant of the instruction performs an exception return without the use of the stack. ARM",
          "deprecates use of this instruction. However, in this case:",
          "        The PE branches to the address written to the PC, and restores PSTATE from SPSR_<current_mode>.",
          "        The PE checks SPSR_<current_mode> for an illegal return event. See Illegal return events from",
          "AArch32 state on page G1-3845.",
          "        The instruction is UNDEFINED in Hyp mode.",
          "        The instruction is CONSTRAINED UNPREDICTABLE in User mode and System mode."
        ]
      },
      "symbols": {
        "lines": [
          "     <c>             See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rd>            For encoding A1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                     this register is the SP. ARM deprecates using the PC as the destination register, but if the PC is used:",
          "                            For the SUB variant, the instruction is a branch to the address calculated by the operation.",
          "                             This is an interworking branch, see Pseudocode description of operations on the AArch32",
          "                             general-purpose registers and the PC on page E1-2378.",
          "                            For the SUBS variant, the instruction performs an exception return, that restores PSTATE",
          "                             from SPSR_<current_mode>.",
          "                     For encoding T1: is the general-purpose destination register, encoded in the \"Rd\" field. If omitted,",
          "                     this register is the SP.",
          "     <Rm>            For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                     can be used.",
          "             For encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>      Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "             the following values:",
          "             LSL         when type = 00",
          "             LSR         when type = 01",
          "             ASR         when type = 10",
          "             ROR         when type = 11",
          "<amount>     Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "             LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm24",
              "size": 24,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm24, 32);",
            "// imm32 is for assembly/disassembly. SVC handlers in some",
            "// systems interpret imm24 in software, for example to determine the required service."
          ],
          "mask": "0x0f000000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SVC{<c>}{<q>} {#}<imm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 0 1 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm8, 32);",
            "// imm32 is for assembly/disassembly. SVC handlers in some",
            "// systems interpret imm8 in software, for example to determine the required service."
          ],
          "mask": "0x0000df00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SVC{<c>}{<q>} {#}<imm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        }
      ],
      "id": "243",
      "names": [
        "SVC",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    AArch32.CallSupervisor(imm32<15:0>);"
        ]
      },
      "summary": {
        "lines": [
          "Supervisor Call causes a Supervisor Call exception. For more information, see Supervisor Call (SVC) exception on",
          "page G1-3863.",
          "Note",
          "SVC was previously called SWI, Software Interrupt, and this name is still found in some documentation.",
          "Software can use this instruction as a call to an operating system to provide a service.",
          "In the following cases, the Supervisor Call exception generated by the SVC instruction is taken to Hyp mode:",
          "          If the SVC is executed in Hyp mode.",
          "          If HCR.TGE is set to 1, and the SVC is executed in Non-secure User mode. For more information, see",
          "Supervisor Call exception, when HCR.TGE is set to 1 on page G1-3842",
          "In these cases, the HSR identifies that the exception entry was caused by a Supervisor Call exception, EC value 0x11,",
          "see Use of the HSR on page G4-4159. The immediate field in the HSR:",
          "          If the SVC is unconditional:",
          "        For the T32 instruction, is the zero-extended value of the imm8 field.",
          "        For the A32 instruction, is the least-significant 16 bits the imm24 field.",
          "          If the SVC is conditional, is UNKNOWN."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<imm>        For encoding A1: is a 24-bit unsigned immediate, in the range 0 to 16777215, encoded in the",
          "             \"imm24\" field.",
          "             For encoding T1: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE SXTB;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x006a0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE SXTB;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa40f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "244",
      "names": [
        "SXTAB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = R[n] + SignExtend(rotated<7:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Signed Extend and Add Byte extracts an 8-bit value from a register, sign-extends it to 32 bits, adds the result to the",
          "value in another register, and writes the final result to the destination register. The instruction can specify a rotation",
          "by 0, 8, 16, or 24 bits before extracting the 8-bit value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "        16         when rotate = 10",
          "        24         when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE SXTB16;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x00680070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE SXTB16;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa20f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "245",
      "names": [
        "SXTAB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d]<15:0> = R[n]<15:0> + SignExtend(rotated<7:0>, 16);",
          "    R[d]<31:16> = R[n]<31:16> + SignExtend(rotated<23:16>, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Signed Extend and Add Byte 16 extracts two 8-bit values from a register, sign-extends them to 16 bits each, adds",
          "the results to two 16-bit values from another register, and writes the final results to the destination register. The",
          "instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "        16         when rotate = 10",
          "        24         when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE SXTH;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x006b0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE SXTH;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa00f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "246",
      "names": [
        "SXTAH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = R[n] + SignExtend(rotated<15:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Signed Extend and Add Halfword extracts a 16-bit value from a register, sign-extends it to 32 bits, adds the result",
          "to a value from another register, and writes the final result to the destination register. The instruction can specify a",
          "rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "        16         when rotate = 10",
          "        24         when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06af0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 0 1 0 0 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);   rotation = 0;"
          ],
          "mask": "0x0000b240",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTB{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 0 0 1 1 1 1 1 1 1 1",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa4ff080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTB{<c>}.W {<Rd>,} <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "247",
      "names": [
        "SXTB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = SignExtend(rotated<7:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to 32 bits, and writes the result to the",
          "destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>         Is the general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>     Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "             (omitted) when rotate = 00",
          "             8            when rotate = 01",
          "             16           when rotate = 10",
          "             24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 0 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x068f0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 1 0 1 1 1 1 1 1 1 1",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa2ff080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "248",
      "names": [
        "SXTB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d]<15:0> = SignExtend(rotated<7:0>, 16);",
          "    R[d]<31:16> = SignExtend(rotated<23:16>, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Signed Extend Byte 16 extracts two 8-bit values from a register, sign-extends them to 16 bits each, and writes the",
          "results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the",
          "8-bit values."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               Is the general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "                   16           when rotate = 10",
          "                   24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 0 1 1 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06bf0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 0 1 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);   rotation = 0;"
          ],
          "mask": "0x0000b200",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTH{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 0 0 1 1 1 1 1 1 1 1",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa0ff080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "SXTH{<c>}.W {<Rd>,} <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "SXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "249",
      "names": [
        "SXTH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = SignExtend(rotated<15:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Signed Extend Halfword extracts a 16-bit value from a register, sign-extends it to 32 bits, and writes the result to",
          "the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit",
          "value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>          See Standard assembler syntax fields on page F2-2506.",
          "<q>          See Standard assembler syntax fields on page F2-2506.",
          "<Rd>         Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>         Is the general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>     Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "             (omitted) when rotate = 00",
          "             8            when rotate = 01",
          "             16           when rotate = 10",
          "             24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 0 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) (0) (0) (0) (0) 0 0 0",
              "size": 11,
              "type": 5
            },
            {
              "name": "H",
              "size": 1,
              "type": 3
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); is_tbh = (H == '1');",
            "if m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13",
            "if InITBlock() && !LastInITBlock() then UNPREDICTABLE;"
          ],
          "mask": "0xe8d0f000",
          "mnemonics": [
            {
              "constraint": " H = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TBB{<c>}{<q>} [<Rn>, <Rm>]// Outside or last in IT block"
                }
              ],
              "name": "Byte variant"
            },
            {
              "constraint": " H = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TBH{<c>}{<q>} [<Rn>, <Rm>, LSL #1]// Outside or last in IT block"
                }
              ],
              "name": "Halfword variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "250",
      "names": [
        "TBB",
        "TBH"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if is_tbh then",
          "        halfwords = UInt(MemU[R[n]+LSL(R[m],1), 2]);",
          "    else",
          "        halfwords = UInt(MemU[R[n]+R[m], 1]);",
          "    BranchWritePC(PC + 2*halfwords);"
        ]
      },
      "summary": {
        "lines": [
          "Table Branch Byte or Halfword causes a PC-relative forward branch using a table of single byte or halfword offsets.",
          "A base register provides a pointer to the table, and a second register supplies an index into the table. The branch",
          "length is twice the value returned from the table."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rn>            Is the general-purpose base register holding the address of the table of branch lengths, encoded in",
          "                the \"Rn\" field. The PC can be used. If it is, the table immediately follows this instruction.",
          "<Rm>            For the byte variant: is the general-purpose index register, encoded in the \"Rm\" field. This register",
          "                contains an integer pointing to a single byte in the table. The offset in the table is the value of the",
          "                index.",
          "                For the halfword variant: is the general-purpose index register, encoded in the \"Rm\" field. This",
          "                register contains an integer pointing to a halfword in the table. The offset in the table is twice the",
          "                value of the index."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x03300000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 1 0 0 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0900f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "251",
      "names": [
        "TEQ",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] EOR imm32;",
          "    PSTATE.N = result<31>;",
          "    PSTATE.Z = IsZeroBit(result);",
          "    PSTATE.C = carry;",
          "    // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Test Equivalence (immediate) performs a bitwise exclusive OR operation on a register value and an immediate",
          "value. It updates the condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                   used.",
          "                   For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>            For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                   page F4-2559 for the range of values.",
          "                   For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "                   page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01300000",
          "mnemonics": [
            {
              "constraint": " imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea900f00",
          "mnemonics": [
            {
              "constraint": " imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "252",
      "names": [
        "TEQ",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] EOR shifted;",
          "    PSTATE.N = result<31>;",
          "    PSTATE.Z = IsZeroBit(result);",
          "    PSTATE.C = carry;",
          "    // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Test Equivalence (register) performs a bitwise exclusive OR operation on a register value and an optionally-shifted",
          "register value. It updates the condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "     <q>             See Standard assembler syntax fields on page F2-2506.",
          "     <Rn>            For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "                     be used.",
          "                     For encoding T1: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "     <Rm>            For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "                     can be used.",
          "                     For encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "     <shift>         Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                     the following values:",
          "                     LSL          when type = 00",
          "                     LSR          when type = 01",
          "                     ASR          when type = 10",
          "                     ROR          when type = 11",
          "     <amount>        Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "                     LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "shift_t = DecodeRegShift(type);",
            "if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01300010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TEQ{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "253",
      "names": [
        "TEQ",
        "(register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] EOR shifted;",
          "    PSTATE.N = result<31>;",
          "    PSTATE.Z = IsZeroBit(result);",
          "    PSTATE.C = carry;",
          "    // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Test Equivalence (register-shifted register) performs a bitwise exclusive OR operation on a register value and a",
          "register-shifted register value. It updates the condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);",
            "(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);"
          ],
          "mask": "0x03100000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0",
              "size": 5,
              "type": 5
            },
            {
              "name": "i",
              "size": 1,
              "type": 2
            },
            {
              "name": "0 0 0 0 0 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "n = UInt(Rn);",
            "(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);",
            "if n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf0100f00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, #<const>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "254",
      "names": [
        "TST",
        "(immediate)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = R[n] AND imm32;",
          "    PSTATE.N = result<31>;",
          "    PSTATE.Z = IsZeroBit(result);",
          "    PSTATE.C = carry;",
          "    // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Test (immediate) performs a bitwise AND operation on a register value and an immediate value. It updates the",
          "condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               For encoding A1: is the general-purpose source register, encoded in the \"Rn\" field. The PC can be",
          "                   used.",
          "                   For encoding T1: is the general-purpose source register, encoded in the \"Rn\" field.",
          "<const>            For encoding A1: an immediate value. See Modified immediate constants in A32 instructions on",
          "                   page F4-2559 for the range of values.",
          "                   For encoding T1: an immediate value. See Modified immediate constants in T32 instructions on",
          "                   page F3-2530 for the range of values."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm5);"
          ],
          "mask": "0x01100000",
          "mnemonics": [
            {
              "constraint": " imm5 = 00000 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm5 == 00000 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "0 1 0 0 0 0 1 0 0 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rn",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = (SRType_LSL, 0);"
          ],
          "mask": "0x00004200",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 0 1 0 1 0 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm);",
            "(shift_t, shift_n) = DecodeImmShift(type, imm3:imm2);",
            "if n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xea100f00",
          "mnemonics": [
            {
              "constraint": " imm3 = 000 && imm2 = 00 && type = 11.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, <Rm>, RRX"
                }
              ],
              "name": "Rotate right with extend variant"
            },
            {
              "constraint": " !(imm3 == 000 && imm2 == 00 && type == 11).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}.W <Rn>, <Rm>// <Rn>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
                }
              ],
              "name": "Shift or rotate by value variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "255",
      "names": [
        "TST",
        "(register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] AND shifted;",
          "    PSTATE.N = result<31>;",
          "    PSTATE.Z = IsZeroBit(result);",
          "    PSTATE.C = carry;",
          "    // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Test (register) performs a bitwise AND operation on a register value and an optionally-shifted register value. It",
          "updates the condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>           See Standard assembler syntax fields on page F2-2506.",
          "<q>           See Standard assembler syntax fields on page F2-2506.",
          "<Rn>          For encoding A1: is the first general-purpose source register, encoded in the \"Rn\" field. The PC can",
          "              be used.",
          "              For encoding T1 and T2: is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>          For encoding A1: is the second general-purpose source register, encoded in the \"Rm\" field. The PC",
          "              can be used.",
          "              For encoding T1 and T2: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<shift>       Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "              the following values:",
          "              LSL         when type = 00",
          "              LSR         when type = 01",
          "              ASR         when type = 10",
          "              ROR         when type = 11",
          "<amount>      Is the shift amount, in the range 1 to 31 (when <shift> = LSL or ROR) or 1 to 32 (when <shift> =",
          "              LSR or ASR) encoded in the \"imm5\" field as <amount> modulo 32."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 1 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(0) (0) (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "type",
              "size": 2,
              "type": 0
            },
            {
              "name": "1",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "n = UInt(Rn); m = UInt(Rm); s = UInt(Rs);",
            "shift_t = DecodeRegShift(type);",
            "if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x01100010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "TST{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        }
      ],
      "id": "256",
      "names": [
        "TST",
        "(register-shifted register)"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    shift_n = UInt(R[s]<7:0>);",
          "    (shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);",
          "    result = R[n] AND shifted;",
          "    PSTATE.N = result<31>;",
          "    PSTATE.Z = IsZeroBit(result);",
          "    PSTATE.C = carry;",
          "    // PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Test (register-shifted register) performs a bitwise AND operation on a register value and a register-shifted register",
          "value. It updates the condition flags based on the result, and discards the result."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<type>             Is the type of shift to be applied to the second source register, encoded in the \"type\" field. It can have",
          "                   the following values:",
          "                   LSL         when type = 00",
          "                   LSR         when type = 01",
          "                   ASR         when type = 10",
          "                   ROR         when type = 11",
          "<Rs>               Is the third general-purpose source register holding a shift amount in its bottom 8 bits, encoded in",
          "                   the \"Rs\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06500f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "257",
      "names": [
        "UADD16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);",
          "    sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);",
          "    R[d]<15:0> = sum1<15:0>;",
          "          R[d]<31:16> = sum2<15:0>;",
          "          PSTATE.GE<1:0> = if sum1 >= 0x10000 then '11' else '00';",
          "          PSTATE.GE<3:2> = if sum2 >= 0x10000 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Add 16 performs two 16-bit unsigned integer additions, and writes the results to the destination register.",
          "It sets PSTATE.GE according to the results of the additions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06500f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "258",
      "names": [
        "UADD8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);",
          "    sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);",
          "    sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);",
          "          sum4 = UInt(R[n]<31:24>) +    UInt(R[m]<31:24>);",
          "          R[d]<7:0>   = sum1<7:0>;",
          "          R[d]<15:8> = sum2<7:0>;",
          "          R[d]<23:16> = sum3<7:0>;",
          "          R[d]<31:24> = sum4<7:0>;",
          "          PSTATE.GE<0> = if sum1 >=     0x100   then   '1'   else   '0';",
          "          PSTATE.GE<1> = if sum2 >=     0x100   then   '1'   else   '0';",
          "          PSTATE.GE<2> = if sum3 >=     0x100   then   '1'   else   '0';",
          "          PSTATE.GE<3> = if sum4 >=     0x100   then   '1'   else   '0';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Add 8 performs four unsigned 8-bit integer additions, and writes the results to the destination register. It",
          "sets PSTATE.GE according to the results of the additions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06500f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "259",
      "names": [
        "UASX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);",
          "    sum = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);",
          "          R[d]<15:0> = diff<15:0>;",
          "          R[d]<31:16> = sum<15:0>;",
          "          PSTATE.GE<1:0> = if diff >= 0 then '11' else '00';",
          "          PSTATE.GE<3:2> = if sum >= 0x10000 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs one",
          "unsigned 16-bit integer addition and one unsigned 16-bit subtraction, and writes the results to the destination",
          "register. It sets PSTATE.GE according to the results."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "widthm1",
              "size": 5,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "lsb",
              "size": 5,
              "type": 0
            },
            {
              "name": "1 0 1",
              "size": 3,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn);",
            "lsbit = UInt(lsb); widthminus1 = UInt(widthm1);",
            "if d == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07e00050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "widthm1",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn);",
            "lsbit = UInt(imm3:imm2); widthminus1 = UInt(widthm1);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3c00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "260",
      "names": [
        "UBFX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    msbit = lsbit + widthminus1;",
          "    if msbit <= 31 then",
          "        R[d] = ZeroExtend(R[n]<msbit:lsbit>, 32);",
          "    else",
          "        UNPREDICTABLE;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Bit Field Extract extracts any number of adjacent bits at any position from a register, zero-extends them",
          "to 32 bits, and writes the result to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the general-purpose source register, encoded in the \"Rn\" field.",
          "<lsb>              For encoding A1: is the bit number of the least significant bit in the field, in the range 0 to 31,",
          "                   encoded in the \"lsb\" field.",
          "                   For encoding T1: is the bit number of the least significant bit in the field, in the range 0 to 31,",
          "                   encoded in the \"imm3:imm2\" field.",
          "<width>            Is the width of the field, in the range 1 to 32-<lsb>, encoded in the \"widthm1\" field as <width>-1."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "1 1 1 0 0 1 1 1 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm12:imm4, 32);",
            "// imm32 is for assembly and disassembly only, and is ignored by hardware."
          ],
          "mask": "0xe7f000f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UDF{<c>}{<q>} {#}<imm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 0 1 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "imm8",
              "size": 8,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm8, 32);",
            "// imm32 is for assembly and disassembly only, and is ignored by hardware."
          ],
          "mask": "0x0000de00",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UDF{<c>}{<q>} {#}<imm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 1 1 1 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "imm4",
              "size": 4,
              "type": 2
            },
            {
              "name": "1 0 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "imm12",
              "size": 12,
              "type": 2
            }
          ],
          "decode": [
            "imm32 = ZeroExtend(imm4:imm12, 32);",
            "// imm32 is for assembly and disassembly only, and is ignored by hardware."
          ],
          "mask": "0xf7f0a000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UDF{<c>}.W {#}<imm>// <imm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "UDF{<c>}{<q>} {#}<imm>"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "261",
      "names": [
        "UDF",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    UNDEFINED;"
        ]
      },
      "summary": {
        "lines": [
          "Permanently Undefined generates an Undefined Instruction exception.",
          "The encodings for UDF used in this section are defined as permanently UNDEFINED in the ARMv8-A architecture.",
          "However:",
          "        With the T32 instruction set, ARM deprecates using the UDF instruction in an IT block.",
          "        In the A32 instruction set, UDF is not conditional."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             For encoding A1: see Standard assembler syntax fields on page F2-2506. <c> must be AL or omitted.",
          "                For encoding T1 and T2: see Standard assembler syntax fields on page F2-2506. ARM deprecates",
          "                using any <c> value other than AL.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<imm>           For encoding A1: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                \"imm12:imm4\" field. The PE ignores the value of this constant.",
          "                For encoding T1: is a 8-bit unsigned immediate, in the range 0 to 255, encoded in the \"imm8\" field.",
          "                The PE ignores the value of this constant.",
          "                For encoding T2: is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the",
          "                \"imm4:imm12\" field. The PE ignores the value of this constant."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0730f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1)",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfbb0f0f0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "262",
      "names": [
        "UDIV",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if UInt(R[m]) == 0 then",
          "             if IntegerZeroDivideTrappingEnabled() then",
          "                 GenerateIntegerZeroDivide();",
          "             else",
          "                 result = 0;",
          "         else",
          "             result = RoundTowardsZero(UInt(R[n]) / UInt(R[m]));",
          "         R[d] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Divide divides a 32-bit unsigned integer register value by a 32-bit unsigned integer register value, and",
          "writes the result to the destination register. The condition flags are not affected.",
          "See Divide instructions on page F1-2479 for more information about this instruction."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register holding the dividend, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register holding the divisor, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "263",
      "names": [
        "UHADD16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);",
          "          sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);",
          "          R[d]<15:0> = sum1<16:1>;",
          "          R[d]<31:16> = sum2<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Halving Add 16 performs two unsigned 16-bit integer additions, halves the results, and writes the results",
          "to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "264",
      "names": [
        "UHADD8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);",
          "    sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);",
          "    sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);",
          "          sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);",
          "          R[d]<7:0>   = sum1<8:1>;",
          "          R[d]<15:8> = sum2<8:1>;",
          "          R[d]<23:16> = sum3<8:1>;",
          "          R[d]<31:24> = sum4<8:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Halving Add 8 performs four unsigned 8-bit integer additions, halves the results, and writes the results to",
          "the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "265",
      "names": [
        "UHASX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);",
          "          sum = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);",
          "          R[d]<15:0> = diff<16:1>;",
          "          R[d]<31:16> = sum<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Halving Add and Subtract with Exchange exchanges the two halfwords of the second operand, performs",
          "one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, halves the results, and writes the results",
          "to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfae0f060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "266",
      "names": [
        "UHSAX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);",
          "          diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);",
          "          R[d]<15:0> = sum<16:1>;",
          "          R[d]<31:16> = diff<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Halving Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs",
          "one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, halves the results, and writes the results",
          "to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700f70",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfad0f060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "267",
      "names": [
        "UHSUB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);",
          "          diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);",
          "          R[d]<15:0> = diff1<16:1>;",
          "          R[d]<31:16> = diff2<16:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Halving Subtract 16 performs two unsigned 16-bit integer subtractions, halves the results, and writes the",
          "results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06700ff0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfac0f060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "268",
      "names": [
        "UHSUB8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);",
          "    diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);",
          "    diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);",
          "          diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);",
          "          R[d]<7:0>   = diff1<8:1>;",
          "          R[d]<15:8> = diff2<8:1>;",
          "          R[d]<23:16> = diff3<8:1>;",
          "          R[d]<31:24> = diff4<8:1>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Halving Subtract 8 performs four unsigned 8-bit integer subtractions, halves the results, and writes the",
          "results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 0 1 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x00400090",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 1 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm);",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfbe00060",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "269",
      "names": [
        "UMAAL",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]) + UInt(R[dLo]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Multiply Accumulate Accumulate Long multiplies two unsigned 32-bit values to produce a 64-bit value,",
          "adds two unsigned 32-bit values, and writes the 64-bit result to two registers."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<RdLo>             Is the general-purpose source register holding the first addend and the destination register for the",
          "                   lower 32 bits of the result, encoded in the \"RdLo\" field.",
          "<RdHi>             Is the general-purpose source register holding the second addend and the destination register for the",
          "                   upper 32 bits of the result, encoded in the \"RdHi\" field.",
          "<Rn>               Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x00a00090",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMLALS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfbe00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "270",
      "names": [
        "UMLAL",
        "UMLALS"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]:R[dLo]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;",
          "    if setflags then",
          "        PSTATE.N = result<63>;",
          "        PSTATE.Z = IsZeroBit(result<63:0>);",
          "        // PSTATE.C, PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Multiply Accumulate Long multiplies two unsigned 32-bit values to produce a 64-bit value, and",
          "accumulates this with a 64-bit value.",
          "In A32 instructions, the condition flags can optionally be updated based on the result. Use of this option adversely",
          "affects performance on many implementations."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "     <RdLo>          Is the general-purpose source register holding the lower 32 bits of the addend, and the destination",
          "                     register for the lower 32 bits of the result, encoded in the \"RdLo\" field.",
          "     <RdHi>          Is the general-purpose source register holding the upper 32 bits of the addend, and the destination",
          "                     register for the upper 32 bits of the result, encoded in the \"RdHi\" field.",
          "     <Rn>            Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "     <Rm>            Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 0 0 1 0 0",
              "size": 7,
              "type": 5
            },
            {
              "name": "S",
              "size": 1,
              "type": 3
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = (S == '1');",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0x00800090",
          "mnemonics": [
            {
              "constraint": " S = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMULLS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Flag setting variant"
            },
            {
              "constraint": " S = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "Not flag setting variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdLo",
              "size": 4,
              "type": 1
            },
            {
              "name": "RdHi",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "dLo = UInt(RdLo); dHi = UInt(RdHi); n = UInt(Rn); m = UInt(Rm); setflags = FALSE;",
            "if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;",
            "// ARMv8-A removes UNPREDICTABLE for R13",
            "if dHi == dLo then UNPREDICTABLE;"
          ],
          "mask": "0xfba00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "271",
      "names": [
        "UMULL",
        "UMULLS"
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    result = UInt(R[n]) * UInt(R[m]);",
          "    R[dHi] = result<63:32>;",
          "    R[dLo] = result<31:0>;",
          "    if setflags then",
          "        PSTATE.N = result<63>;",
          "        PSTATE.Z = IsZeroBit(result<63:0>);",
          "        // PSTATE.C, PSTATE.V unchanged"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Multiply Long multiplies two 32-bit unsigned values to produce a 64-bit result.",
          "In A32 instructions, the condition flags can optionally be updated based on the result. Use of this option adversely",
          "affects performance on many implementations."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "     <RdLo>          Is the general-purpose destination register for the lower 32 bits of the result, encoded in the \"RdLo\"",
          "                     field.",
          "     <RdHi>          Is the general-purpose destination register for the upper 32 bits of the result, encoded in the \"RdHi\"",
          "                     field.",
          "     <Rn>            Is the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.",
          "     <Rm>            Is the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600f10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa90f050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "272",
      "names": [
        "UQADD16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum1 = UInt(R[n]<15:0>) + UInt(R[m]<15:0>);",
          "          sum2 = UInt(R[n]<31:16>) + UInt(R[m]<31:16>);",
          "          R[d]<15:0> = UnsignedSat(sum1, 16);",
          "          R[d]<31:16> = UnsignedSat(sum2, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturating Add 16 performs two unsigned 16-bit integer additions, saturates the results to the 16-bit",
          "unsigned integer range 0 <= x <= 216 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 0 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600f90",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa80f050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "273",
      "names": [
        "UQADD8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum1 = UInt(R[n]<7:0>) + UInt(R[m]<7:0>);",
          "    sum2 = UInt(R[n]<15:8>) + UInt(R[m]<15:8>);",
          "    sum3 = UInt(R[n]<23:16>) + UInt(R[m]<23:16>);",
          "          sum4 = UInt(R[n]<31:24>) + UInt(R[m]<31:24>);",
          "          R[d]<7:0>   = UnsignedSat(sum1, 8);",
          "          R[d]<15:8> = UnsignedSat(sum2, 8);",
          "          R[d]<23:16> = UnsignedSat(sum3, 8);",
          "          R[d]<31:24> = UnsignedSat(sum4, 8);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturating Add 8 performs four unsigned 8-bit integer additions, saturates the results to the 8-bit unsigned",
          "integer range 0 <= x <= 28 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfaa0f050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "274",
      "names": [
        "UQASX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff = UInt(R[n]<15:0>) - UInt(R[m]<31:16>);",
          "          sum = UInt(R[n]<31:16>) + UInt(R[m]<15:0>);",
          "          R[d]<15:0> = UnsignedSat(diff, 16);",
          "          R[d]<31:16> = UnsignedSat(sum, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturating Add and Subtract with Exchange exchanges the two halfwords of the second operand,",
          "performs one unsigned 16-bit integer addition and one unsigned 16-bit subtraction, saturates the results to the 16-bit",
          "unsigned integer range 0 <= x <= 216 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfae0f050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "275",
      "names": [
        "UQSAX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);",
          "          diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);",
          "          R[d]<15:0> = UnsignedSat(sum, 16);",
          "          R[d]<31:16> = UnsignedSat(diff, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturating Subtract and Add with Exchange exchanges the two halfwords of the second operand,",
          "performs one unsigned 16-bit integer subtraction and one unsigned 16-bit addition, saturates the results to the 16-bit",
          "unsigned integer range 0 <= x <= 216 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600f70",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfad0f050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "276",
      "names": [
        "UQSUB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);",
          "          diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);",
          "          R[d]<15:0> = UnsignedSat(diff1, 16);",
          "          R[d]<31:16> = UnsignedSat(diff2, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturating Subtract 16 performs two unsigned 16-bit integer subtractions, saturates the results to the",
          "16-bit unsigned integer range 0 <= x <= 216 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06600ff0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfac0f050",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "277",
      "names": [
        "UQSUB8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);",
          "    diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);",
          "    diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);",
          "          diff4 = UInt(R[n]<31:24>) - UInt(R[m]<31:24>);",
          "          R[d]<7:0>   = UnsignedSat(diff1, 8);",
          "          R[d]<15:8> = UnsignedSat(diff2, 8);",
          "          R[d]<23:16> = UnsignedSat(diff3, 8);",
          "          R[d]<31:24> = UnsignedSat(diff4, 8);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturating Subtract 8 performs four unsigned 8-bit integer subtractions, saturates the results to the 8-bit",
          "unsigned integer range 0 <= x <= 28 - 1, and writes the results to the destination register."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x0780f010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb70f000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "278",
      "names": [
        "USAD8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    absdiff1 = Abs(UInt(R[n]<7:0>)   - UInt(R[m]<7:0>));",
          "    absdiff2 = Abs(UInt(R[n]<15:8>) - UInt(R[m]<15:8>));",
          "    absdiff3 = Abs(UInt(R[n]<23:16>) - UInt(R[m]<23:16>));",
          "          absdiff4 = Abs(UInt(R[n]<31:24>) - UInt(R[m]<31:24>));",
          "          result = absdiff1 + absdiff2 + absdiff3 + absdiff4;",
          "          R[d] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Sum of Absolute Differences performs four unsigned 8-bit subtractions, and adds the absolute values of",
          "the differences together."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 1 1 0 0 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE USAD8;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x07800010",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 1 0 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Ra == '1111' then SEE USAD8;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); a = UInt(Ra);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfb700000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "279",
      "names": [
        "USADA8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    absdiff1 = Abs(UInt(R[n]<7:0>)        - UInt(R[m]<7:0>));",
          "    absdiff2 = Abs(UInt(R[n]<15:8>)       - UInt(R[m]<15:8>));",
          "    absdiff3 = Abs(UInt(R[n]<23:16>)      - UInt(R[m]<23:16>));",
          "    absdiff4 = Abs(UInt(R[n]<31:24>)      - UInt(R[m]<31:24>));",
          "    result = UInt(R[a]) + absdiff1 +      absdiff2 + absdiff3 + absdiff4;",
          "    R[d] = result<31:0>;"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Sum of Absolute Differences and Accumulate performs four unsigned 8-bit subtractions, and adds the",
          "absolute values of the differences to a 32-bit accumulate operand."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<Ra>               Is the third general-purpose source register holding the addend, encoded in the \"Ra\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1",
              "size": 7,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 5,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm5",
              "size": 5,
              "type": 2
            },
            {
              "name": "sh",
              "size": 1,
              "type": 3
            },
            {
              "name": "0 1",
              "size": 2,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);",
            "(shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);",
            "if d == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06e00010",
          "mnemonics": [
            {
              "constraint": " sh = 1.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>"
                }
              ],
              "name": "Arithmetic shift right variant"
            },
            {
              "constraint": " sh = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
                }
              ],
              "name": "Logical shift left variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "sh",
              "size": 1,
              "type": 3
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0",
              "size": 1,
              "type": 5
            },
            {
              "name": "imm3",
              "size": 3,
              "type": 2
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "imm2",
              "size": 2,
              "type": 2
            },
            {
              "name": "(0)",
              "size": 1,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 5,
              "type": 0
            }
          ],
          "decode": [
            "if sh == '1' && (imm3:imm2) == '00000' then SEE USAT16;",
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);",
            "(shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3800000",
          "mnemonics": [
            {
              "constraint": " sh = 1 && !(imm3 == 000 && imm2 == 00).",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>"
                }
              ],
              "name": "Arithmetic shift right variant"
            },
            {
              "constraint": " sh = 0.",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
                }
              ],
              "name": "Logical shift left variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "280",
      "names": [
        "USAT",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    operand = Shift(R[n], shift_t, shift_n, PSTATE.C); // PSTATE.C ignored",
          "    (result, sat) = UnsignedSatQ(SInt(operand), saturate_to);",
          "    R[d] = ZeroExtend(result, 32);",
          "    if sat then",
          "        PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturate saturates an optionally-shifted signed value to a selected unsigned range.",
          "This instruction sets PSTATE.Q to 1 if the operation saturates."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<imm>           Is the bit position for saturation, in the range 0 to 31, encoded in the \"sat_imm\" field.",
          "<Rn>            Is the general-purpose source register, encoded in the \"Rn\" field.",
          "<amount>        For encoding A1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in",
          "                the \"imm5\" field.",
          "                For encoding A1: is the shift amount, in the range 1 to 32 encoded in the \"imm5\" field as <amount>",
          "                modulo 32.",
          "                For encoding T1: is the optional shift amount, in the range 0 to 31, defaulting to 0 and encoded in",
          "                the \"imm3:imm2\" field.",
          "                For encoding T1: is the shift amount, in the range 1 to 31 encoded in the \"imm3:imm2\" field as",
          "                <amount>."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 0",
              "size": 8,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 4,
              "type": 0
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 0 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);",
            "if d == 15 || n == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06e00f30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 (0) 1 1 1 0 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 0 (0) (0)",
              "size": 4,
              "type": 5
            },
            {
              "name": "sat_imm",
              "size": 4,
              "type": 0
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); saturate_to = UInt(sat_imm);",
            "if d == 15 || n == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xf3a00000",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "281",
      "names": [
        "USAT16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    (result1, sat1) = UnsignedSatQ(SInt(R[n]<15:0>), saturate_to);",
          "    (result2, sat2) = UnsignedSatQ(SInt(R[n]<31:16>), saturate_to);",
          "          R[d]<15:0> = ZeroExtend(result1, 16);",
          "          R[d]<31:16> = ZeroExtend(result2, 16);",
          "          if sat1 || sat2 then",
          "              PSTATE.Q = '1';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Saturate 16 saturates two signed 16-bit values to a selected unsigned range.",
          "This instruction sets PSTATE.Q to 1 if the operation saturates."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<imm>              Is the bit position for saturation, in the range 0 to 15, encoded in the \"sat_imm\" field.",
          "<Rn>               Is the general-purpose source register, encoded in the \"Rn\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06500f50",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfae0f040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "282",
      "names": [
        "USAX",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    sum = UInt(R[n]<15:0>) + UInt(R[m]<31:16>);",
          "    diff = UInt(R[n]<31:16>) - UInt(R[m]<15:0>);",
          "          R[d]<15:0> = sum<15:0>;",
          "          R[d]<31:16> = diff<15:0>;",
          "          PSTATE.GE<1:0> = if sum >= 0x10000 then '11' else '00';",
          "          PSTATE.GE<3:2> = if diff >= 0 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Subtract and Add with Exchange exchanges the two halfwords of the second operand, performs one",
          "unsigned 16-bit integer subtraction and one unsigned 16-bit addition, and writes the results to the destination",
          "register. It sets PSTATE.GE according to the results."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 0 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06500f70",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfad0f040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "283",
      "names": [
        "USUB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = UInt(R[n]<15:0>) - UInt(R[m]<15:0>);",
          "    diff2 = UInt(R[n]<31:16>) - UInt(R[m]<31:16>);",
          "    R[d]<15:0> = diff1<15:0>;",
          "          R[d]<31:16> = diff2<15:0>;",
          "          PSTATE.GE<1:0> = if diff1 >= 0 then '11' else '00';",
          "          PSTATE.GE<3:2> = if diff2 >= 0 then '11' else '00';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Subtract 16 performs two 16-bit unsigned integer subtractions, and writes the results to the destination",
          "register. It sets PSTATE.GE according to the results of the subtractions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 0 1 0 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "(1) (1) (1) (1) 1 1 1 1",
              "size": 8,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06500ff0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rn",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "0 1 0 0",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);",
            "if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfac0f040",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "284",
      "names": [
        "USUB8",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    diff1 = UInt(R[n]<7:0>) - UInt(R[m]<7:0>);",
          "    diff2 = UInt(R[n]<15:8>) - UInt(R[m]<15:8>);",
          "    diff3 = UInt(R[n]<23:16>) - UInt(R[m]<23:16>);",
          "          diff4 = UInt(R[n]<31:24>) -    UInt(R[m]<31:24>);",
          "          R[d]<7:0>   = diff1<7:0>;",
          "          R[d]<15:8> = diff2<7:0>;",
          "          R[d]<23:16> = diff3<7:0>;",
          "          R[d]<31:24> = diff4<7:0>;",
          "          PSTATE.GE<0> = if diff1 >=     0   then   '1'   else   '0';",
          "          PSTATE.GE<1> = if diff2 >=     0   then   '1'   else   '0';",
          "          PSTATE.GE<2> = if diff3 >=     0   then   '1'   else   '0';",
          "          PSTATE.GE<3> = if diff4 >=     0   then   '1'   else   '0';"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Subtract 8 performs four 8-bit unsigned integer subtractions, and writes the results to the destination",
          "register. It sets PSTATE.GE according to the results of the subtractions."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE UXTB;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x006e0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE UXTB;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa50f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "285",
      "names": [
        "UXTAB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = R[n] + ZeroExtend(rotated<7:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Extend and Add Byte extracts an 8-bit value from a register, zero-extends it to 32 bits, adds the result to",
          "the value in another register, and writes the final result to the destination register. The instruction can specify a",
          "rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "                     16           when rotate = 10",
          "                     24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 0 0",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE UXTB16;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x006c0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE UXTB16;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa30f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "286",
      "names": [
        "UXTAB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d]<15:0> = R[n]<15:0> + ZeroExtend(rotated<7:0>, 16);",
          "    R[d]<31:16> = R[n]<31:16> + ZeroExtend(rotated<23:16>, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Extend and Add Byte 16 extracts two 8-bit values from a register, zero-extends them to 16 bits each, adds",
          "the results to two 16-bit values from another register, and writes the final results to the destination register. The",
          "instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit values."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "                     16           when rotate = 10",
          "                     24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE UXTH;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);               rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x006f0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 0 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "1 1 1 1",
              "size": 4,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "if Rn == '1111' then SEE UXTH;",
            "d = UInt(Rd); n = UInt(Rn); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa10f080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "287",
      "names": [
        "UXTAH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = R[n] + ZeroExtend(rotated<15:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Extend and Add Halfword extracts a 16-bit value from a register, zero-extends it to 32 bits, adds the result",
          "to a value from another register, and writes the final result to the destination register. The instruction can specify a",
          "rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rn>               Is the first general-purpose source register, encoded in the \"Rn\" field.",
          "<Rm>               Is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "                     16           when rotate = 10",
          "                     24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06ef0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 0 1 0 1 1",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);   rotation = 0;"
          ],
          "mask": "0x0000b2c0",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTB{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa5ff080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTB{<c>}.W {<Rd>,} <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "UXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "288",
      "names": [
        "UXTB",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = ZeroExtend(rotated<7:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to 32 bits, and writes the result to the",
          "destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>            Is the general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>        Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                (omitted) when rotate = 00",
          "                8            when rotate = 01",
          "                16           when rotate = 10",
          "                24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 0 0 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06cf0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa3ff080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "289",
      "names": [
        "UXTB16",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d]<15:0> = ZeroExtend(rotated<7:0>, 16);",
          "    R[d]<31:16> = ZeroExtend(rotated<23:16>, 16);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Extend Byte 16 extracts two 8-bit values from a register, zero-extends them to 16 bits each, and writes",
          "the results to the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting",
          "the 8-bit values."
        ]
      },
      "symbols": {
        "lines": [
          "<c>                See Standard assembler syntax fields on page F2-2506.",
          "<q>                See Standard assembler syntax fields on page F2-2506.",
          "<Rd>               Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>               For encoding A1: is the general-purpose source register, encoded in the \"Rm\" field.",
          "                   For encoding T1: is the second general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>           Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                   (omitted) when rotate = 00",
          "                   8            when rotate = 01",
          "                   16           when rotate = 10",
          "                   24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 1 1 0 1 1 1 1 1 1 1 1",
              "size": 12,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "(0) (0) 0 1 1 1",
              "size": 6,
              "type": 5
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE;"
          ],
          "mask": "0x06ff0070",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 0 0 1 0 1 0",
              "size": 10,
              "type": 5
            },
            {
              "name": "Rs",
              "size": 3,
              "type": 1
            },
            {
              "name": "Rd",
              "size": 3,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd);       m = UInt(Rm);   rotation = 0;"
          ],
          "mask": "0x0000b280",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTH{<c>}{<q>} {<Rd>,} <Rm>"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 1 0 1 0 0 0 0 1 1 1 1 1 1 1 1 1",
              "size": 20,
              "type": 5
            },
            {
              "name": "Rd",
              "size": 4,
              "type": 1
            },
            {
              "name": "1 (0)",
              "size": 2,
              "type": 5
            },
            {
              "name": "rotate",
              "size": 2,
              "type": 0
            },
            {
              "name": "Rm",
              "size": 4,
              "type": 1
            }
          ],
          "decode": [
            "d = UInt(Rd); m = UInt(Rm); rotation = UInt(rotate:'000');",
            "if d == 15 || m == 15 then UNPREDICTABLE; // ARMv8-A removes UNPREDICTABLE for R13"
          ],
          "mask": "0xfa1ff080",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "UXTH{<c>}.W {<Rd>,} <Rm>// <Rd>, <Rm> can be represented in T1"
                },
                {
                  "aliases": [],
                  "value": "UXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "290",
      "names": [
        "UXTH",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    rotated = ROR(R[m], rotation);",
          "    R[d] = ZeroExtend(rotated<15:0>, 32);"
        ]
      },
      "summary": {
        "lines": [
          "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends it to 32 bits, and writes the result to",
          "the destination register. The instruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit",
          "value."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506.",
          "<Rd>            Is the general-purpose destination register, encoded in the \"Rd\" field.",
          "<Rm>            Is the general-purpose source register, encoded in the \"Rm\" field.",
          "<amount>        Is the rotate amount, encoded in the \"rotate\" field. It can have the following values:",
          "                (omitted) when rotate = 00",
          "                8            when rotate = 01",
          "                16           when rotate = 10",
          "                24           when rotate = 11"
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 1 0",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0320f002",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "WFE{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1 0 0 1 0 0 0 0 0",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0000bf20",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "WFE{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 1 0",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3af8002",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "WFE{<c>}.W"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "291",
      "names": [
        "WFE",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if EventRegistered() then",
          "        ClearEventRegister();",
          "    else",
          "        if PSTATE.EL == EL0 then",
          "            AArch32.CheckForWFxTrap(EL1, TRUE);",
          "        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then",
          "            AArch32.CheckForWFxTrap(EL2, TRUE);",
          "        if HaveEL(EL3) && PSTATE.M != M32_Monitor then",
          "            AArch32.CheckForWFxTrap(EL3, TRUE);",
          "        WaitForEvent();"
        ]
      },
      "summary": {
        "lines": [
          "Wait For Event is a hint instruction that permits the PE to enter a low-power state until one of a number of events",
          "occurs, including events signaled by executing the SEV instruction on any PE in the multiprocessor system. For more",
          "information, see Wait For Event and Send Event on page G1-3888.",
          "As described in Wait For Event and Send Event on page G1-3888, the execution of a WFE instruction that would",
          "otherwise cause entry to a low-power state can be trapped to a higher Exception level, see:",
          "          Traps to Undefined mode of PL0 execution of WFE and WFI instructions on page G1-3904.",
          "          Traps to Hyp mode of Non-secure PL0 and PL1 execution of WFE and WFI instructions on page G1-3918.",
          "          Traps to Monitor mode of the execution of WFE and WFI instructions in modes other than Monitor mode on",
          "page G1-3928."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 1 1",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0320f003",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "WFI{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1 0 0 1 1 0 0 0 0",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0000bf30",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "WFI{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 1 1",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3af8003",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "WFI{<c>}.W"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "292",
      "names": [
        "WFI",
        ""
      ],
      "operation": {
        "lines": [
          "if ConditionPassed() then",
          "    EncodingSpecificOperations();",
          "    if !InterruptPending() then",
          "        if PSTATE.EL == EL0 then",
          "            AArch32.CheckForWFxTrap(EL1, FALSE);",
          "        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then",
          "            AArch32.CheckForWFxTrap(EL2, FALSE);",
          "        if HaveEL(EL3) && PSTATE.M != M32_Monitor then",
          "            AArch32.CheckForWFxTrap(EL3, FALSE);",
          "        WaitForInterrupt();"
        ]
      },
      "summary": {
        "lines": [
          "Wait For Interrupt is a hint instruction that permits the PE to enter a low-power state until one of a number of",
          "asynchronous events occurs. For more information, see Wait For Interrupt on page G1-3891.",
          "As described in Wait For Interrupt on page G1-3891, the execution of a WFI instruction that would otherwise cause",
          "entry to a low-power state can be trapped to a higher Exception level, see:",
          "          Traps to Undefined mode of PL0 execution of WFE and WFI instructions on page G1-3904.",
          "          Traps to Hyp mode of Non-secure PL0 and PL1 execution of WFE and WFI instructions on page G1-3918.",
          "          Traps to Monitor mode of the execution of WFE and WFI instructions in modes other than Monitor mode on",
          "page G1-3928."
        ]
      },
      "symbols": {
        "lines": [
          "<c>             See Standard assembler syntax fields on page F2-2506.",
          "<q>             See Standard assembler syntax fields on page F2-2506."
        ]
      }
    },
    {
      "decode": {
        "lines": []
      },
      "encodings": [
        {
          "bits": [
            {
              "name": "!=1111",
              "size": 4,
              "type": 4
            },
            {
              "name": "0 0 1 1 0 0 1 0 0 0 0 0 (1) (1) (1) (1) (0) (0) (0) (0) 0 0 0 0 0 0 0 1",
              "size": 28,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0320f001",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "YIELD{<c>}{<q>}"
                }
              ],
              "name": "A1 variant"
            }
          ],
          "name": "A1",
          "variant": "[Arm Bits32 Archetype (0x200000021)]"
        },
        {
          "bits": [
            {
              "name": "1 0 1 1 1 1 1 1 0 0 0 1 0 0 0 0",
              "size": 16,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0x0000bf10",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "YIELD{<c>}{<q>}"
                }
              ],
              "name": "T1 variant"
            }
          ],
          "name": "T1",
          "variant": "[Thumb Bits16 Archetype (0x200000012)]"
        },
        {
          "bits": [
            {
              "name": "1 1 1 1 0 0 1 1 1 0 1 0 (1) (1) (1) (1) 1 0 (0) 0 (0) 0 0 0 0 0 0 0 0 0 0 1",
              "size": 32,
              "type": 5
            }
          ],
          "decode": [
            "// No additional decoding required"
          ],
          "mask": "0xf3af8001",
          "mnemonics": [
            {
              "constraint": "",
              "mnemonics": [
                {
                  "aliases": [],
                  "value": "YIELD{<c>}.W"
                }
              ],
              "name": "T2 variant"
            }
          ],
          "name": "T2",
          "variant": "[Thumb Bits32 Archetype (0x200000022)]"
        }
      ],
      "id": "293",
      "names": [
        "YIELD",
        ""
      ],
      "operation": {
        "lines": []
      },
      "summary": {
        "lines": [
          "YIELD is a hint instruction. Software with a multithreading capability can use a YIELD instruction to indicate to the",
          "PE that it is performing a task, for example a spin-lock, that could be swapped out to improve overall system",
          "performance. The PE can use this hint to suspend and resume multiple software threads if it supports the capability.",
          "For more information about the recommended use of this instruction see The Yield instruction on page F1-2484."
        ]
      },
      "symbols": {
        "lines": []
      }
    }
]
